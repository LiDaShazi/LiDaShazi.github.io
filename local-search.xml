<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/02/14/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2025/02/14/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/02/14/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/02/14/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>算法时间复杂度：操作次数只要最高阶的项 O()：最差时间复杂度</p><p>实际需要考虑到操作所需时间，比如位运算和乘法运算的时间差距很大</p><h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序:"></a>选择排序:</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selectionSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-type">int</span> minindex = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minindex]) &#123;<br>                minindex = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i != minindex) &#123;<br>            <span class="hljs-built_in">swap</span>(arr[i], arr[minindex]);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printArr</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i: arr) &#123;<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; arr = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>    <span class="hljs-built_in">selectionSort</span>(arr);<br>    <span class="hljs-built_in">printArr</span>(arr);<br>&#125;<br><span class="hljs-comment">//时间复杂度：O(N2) 空间复杂度O(1)</span><br></code></pre></td></tr></table></figure><h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-built_in">swap</span>(arr[j], arr[j + <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//时间复杂度：O(N2) 空间复杂度O(1)</span><br></code></pre></td></tr></table></figure><h5 id="异或运算："><a href="#异或运算：" class="headerlink" title="异或运算："></a><strong>异或运算：</strong></h5><p>相同为0，不同为1 符号^  还可以理解为不进位相加</p><p>性质：（实质是同一位上的0和1的个数，奇数个1就是1，偶数个1就是0）</p><p>1.0^N&#x3D;N  N^N&#x3D;0</p><p>2.满足交换律和结合律</p><p>3.满足无序性，同一批数运算出来结果是相同的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap2</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>    arr[i] = arr[i] ^ arr[j];<br>    arr[j] = arr[i] ^ arr[j];<br>    arr[i] = arr[i] ^ arr[j];<br>&#125;<br><span class="hljs-comment">//能够这么做的前提是两个数不是同一块内存(会将两个数都洗成0)，数字可以相等</span><br><span class="hljs-comment">//原理在于当两个数的内存是同一块地址时，会同时改变两个数</span><br></code></pre></td></tr></table></figure><h5 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h5><p>1.在一个数组中，已知中有一种数出现了奇数次，其他的都出现了偶数次，找出这个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//偶数的都和成0了</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bitex</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        res = arr[i]^res;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.在一个数组中，已知中有两种数出现了奇数次，其他的都出现了偶数次，找出这两个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bitex2</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> eor = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        eor = eor ^ arr[i];<br>    &#125;<br>    <span class="hljs-type">int</span> group = eor &amp; (~eor + <span class="hljs-number">1</span>); <span class="hljs-comment">//提取出最右侧的1，剩下的都是0</span><br>    <span class="hljs-type">int</span> onlyOne = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> ((group &amp; arr[i]) != <span class="hljs-number">0</span>) &#123;<br>            onlyOne ^= arr[i];<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; onlyOne &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; (eor ^ onlyOne) &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//通过eor最低位一个不为1的位将原数组分成两组，一组那一位为0，一组为1，反正偶数个数的数字一定在一组，奇数个数的数字分别在两组</span><br></code></pre></td></tr></table></figure><h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &gt; <span class="hljs-number">0</span>; --j) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[j - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-built_in">swap</span>(arr[j], arr[j - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//逐步实现0~i范围上有序</span><br></code></pre></td></tr></table></figure><h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h5><p>只要是能够构建出一种排他性的问题就可以二分了，比如左边一定有，右边一定没有，又或是左边一定有，右边可能有，只需找一个</p><p>左右两侧与求的问题有关，并且确定可以利用条件甩掉一边就可以二分</p><p>1.在一个有序数组中，找某个数是否存在</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">nt <span class="hljs-title">binarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123; <span class="hljs-comment">//注意这里是&lt;=</span><br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (target == arr[mid]) &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.在一个有序数组中，找&gt;&#x3D;某个数最左侧的位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bigLeft</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (arr[mid] &gt;= target) &#123;<br>            ans = mid;<span class="hljs-comment">//只要是找到新的一定比原来记录的值的小</span><br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;;<br>&#125;<br><span class="hljs-comment">//一直二分到底直到结束，找到最小的那个数</span><br></code></pre></td></tr></table></figure><p>3.局部最小值问题，一个无序数组中，任何两个相邻的位置不同，求一个局部最小的位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLocalMin</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br><span class="hljs-comment">// arr[mid] &lt; arr[mid - 1]：确保 mid 比左邻居小。</span><br><span class="hljs-comment">// arr[mid] &lt; arr[mid + 1]：确保 mid 比右邻居小。</span><br><span class="hljs-comment">// 另外还需要考虑数组的边界：mid == 0 时没有左邻居，mid == arr.size() - 1 时没有右邻居。</span><br>        <span class="hljs-keyword">if</span> ((mid == <span class="hljs-number">0</span> || arr[mid] &lt; arr[mid - <span class="hljs-number">1</span>]) &amp;&amp; (mid == arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> || arr[mid] &lt; arr[mid + <span class="hljs-number">1</span>])) &#123;<br>            <span class="hljs-keyword">return</span> mid; <span class="hljs-comment">// 找到局部最小</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (arr[mid] &gt; arr[mid + <span class="hljs-number">1</span>]) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="对数器（随机样本产生器）"><a href="#对数器（随机样本产生器）" class="headerlink" title="对数器（随机样本产生器）"></a>对数器（随机样本产生器）</h5><p>abs(取绝对值)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//对数器</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">generateRandomArray</span><span class="hljs-params">(<span class="hljs-type">int</span> maxSize, <span class="hljs-type">int</span> maxValue)</span> </span>&#123;<br>    <span class="hljs-type">int</span> size = <span class="hljs-built_in">rand</span>() % (maxSize + <span class="hljs-number">1</span>);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(size)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>        arr[i] = <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">rand</span>() % (maxValue + <span class="hljs-number">1</span>) - <span class="hljs-built_in">rand</span>() % (maxValue + <span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><span class="hljs-comment">//用arr[i] = abs(rand() % (maxValue + 1) - rand() % (maxValue + 1));而不是arr[i]=rand() % (maxValue + 1)</span><br><span class="hljs-comment">//更偏向于 数值差异 的分布，而非均匀的单一随机数</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/12/17/C++%E9%9D%A2%E7%BB%8F/"/>
    <url>/2024/12/17/C++%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="1-讲一讲封装、继承、多态是什么？"><a href="#1-讲一讲封装、继承、多态是什么？" class="headerlink" title="1.讲一讲封装、继承、多态是什么？"></a>1.讲一讲封装、继承、多态是什么？</h3><p><strong>封装：</strong>封装指的是将数据（属性）和操作数据的行为（函数）封装到对象中，隐藏对象的内部细节，只暴露公共接口给外部使用。</p><p><strong>继承：</strong>派生类继承基类的数据成员和成员函数（基类私有成员可被继承，但是无法被访问），其中构造函数、析构函数、友元函数、静态数据变量、静态成员函数都不能被继承，但子类可以调用基类构造函数。派生类访问基类的共享资源 protected 成员对于所有派生类都是可用的，但对外隐藏。当父类中的成员变量或者类本身被final关键字修饰时，修饰的类不能被继承，修饰的成员函数不能重写或修改。</p><p><strong>多态：</strong>C++ 支持两种多态：</p><ol><li><strong>编译时多态</strong>（静态多态）：通过函数重载和运算符重载实现。</li><li><strong>运行时多态</strong>（动态多态）：通过虚函数（<code>virtual</code>）和继承实现。虚函数允许派生类重写基类方法。当基类的指针或引用指向派生类对象时，会调用派生类的实现，使得基类指针呈现不同的表现形式。</li></ol><h3 id="2-final标识符的作用是什么？"><a href="#2-final标识符的作用是什么？" class="headerlink" title="2. final标识符的作用是什么？"></a>2. final标识符的作用是什么？</h3><p>放在类的后面表示该类无法被继承，也就是阻止了从类的继承，放在虚函数后面该虚函数无法被重写，表示阻止虚函数的重载</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024-12-17</title>
    <link href="/2024/12/17/2024-12-17/"/>
    <url>/2024/12/17/2024-12-17/</url>
    
    <content type="html"><![CDATA[<h2 id="2024-12-17"><a href="#2024-12-17" class="headerlink" title="2024-12-17"></a>2024-12-17</h2><h4 id="NAT模式连接原理"><a href="#NAT模式连接原理" class="headerlink" title="NAT模式连接原理"></a>NAT模式连接原理</h4><p><img src="/images/2024-12-17-1.png" alt="NAT模式连接原理"></p><p>修改虚拟网段，虚拟网络编辑器</p><p>查看网关，vmnet8</p><h4 id="网络环境配置"><a href="#网络环境配置" class="headerlink" title="网络环境配置"></a>网络环境配置</h4><p>自动获取：首选项，网络，自动连接</p><p>手动获取：script（脚本）</p><p>vim  etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33(ens33网卡)</p><p><img src="/images/2024-12-17-2.png" alt="2"></p><h4 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h4><p>每个执行的程序称为一个进程，每个进程都分配一个ID号</p><p>每一个进程，都对应一个父进程，而这个父进程可以复制多个子进程</p><p>每个进程都可能以两种方式存在，前台与后台</p><p>一般系统的服务都以后台进程形式存在，而且都会常驻系统中，直到关机才结束</p><h5 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h5><p><strong>ps</strong>命令查看系统进程 -a 所有进程 -u以用户格式显示进程信息 -x显示后台进程运行参数</p><p><strong>ps -aux</strong></p><p><img src="/images/2024-12-17-3.png" alt="3"></p><p>ps-aux | grep xxx 过滤指令，将显示的内容进行过滤</p><p>查看父进程 ps -ef  PPID就是父进程</p><p>pstree 树状形式查看 -p显示pid -u显示所属用户</p><h5 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h5><p>kill [选项] 进程号   -9表示强制进程停止</p><p>killall 进程名称  支持通配符</p><p>1.踢掉jack的非法登录</p><p>ps -aux | grep sshd  找到进程号</p><p>kill 进程号</p><p>2.终止远程登录sshd</p><p>kill 进程号</p><p>3.终止多个gedit编辑器</p><p>killall gedit</p><p>4.强制关闭一个终端</p><p>ps -aux | grep bash</p><p>kill -9 进程号</p><h4 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h4><p>服务本质就是进程，但是运行在后台，通常会监听某个端口，等待其他程序的请求</p><p>systemctl&#x2F;service 服务名 [start|stop|restart|reload|status]  只是临时生效，重启系统后会恢复</p><p>telnet ip 端口 查看某个ip的某个端口是否打开</p><h5 id="查看服务"><a href="#查看服务" class="headerlink" title="查看服务"></a>查看服务</h5><p>1.使用setup 系统服务 就可以看到</p><p>2..&#x2F;etc&#x2F;init.d&#x2F;服务名称</p><h4 id="动态监控"><a href="#动态监控" class="headerlink" title="动态监控"></a>动态监控</h4><h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a><strong>进程</strong></h5><p><strong>top</strong>  -u监控某个user k杀死某个进程 -d多少秒刷新</p><p><img src="/images/2024-12-17-4.png" alt="4"></p><h5 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h5><p>netstat 查看网络服务</p><p>netstat -anp 查看所有的网络服务</p><p>netstat -anp | grep sshd</p><h4 id="RPM和YUM"><a href="#RPM和YUM" class="headerlink" title="RPM和YUM"></a>RPM和YUM</h4><p>rpm用户互联网下载包的打包和管理工具</p><p>rpm -qa | grep firfox  查看安装的包  </p><p><img src="/images/2024-12-17-5.png" alt="5"></p><p>rpm -qi firefox  具体信息</p><p>rpm -ql firefox 安装了哪些文件</p><p>rpm -qf &#x2F;etc&#x2F;passwd 文件全路径名  查询文件所属的软件包</p><p>rpm -e firefox 卸载软件包  </p><p>rpm -ivh RPM包全路径 安装软件</p><p><img src="/images/2024-12-17-6.png" alt="6"></p><p>yum是一个shell前端软件管理器，基于RPM包管理，能够从指定的服务器下载rpm包并进行安装，可以自动处理依赖关系，并安装所有依赖的软件包，前提是可以联网</p><p>yum list | grep xx  查看是否有需要安装的软件</p><p>yum install xxx 默认安装最新版本</p><h3 id="shell编程"><a href="#shell编程" class="headerlink" title="shell编程"></a>shell编程</h3><p>shell是命令行解释器，为用户提供了一个可以向linux内核发送请求以便运行程序的界面系统级程序，用户可以用shell启动，挂起，停止甚至是编写一些程序</p><h4 id="脚本格式"><a href="#脚本格式" class="headerlink" title="脚本格式"></a>脚本格式</h4><p>1.脚本一#!bin&#x2F;bash开头</p><p>2.脚本需要有可执行权限</p><h4 id="编写第一个shell脚本"><a href="#编写第一个shell脚本" class="headerlink" title="编写第一个shell脚本"></a>编写第一个shell脚本</h4><p>1.vim myshell.sh</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello,world!&quot;</span>   <span class="hljs-comment">#它是解释</span><br><span class="hljs-comment">#多行注释</span><br>:&lt;&lt;!<br><span class="hljs-comment">#内容</span><br>!<br></code></pre></td></tr></table></figure><p>2.给所有者一个执行权限</p><p>chmod 744 myshell.sh</p><p>3.执行</p><p>.&#x2F;myshell.sh  &#x2F;&#x2F;相对路径</p><p>&#x2F;root&#x2F;shell&#x2F;myshell.sh  &#x2F;&#x2F;绝对路径</p><p>(如果不给可执行权限，也可以直接用 sh .&#x2F;myshell.sh，但是不推荐)</p><h4 id="shell的变量"><a href="#shell的变量" class="headerlink" title="shell的变量"></a>shell的变量</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>1.变量分为系统变量和用户自定义变量</p><p>2.系统变量有：$HOME $PWD $SHELL $USER</p><p>3.显示shell中所有变量set</p><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>1.定义变量</p><p>A&#x3D;100  echo “A&#x3D;$A”</p><p>2.销毁变量</p><p>unset A echo “A&#x3D;$A”</p><p>3.静态变量，不能unset</p><p>readonly A&#x3D;99</p><h5 id="变量定义规则"><a href="#变量定义规则" class="headerlink" title="变量定义规则"></a>变量定义规则</h5><p>1.变量名称可以有字母，数字，下划线开头，但是不能以数字开头</p><p>2.等号两侧不能有空格</p><p>3.变量名称一般用大写</p><p>4.使用&#96;&#96;将命令括起来或者用$()，可以得到命令的结果为变量</p><h5 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h5><p><img src="/images/2024-12-17-7.png" alt="7"></p><p>vim &#x2F;etc&#x2F;profile</p><p>TOMCAT_HOME&#x3D;&#x2F;opt&#x2F;tomcat</p><p>export TOMCAT_HOME</p><p>注意：在输出之前，需要让其生效</p><p>source  &#x2F;etc&#x2F;profile</p><h5 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h5><p>当我们执行一个shell脚本时，如果希望获取到命令行的参数信息，就可以使用到为止参数变量，比如：.&#x2F;myshell.sh 100 200 , 这个就是一个执行shell的命令行，可以从myshell脚本中获取到参数信息</p><p>$n(n为数字，$0代表命令本身 $1-$9代表第一到第九个参数，十以上的参数需要用大括号包含，如${10})</p><p>$*(代表命令行中的所有参数，把所有参数看做一个整体)</p><p>$@(也代表命令行中所有的参数，不过他把每个参数去区分对待)</p><p>$#(代表命令行中参数的个数)</p><h5 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h5><p>$$(当前进程的进程号PID)</p><p>$!(后台运行的最后一个进程的进程号)</p><p>$?(最后一次执行命令的返回状态，如果这个变量的值为0，证明上一个命令正确执行，如果这个变量的值为非0，具体那个数由命令自己来决定，则证明上一个命令执行不正确)</p><p><img src="/images/2024-12-17-8.png" alt="8"></p><h4 id="shell运算符"><a href="#shell运算符" class="headerlink" title="shell运算符"></a>shell运算符</h4><p>1.$()  RESURT1&#x3D;$(((2+3)*4))</p><p>2.$[]  RESURT2&#x3D;$[(2+3)*4]</p><p>3.expr </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">TEMP=`expr 2 + 3`<br>RESURT3=`expr $TEMP \* 4`<br>echo &quot;RESURT3=$RESULT&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">这种才要给空格，另外两个不要给空格</span><br></code></pre></td></tr></table></figure><h4 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h4><p>[ condition ]   (注意condition前后要有空格)</p><h5 id="1-文件属性判断"><a href="#1-文件属性判断" class="headerlink" title="1. 文件属性判断"></a><strong>1. 文件属性判断</strong></h5><p>使用 <code>test</code> 命令或者 <code>[ ]</code> 表达式来判断文件的状态。</p><table><thead><tr><th>条件</th><th>含义</th></tr></thead><tbody><tr><td><code>-e file</code></td><td>文件存在</td></tr><tr><td><code>-f file</code></td><td>文件存在且是普通文件</td></tr><tr><td><code>-d file</code></td><td>文件存在且是目录</td></tr><tr><td><code>-r file</code></td><td>文件存在且可读</td></tr><tr><td><code>-w file</code></td><td>文件存在且可写</td></tr><tr><td><code>-x file</code></td><td>文件存在且可执行</td></tr><tr><td><code>-s file</code></td><td>文件存在且非空</td></tr><tr><td><code>file1 -nt file2</code></td><td><code>file1</code> 比 <code>file2</code> 更新</td></tr><tr><td><code>file1 -ot file2</code></td><td><code>file1</code> 比 <code>file2</code> 更旧</td></tr><tr><td><code>file1 -ef file2</code></td><td><code>file1</code> 和 <code>file2</code> 硬链接到同一个文件</td></tr></tbody></table><h5 id="2-字符串判断"><a href="#2-字符串判断" class="headerlink" title="2. 字符串判断"></a><strong>2. 字符串判断</strong></h5><p>用于比较字符串内容。</p><table><thead><tr><th>条件</th><th>含义</th></tr></thead><tbody><tr><td><code>-z str</code></td><td>字符串长度为 0</td></tr><tr><td><code>-n str</code></td><td>字符串长度大于 0</td></tr><tr><td><code>str1 = str2</code></td><td>字符串相等</td></tr><tr><td><code>str1 != str2</code></td><td>字符串不相等</td></tr><tr><td><code>[ str ]</code></td><td>字符串非空，相当于 <code>-n str</code> 的简写</td></tr></tbody></table><h5 id="3-数值判断"><a href="#3-数值判断" class="headerlink" title="3. 数值判断"></a><strong>3. 数值判断</strong></h5><p>用于比较数值大小。</p><table><thead><tr><th>条件</th><th>含义</th></tr></thead><tbody><tr><td><code>num1 -eq num2</code></td><td>等于</td></tr><tr><td><code>num1 -ne num2</code></td><td>不等于</td></tr><tr><td><code>num1 -gt num2</code></td><td>大于</td></tr><tr><td><code>num1 -lt num2</code></td><td>小于</td></tr><tr><td><code>num1 -ge num2</code></td><td>大于等于</td></tr><tr><td><code>num1 -le num2</code></td><td>小于等于</td></tr></tbody></table><h4 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h4><h5 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [ condition ];<br><br>    #程序<br><br>fi<br><br>或者<br><br>if [ condition]<br><br>   then <br><br>      #程序<br><br>   elif [ condition ]<br><br>    then<br><br>       #程序<br><br>fi<br></code></pre></td></tr></table></figure><h5 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">case variable in<br>    pattern1)<br>        # 当 variable 匹配 pattern1 时执行的命令<br>        command1<br>        ;;<br>    pattern2)<br>        # 当 variable 匹配 pattern2 时执行的命令<br>        command2<br>        ;;<br>    pattern3||pattern4)<br>        # 当 variable 匹配 pattern3 或 pattern4 时执行的命令<br>        command3<br>        ;;<br>    *)<br>        # 默认情况下（没有匹配时）执行的命令<br>        default_command<br>        ;;<br>esac<br></code></pre></td></tr></table></figure><p><img src="/%5Cimages%5C2024-12-17-9.png" alt="9"></p><h5 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for variable in list<br>do<br>    commands<br>done<br></code></pre></td></tr></table></figure><p><img src="/%5Cimages%5C2024-12-17-10.png" alt="10"></p><table><thead><tr><th>表达式</th><th>参数拆分方式</th><th>输出形式</th></tr></thead><tbody><tr><td><code>$*</code></td><td>不加引号时，会将参数按 <code>IFS</code> 分隔后拆分成多个部分</td><td>分裂后的多个单独参数</td></tr><tr><td><code>&quot;$*&quot;</code></td><td>加引号后，所有参数被拼接成一个整体，保留空格或其他分隔符</td><td>一个完整的字符串</td></tr><tr><td>“$@”</td><td>每个参数是独立的，保持原样</td><td>分裂后的多个单独参数</td></tr></tbody></table><p>C++风格</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for (( 初始化; 条件; 更新 ))<br>do<br>    commands<br>done<br></code></pre></td></tr></table></figure><h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">while [ 条件 ]<br>do<br>    commands<br>done<br></code></pre></td></tr></table></figure><p><img src="/images%5C2024-12-17-11.png" alt="2024-12-17-11"></p>]]></content>
    
    
    <categories>
      
      <category>学习日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024-12-13</title>
    <link href="/2024/12/13/2024-12-13/"/>
    <url>/2024/12/13/2024-12-13/</url>
    
    <content type="html"><![CDATA[<h2 id="2024-12-13"><a href="#2024-12-13" class="headerlink" title="2024-12-13"></a>2024-12-13</h2><h3 id="组管理和权限管理"><a href="#组管理和权限管理" class="headerlink" title="组管理和权限管理"></a>组管理和权限管理</h3><h4 id="组介绍："><a href="#组介绍：" class="headerlink" title="组介绍："></a><strong>组介绍：</strong></h4><p>linux每个用户都必须属于一个组，不能独立于组外，在linux每个文件有所有者，所在组，其他组的概念。</p><p>查看所有者：<strong>ls  -ahl</strong></p><p>修改所有者：<strong>chown（change owner)  用户名 文件名</strong></p><p>chown newowner:newgroup file 改变所有者和所有组</p><p>-R 如果是目录 使其下所有的子文件和目录递归生效</p><p>造成所有者和所在组可能不一样</p><p>修改文件所在组：<strong>chgrp 组名 文件名</strong></p><p><strong>除文件的所有者和所有则的文件外，其他用户就是其他组</strong></p><h4 id="权限介绍"><a href="#权限介绍" class="headerlink" title="权限介绍"></a>权限介绍</h4><h5 id="案例详解"><a href="#案例详解" class="headerlink" title="案例详解"></a>案例详解</h5><p><strong>-rw-r–r– 1  tom police 6 3月 18 19:24 ok.txt</strong></p><p>文件类型：</p><p>-普通文件 d目录 l软链接 c字符设备【键盘，鼠标】 b块文件，硬盘</p><p>-文件类型  rw-文件所有者权限 r–文件所在组权限 r–文件其他组用户权限</p><p>1 如果是文件，表示硬链接数目  如果是目录则表示该目录的子目录个数</p><p>tom 代表文件所有者 police 代表文件所在组</p><p>6代表文件大小 如果是目录会显示4096</p><p>3月 18 19:24 文件最后修改时间</p><p>ok.txt 文件名称</p><h5 id="rwx权限介绍"><a href="#rwx权限介绍" class="headerlink" title="rwx权限介绍"></a>rwx权限介绍</h5><p>rwx作用到文件 r代表可读 </p><p>w代表可写，但不代表可以删除，删除一个文件的前题是对该文件所在的目录有写权限，才能删除该文件</p><p>x代表可执行</p><p>rwx作用到目录 r代表可以读取，ls查看目录内容</p><p>w代表可以修改，目录内创建+删除+重命名目录</p><p>x代表可执行，可以进入该目录</p><h4 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h4><p><strong>chmod</strong> 修改文件或者目录权限</p><p><strong>第一种方式： + - &#x3D; 变更权限</strong></p><p>u所有者 g所在组 o其他人 a所有人</p><p>chmod u-x,g+w abc.txt</p><p><strong>第二种方式：通过数字变更权限</strong></p><p> r &#x3D; 4 w &#x3D; 2 x &#x3D; 1</p><p>chmod  755 abc.txt</p><h3 id="实践：警察和土匪游戏"><a href="#实践：警察和土匪游戏" class="headerlink" title="实践：警察和土匪游戏"></a>实践：警察和土匪游戏</h3><p>police： jack, jerry  bandit(土匪) ： xh xq</p><h4 id="1-创建组"><a href="#1-创建组" class="headerlink" title="1.创建组"></a>1.创建组</h4><h4 id="2-创建用户"><a href="#2-创建用户" class="headerlink" title="2.创建用户"></a>2.创建用户</h4><h4 id="3-jack创建一个文件，自己可以读写，本组人可以读，其他组没有任何权限"><a href="#3-jack创建一个文件，自己可以读写，本组人可以读，其他组没有任何权限" class="headerlink" title="3. jack创建一个文件，自己可以读写，本组人可以读，其他组没有任何权限"></a>3. jack创建一个文件，自己可以读写，本组人可以读，其他组没有任何权限</h4><h4 id="4-jack修改该文件，让其他组人可以读，本组人可以读写"><a href="#4-jack修改该文件，让其他组人可以读，本组人可以读写" class="headerlink" title="4. jack修改该文件，让其他组人可以读，本组人可以读写"></a>4. jack修改该文件，让其他组人可以读，本组人可以读写</h4><h4 id="5-xh-投靠警察，使小红可以读写jack的文件"><a href="#5-xh-投靠警察，使小红可以读写jack的文件" class="headerlink" title="5. xh 投靠警察，使小红可以读写jack的文件"></a>5. xh 投靠警察，使小红可以读写jack的文件</h4><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><h4 id="定时任务调度"><a href="#定时任务调度" class="headerlink" title="定时任务调度"></a>定时任务调度</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>crontab -e编辑定时任务  -l查询crontab任务 -r删除当前用户所有的crontab任务</p><p>service crond restart 重启任务调度</p><p>如果只是简单的任务，不用写脚本，直接在crontab加入任务即可，对于比较浮渣的任务，需要写脚本（shell)</p><h5 id="任务步骤"><a href="#任务步骤" class="headerlink" title="任务步骤"></a>任务步骤</h5><p><strong>占位符说明</strong> </p><p>每行的语法为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">复制代码<br>分钟 小时 日 月 星期 命令<br></code></pre></td></tr></table></figure><p>各个占位符的具体含义和范围是：</p><table><thead><tr><th>占位符</th><th>描述</th><th>取值范围</th></tr></thead><tbody><tr><td>分钟</td><td>指定分钟</td><td>0-59</td></tr><tr><td>小时</td><td>指定小时</td><td>0-23</td></tr><tr><td>日</td><td>指定日期</td><td>1-31</td></tr><tr><td>月</td><td>指定月份</td><td>1-12 或 <code>JAN-DEC</code></td></tr><tr><td>星期</td><td>指定星期几</td><td>0-7 (0 和 7 都表示星期天) 或 <code>SUN-SAT</code></td></tr><tr><td>命令</td><td>要执行的命令</td><td>任意有效的 Shell 命令</td></tr></tbody></table><p>特殊符号</p><ol><li><p>**星号 (<code>*</code>)**：表示任意值。例如，<code>* * * * *</code> 表示每分钟执行一次任务。</p></li><li><p>**逗号 (<code>,</code>)**：列举多个值。例如，<code>0,15,30,45 * * * *</code> 表示每小时的第 0、15、30 和 45 分钟执行。</p></li><li><p>**连字符 (<code>-</code>)**：表示范围。例如，<code>1-5 * * * *</code> 表示每小时的第 1 到第 5 分钟执行。</p></li><li><p>**斜线 (<code>*/n</code>)**：表示步进。例如，<code>*/5 * * * *</code> 表示每 5 分钟执行一次。</p></li><li><p>**问号 (<code>?</code>)**：在某些 Crontab 变种中，用于占位（通常与 <code>星期</code> 或 <code>日期</code> 配合使用，表示不指定）。这种写法多用于 Quartz 定时器，而非传统的 Crontab。</p></li><li><p>**井号 (<code>#</code>)**：用于指定每月的第几周。例如，<code>5 0 1 * 4#2</code> 表示在每月的第二个星期四的 00:05 执行。</p></li><li><p>cd &#x2F;home&#x2F;</p></li><li><p>vim mytask.sh</p></li><li><p>输入date &gt;&gt;&#x2F;tmp&#x2F;mydate.txt</p></li><li><p>修改权限为可执行 chmod 744 mytask.sh</p></li><li><p>crontab -e (所用定时任务都在一个文件里面)</p></li><li><p>*&#x2F;1 * * * * ls -l &#x2F;etc &gt;&gt; &#x2F;tmp&#x2F;to.txt</p><p>*&#x2F;1 * * * * &#x2F;home&#x2F;mytask.sh</p></li></ol><h3 id="磁盘分区和挂载"><a href="#磁盘分区和挂载" class="headerlink" title="磁盘分区和挂载"></a>磁盘分区和挂载</h3><h4 id="分区基础知识"><a href="#分区基础知识" class="headerlink" title="分区基础知识"></a>分区基础知识</h4><p>1 mbr分区，gtp分区，主分区数量增加，分区最大容量增加</p><p>2 windows磁盘分区 主分区 扩展分区（可以分为逻辑分区）</p><p>3 linux分区 linux无论有几个分区，分给哪一目录使用，归根结底只有一个根目录，一个独立且唯一的文件结构，linux中每个分区都是来组成文件系统的一部分</p><p>linux采用了一种叫做mount(挂载)的处理方法，它的整个文件系统包含了一整套的文件和目录，且将一个分区和一个目录联系起来。</p><p>4 在linux中如何对硬盘进行标号</p><p><strong>lsblk -f&#x2F;lsblk</strong>查看系统分区域挂载的情况</p><p><strong><code>sdx~</code> 的含义</strong></p><ul><li>**<code>s</code>**：表示 SCSI（包括 SATA 和 SAS）设备，但实际上现代系统中也用来标识基于 USB 或 NVMe 接口的设备。</li><li>**<code>d</code>**：代表磁盘（Disk）。</li><li><code>x</code>：代表设备的字母序号，a表示第一个磁盘，b表示第二个磁盘，依此类推。</li></ul><p>设备后缀</p><ul><li><code>sda1</code>、<code>sda2</code> 等：数字后缀表示该磁盘上的分区编号。从5开始后就是逻辑分区</li></ul><h4 id="增加一块磁盘"><a href="#增加一块磁盘" class="headerlink" title="增加一块磁盘"></a>增加一块磁盘</h4><p>1.虚拟机添加磁盘</p><p>2.分区 fdisk &#x2F;dev&#x2F;sdb   n   p   1   1   w</p><p>3.格式化 mkfs -t ext4 &#x2F;dev&#x2F;sdb1</p><p>4.挂载 先创建一个 &#x2F;home&#x2F;newdisk ,挂载 mount &#x2F;dev&#x2F;sdb1 &#x2F;home&#x2F;newdisk</p><p>5.设置永久挂载  vim &#x2F;etc&#x2F;fstab</p><p>&#x2F;dev&#x2F;sdb1         &#x2F;home&#x2F;newdisk        ext4     defaults       0 0</p><h4 id="磁盘情况查询"><a href="#磁盘情况查询" class="headerlink" title="磁盘情况查询"></a>磁盘情况查询</h4><p><strong>df -h</strong>  系统整体使用情况</p><p><strong>du -h &#x2F;目录</strong> </p><p>某个目录使用情况   -s 指定目录占用大小汇总  -a含文件    -c列出明细的同时，增加汇总值    –max-depth&#x3D;1 子目录深度</p><p>du -ach –max-depth&#x3D;1 &#x2F;opt</p><p>统计某个目录下有多少文件</p><p>ls -l &#x2F;home | grep “^-“ | wc -l  wc是统计的意思</p><p>统计&#x2F;home文件夹下目录个数</p><p>ls -l &#x2F;home | grep “^d” | wc -l </p><p>统计&#x2F;home文件夹下文件个数，包括子文件夹里的</p><p>ls -lR &#x2F;home | grep “^d” | wc -l </p><p>以树状形式查看目录</p><p>yum install tree</p><p>tree &#x2F;home&#x2F;</p>]]></content>
    
    
    <categories>
      
      <category>学习日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024-12-12</title>
    <link href="/2024/12/12/2024-12-12/"/>
    <url>/2024/12/12/2024-12-12/</url>
    
    <content type="html"><![CDATA[<h2 id="2024-12-12"><a href="#2024-12-12" class="headerlink" title="2024-12-12"></a>2024-12-12</h2><h3 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h3><p>YAML Front Matter 是一种用于在文本文件（如Markdown文件）中定义元数据的格式。它通常位于文件的顶部，由三个连续的短横线（<code>---</code>）包围的区域，用于指定个别文件的变量和配置信息。这些元数据可以包括文件的标题、日期、标签、类别等，也可以用于控制页面的布局和版本控制等。</p><p>YAML（Yet Another Markup Language）是一种轻量级的数据序列化格式，它易于人类阅读和编写，同时也易于机器解析和生成。</p><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p><strong>linux系统是一个多用户多任务的操作系统，任何一个使用系统资源的用户，都必须向系统管理员申请一个账号，然后以这个账号的身份进入系统</strong></p><p>用户归属于用户组  每个用户属于一个或多个组  root属于root组</p><p>家目录 &#x2F;home&#x2F; 目录下有各个创建的用户对应的家目录，当用户登录时自动进入自己的家目录</p><p><strong>添加用户</strong></p><p>useradd [选项，可以不选] 用户名   没有指定家目录，会自动创建与该用户同名的子家目录，并将该用户添加到家目录中，也就是创建&#x2F;home的目录</p><p><strong>useradd -d &#x2F;home&#x2F;llj</strong> 向指定目录添加用户 直接建新目录</p><p><strong>用户组没有指定，自动创建同名用户组</strong></p><p><strong>cd 切换目录</strong> change director</p><p><strong>passwd 用户名</strong> 指定密码</p><p><strong>mkdir</strong> make director 创建目录 添加用户</p><p><strong>删除目录</strong></p><p><strong>userdel 用户 删除用户</strong>，但是保留家目录</p><p><strong>userdel -r 用户 删除用户</strong>，并且家目录</p><p><strong>在删除用户时，一般要保留家目录，因为有一些文件需要保留</strong></p><p><strong>id 用户</strong>  查询用户信息</p><p><strong>su - 切换用户名</strong>  高权限用户进入低权限用户不需要输密码</p><p><strong>exit</strong> 回退到初始用户</p><p><strong>whoami</strong> 查看当前是那个用户</p><h4 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h4><p>类似于角色，系统能够可以对用共性的多个用户进行统一的管理</p><p><strong>groupadd</strong> 组名 添加用户组</p><p><strong>clean</strong> 清屏</p><p><strong>groupdel</strong> 组名 删除用户组</p><p><strong>useradd -g 用户组 用户名</strong> 添加有归属的用户</p><p><strong>usermod -g 用户组 用户名</strong> 修改用户所属用户组</p><p><strong>&#x2F;etc&#x2F;passwd</strong> 用户配置信息</p><p>用户名：口令x(指代密码):用户id:组id::家目录：shell</p><p><strong>&#x2F;etc&#x2F;grroup</strong> 组配置信息</p><p>组名：口令x:组id:组内用户列表</p><p><strong>&#x2F;etc&#x2F;shadow</strong>(阴影) 口令配置信息（密码和登录信息，加密）</p><p>注意： <strong>路径问题</strong></p><p>如果你运行的是 <code>vim etc/passwd</code>，而不是 <code>vim /etc/passwd</code>，系统会尝试在当前工作目录下寻找 <code>etc/passwd</code> 文件，而不是全局的 <code>/etc/passwd</code> 文件。如果当前目录中没有该文件，Vim 会新建一个空文件。</p><p><strong>解决办法</strong>：明确指定路径，运行 <code>vim /etc/passwd</code>。</p><h3 id="实用指令"><a href="#实用指令" class="headerlink" title="实用指令"></a>实用指令</h3><h4 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a><strong>运行级别</strong></h4><p>0：关机  1：单用户  2：多用户无网络  <strong>3：多用户有网络</strong>  4：系统保留  5：图形界面  6：重启</p><p><strong>系统的运行级别配置文件 &#x2F;etc&#x2F;inittab</strong>  tab(标签)</p><p><strong>init 运行级别</strong> 切换到指定运行级别</p><p><strong>cat 文件</strong> 查看文件</p><h4 id="SysVinit和Systemd"><a href="#SysVinit和Systemd" class="headerlink" title="SysVinit和Systemd"></a>SysVinit和Systemd</h4><h5 id="SysVinit"><a href="#SysVinit" class="headerlink" title="SysVinit"></a><strong>SysVinit</strong></h5><ul><li><strong>SysVinit</strong> 是一种传统的初始化系统，源自 Unix 的 <strong>System V</strong> 体系。</li><li>它负责管理系统的启动流程，包括启动服务、挂载文件系统、进入特定运行级别（Runlevel）等。</li><li>配置文件位于 <code>/etc/inittab</code>，通过运行级别（如 <code>0</code>、<code>1</code>、<code>2</code> 等）来定义系统的工作状态。</li><li>常见的服务脚本存放在 <code>/etc/init.d</code>。</li></ul><hr><h5 id="Systemd"><a href="#Systemd" class="headerlink" title="Systemd"></a><strong>Systemd</strong></h5><ul><li><strong>Systemd</strong> 是一种现代化的初始化系统，旨在克服 SysVinit 的局限性，为 Linux 系统提供更快、更可靠的启动和服务管理。</li><li>它使用并行化技术，加快了启动速度，同时引入了服务依赖管理和监控功能。</li><li>配置文件分布在 <code>/etc/systemd/</code> 和 <code>/lib/systemd/system</code> 下，以 <code>.service</code> 文件为主。</li><li>Systemd 不仅是初始化系统，还提供了许多附加功能，例如日志管理（<code>journald</code>）和设备管理（<code>udevd</code>）。</li></ul><hr><h5 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a><strong>主要区别</strong></h5><table><thead><tr><th>特性</th><th>SysVinit</th><th>Systemd</th></tr></thead><tbody><tr><td><strong>设计理念</strong></td><td>单线程、串行启动</td><td>并行化、多线程启动</td></tr><tr><td><strong>服务管理</strong></td><td>服务启动顺序需手动配置</td><td>自动管理服务依赖，按需启动</td></tr><tr><td><strong>启动速度</strong></td><td>启动速度较慢，不能并行化</td><td>启动速度快，支持并行化</td></tr><tr><td><strong>配置文件</strong></td><td><code>/etc/inittab</code> 和 <code>/etc/init.d</code></td><td><code>/etc/systemd/</code> 和 <code>.service</code> 文件</td></tr><tr><td><strong>运行级别</strong></td><td>使用运行级别（Runlevel）</td><td>使用目标（Target），更灵活</td></tr><tr><td><strong>监控和恢复</strong></td><td>缺乏内建服务监控功能</td><td>内建服务监控和自动恢复</td></tr><tr><td><strong>日志管理</strong></td><td>使用传统日志（如 <code>/var/log</code>）</td><td>集中式日志管理，通过 <code>journald</code></td></tr><tr><td><strong>依赖管理</strong></td><td>手动配置服务依赖</td><td>自动检测和管理服务依赖</td></tr><tr><td><strong>扩展功能</strong></td><td>无扩展功能</td><td>提供诸多功能，如 <code>timedatectl</code> 和 <code>networkd</code></td></tr><tr><td><strong>启动顺序</strong></td><td>严格按照脚本文件顺序启动</td><td>根据依赖动态调整启动顺序</td></tr><tr><td><strong>兼容性</strong></td><td>兼容旧版 UNIX 系统</td><td>主流 Linux 发行版的默认选项</td></tr></tbody></table><p><strong>如何找回丢失的root密码</strong></p><p>因为进入单用户模式，root不需要密码，进入到单用户模式，然后修改root密码</p><p>开机，在引导是输入回车，看到界面输入e,  新界面选中第二行输入e, 输入1，回车，输入b,进入单用户模式，修改passwd</p><h4 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h4><p>当我们对某个指令不熟悉时</p><p>man [命令&#x2F;配置文件]  entry(登记) format(格式)</p><p>help 命令 用法</p><h4 id="文件目录类"><a href="#文件目录类" class="headerlink" title="文件目录类"></a>文件目录类</h4><p><strong>目录结尾加&#x2F; 文件不叫 绝对路径开头加&#x2F; 相对路径开头不加&#x2F;</strong></p><p><strong>pwd</strong> 显示当前目录的绝对路径</p><p><strong>ls</strong> [目录或是文件] <strong>-a</strong> 包括隐藏的 <strong>-l</strong> 详细信息，以列表形式显示 -al ll是ls -l的别名</p><p><strong>cd</strong> 切换目录  <code>..</code> 的含义：当前路径的父目录，即去掉最后一层路径。</p><p>cd ~或者 cd 回到自己的家目录 cd ..回到当前目录的上一级 </p><p><strong>mkdir</strong> 创建目录 -p 创建多级目录 绝对路径或者相对路径</p><p><strong>rmdir</strong> 删除空目录 如果有内容是无法删除的  强制删除 rm -rf</p><p><strong>touch</strong> 创建新文件 在当前目录下 可以一次性创键多个文件</p><p><strong>CP</strong>  拷贝某文件到某目录下  cp aaa.txt bbb&#x2F;  -r(递归拷贝) 可以拷贝整个目录到另一个目录  \cp -r aaa&#x2F; bbb&#x2F; 强制覆盖，如果bbb&#x2F;目录下已经有aaa&#x2F;目录下的某个文件，\cp可以强制覆盖，不会提示</p><p><strong>rm</strong>  删除文件或目录  -rf(删除整个目录) -f(取消提示)</p><p><strong>mv</strong> 移动文件或者重命名 </p><p>mv 原名 新名（就在当前目录）重命名 mv aaa.txt bbb.txt</p><p>mv pig.txt &#x2F;root&#x2F; 移动文件</p><p><strong>cat</strong>  查看文件内容 以只读的方式打开 -n显示行号  加上管道命令 |more 进行分页显示</p><p>cat -n &#x2F;etc&#x2F;file | more</p><p><strong>more</strong> 以全屏的方式一次性显示文件  空格 下一页  enter 下一行 ctrl F下一页 ctrl B上一页</p><p><strong>less</strong> 一页一页全屏显示，大型文件查看</p><p><strong>&gt;指令和&gt;&gt;指令</strong>  &gt;输出重定向，会覆盖原文件内容  &gt;&gt;追加到该文件末尾 </p><p><strong>echo</strong> 输出内容到控制台</p><p><strong>head</strong> 显示文件开头内容（10行）  -n 5 指定行数</p><p><strong>tail</strong>  显示文件末尾内容（10行）  -n 5 指定行数  <strong>tail -f 实时追踪文件的更新</strong></p><p><strong>ln -s</strong> 类似于windows里面的快捷方式  </p><p>ln -s &#x2F;root linkToRoot rm -rf linkToRoot</p><p><strong>histoty</strong> 查看已经执行过的历史命令，也可以执行历史指令 history histoty 10</p><p><strong>!178</strong> 执行178这个指令</p><h4 id="时间日期类"><a href="#时间日期类" class="headerlink" title="时间日期类"></a>时间日期类</h4><p><strong>date</strong> 显示当前日期 date  date+%Y 年 date+%m  %d </p><p><strong>date “+Y</strong>年**%m<strong>月</strong>%d<strong>日</strong>%H<strong>时</strong>%M<strong>分</strong>%S<strong>秒</strong>“**</p><p><strong>date -s 设置时间</strong> date -s “2018-10-10 11-22-22”</p><p><strong>cal 显示日历</strong> cal 2024 显示某一年日历</p><h4 id="搜索查找类"><a href="#搜索查找类" class="headerlink" title="搜索查找类"></a>搜索查找类</h4><p><strong>find [搜索范围] [选项]</strong> </p><p>-name 查询方式为名字 -user 文件拥有者 -size +20M  -20M 20M  *.txt</p><p><strong>locate</strong>  快速定位文件路径</p><p>需要先使用updatedb 创建locate数据库  然后locate hello.txt</p><p><strong>| 管道命令</strong>，表示将前一个命令的处理结果传递给后面的命令处理</p><p><strong>grep [选项] 查找内容 源文件</strong>  <strong>-n显示匹配行号，-i忽略字母大小写</strong></p><p><strong>cat hello.txt | grep yes</strong> </p><h4 id="压缩和解压缩类"><a href="#压缩和解压缩类" class="headerlink" title="压缩和解压缩类"></a>压缩和解压缩类</h4><p><strong>gzip&#x2F;gunzip</strong>  压缩和解压缩文件</p><p>使用gzip对文件进行压缩后，不会保留原文件  </p><p><strong>zip&#x2F;unzip</strong> -r(压缩目录)  -d(指定压缩目录)</p><p>zip -r mypackage.zip &#x2F;home&#x2F; 将home目录压缩成mypackage.zip放到当前目录</p><p>zip -d &#x2F;opt&#x2F;tmp&#x2F; maypackage.zip 将maypackage.zip解压到&#x2F;opt&#x2F;tmp&#x2F;目录下</p><p><strong>tar</strong> </p><p>-c产生.tar打包文件 -v显示详细信息 -f指定压缩后的文件名 -z打包的同时压缩 -x解包.tar文件</p><p>tar -zcvf a.tar.gz a1.txt a2.txt  将a1.txt a2.txt打包并压缩成a.tar.gz</p><p>tar -zcvf myhome.tar.gz &#x2F;home&#x2F; 将&#x2F;home&#x2F;打包压缩成myhome.tar.gz</p><p>tar -zxvf a.tar.gz 解压a.tar.gz</p><p>tar -zxvf myhome.tar.gz -C &#x2F;opt&#x2F; 解压myhome.tar.gz 到&#x2F;opt&#x2F;</p>]]></content>
    
    
    <categories>
      
      <category>学习日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024-12-11</title>
    <link href="/2024/12/11/2024-12-11/"/>
    <url>/2024/12/11/2024-12-11/</url>
    
    <content type="html"><![CDATA[<h3 id="2024-12-11"><a href="#2024-12-11" class="headerlink" title="2024-12-11"></a>2024-12-11</h3><h4 id="vi和vim基本介绍"><a href="#vi和vim基本介绍" class="headerlink" title="vi和vim基本介绍"></a>vi和vim基本介绍</h4><p>vim是vi的增强版本，具有程序编辑能力</p><h4 id="vi和vim的三种常见模式"><a href="#vi和vim的三种常见模式" class="headerlink" title="vi和vim的三种常见模式"></a>vi和vim的三种常见模式</h4><p><strong>1.正常模式</strong></p><p><strong>快捷键：</strong></p><p>默认模式，在正常模式下可以使用快捷键</p><p>Nyy: yy复制当前行，3yy当前3行</p><p>p: 粘贴</p><p>Ndd: 删除当前行</p><p>&#x2F;加单词：先用&#x2F;进入命令行模式，在输入单词即可查找</p><p>：set nu和：set nonu :加入行号，取消行号</p><p>G和gg: 末行和首行</p><p>u: 撤销动作</p><p>光标移动到20行： ：set nu 输入20 输入shift g</p><p><strong>按下i,l,o,O,a,A,r,R等任何一个字母都会进入编辑模式，一般按下i即可</strong></p><p><strong>按：或者&#x2F;进入命令行模式</strong></p><p><strong>2.插入模式</strong></p><p>进行编辑</p><p><strong>3.命令行模式</strong></p><p>：wq保存退出，：q！强制退出  无修改：q退出</p><p>完成读取，存盘，替换，离开，显示行号等动作</p><p><strong>按esc进入正常模式</strong></p><p>ll 显示当前目录文件</p><h4 id="关机和重启"><a href="#关机和重启" class="headerlink" title="关机和重启"></a>关机和重启</h4><p>shutdown</p><p>​shutdown -h now :立即关机</p><p>​shutdown -1 now :1分钟后关机</p><p>​shutdown -r now :立即重启</p><p>halt（停止） 关机</p><p>reboot  重启</p><p>sync（同步）  保存，将内存的数据同步到磁盘上</p><p>su  - 用户名 切换系统管理员</p><p>logout 注销用户 只针对远程登录</p>]]></content>
    
    
    <categories>
      
      <category>学习日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024-12-10</title>
    <link href="/2024/12/10/2024-12-10/"/>
    <url>/2024/12/10/2024-12-10/</url>
    
    <content type="html"><![CDATA[<h3 id="2024-12-10"><a href="#2024-12-10" class="headerlink" title="2024-12-10"></a>2024-12-10</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><img src="/images/1.jpg" alt="1"></p><p>linux内核：centos redhat ubuntu suse fedora(发行版)</p><p>操作系统：windows android  linux 车载系统 </p><p>linux和unix的关系：linux是基于unix的开源操作系统</p><p>远程操作系统操作机房–命令行操作</p><p><strong>windows和VM和centos关系:</strong></p><p>VM软件可以在windows上创建一个虚拟机空间，而centos则装在这个空间上</p><p>而这个这个centos可以移植，用其他的vm打开</p><p>deprecate 反对</p><h4 id="虚拟机网络连接模式"><a href="#虚拟机网络连接模式" class="headerlink" title="虚拟机网络连接模式"></a><em>虚拟机网络连接模式</em></h4><p>桥接模式：虚拟机ip地址与宿主机ip地址在同一个网段 </p><p>可能会出现ip地址冲突，只有253个地址 0是网络号，255是广播</p><p>NAT模式：网络地址转换方式：宿主机会重新创建一个虚拟ip地址，而linux系统能在这个虚拟ip网段创建新的地址，linux可以访问外网，不会造成ip冲突，但是外网不能找到虚拟机</p><p>主机模式：linux是一个独立的主机，不能访问外网</p><p><strong>VMnet0网口对应的是桥接模式</strong></p><p><strong>VMnet8网口对应的是NAT模式</strong></p><p><strong>VMnet1网口对应的是仅主机模式</strong></p><p>linux磁盘分区至少有三个 根分区 swap分区 boot分区</p><p>重启指令 reboot</p><p>共享文件夹默认放在centos 的 &#x2F;mnt&#x2F;hgfs 下</p><h4 id="linux目录结构"><a href="#linux目录结构" class="headerlink" title="linux目录结构"></a>linux目录结构</h4><p>树状目录结构 &#x2F;根目录</p><p><strong>在linux世界里，一切皆文件</strong> （所有东西都映射为文件）</p><p><strong>bin：</strong>binary  常用的命令</p><p><strong>sbin:</strong>  系统管理员使用的系统管理程序</p><p><strong>home：</strong>存放普通用户的主目录，在linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的</p><p><strong>root:</strong>   系统管理员 <strong>root&#x2F;desktop</strong> 桌面在这个之下</p><p>lib:   系统开机所需要的最基本的动态链接共享库，类似windows中的dll文件</p><p>DLL文件的作用是将程序中的一些功能模块化和共享化，避免重复开发和占用过多存储空间</p><p>lost+found: 系统非法关机，存放文件</p><p>dev:  管理设备，如cpu等等</p><p><strong>etc:</strong>    系统管理所需要的配置文件和子目录</p><p><strong>usr:</strong>    用户安装的很多应用程序和文件都存放在这个目录，类似于windows下的program fils目录</p><p><strong>boot:</strong>  启动linux的一些核心文件，包括一些连接文件和镜像文件</p><p>proc:  srv:  sys： 这三个最好别动</p><p>tmp:   临时文件</p><p><strong>media:</strong> U盘，光驱等，linux会将识别的设备挂载到这个目录下</p><p><strong>mnt:</strong>    为了让用户临时挂载别的文件系统的，可以将外部的存储挂载到这上面，进入该目录就可以查看里面的内容</p><p><strong>opt:</strong>   存放安装之前的软件</p><p><strong>usr&#x2F;local:</strong>  安装过后的软件</p><p><strong>var:</strong>    不断扩充的东西，变量，日志</p><p>selinux: 安全相关</p><p>远程登录<strong>xshell</strong> 远程上传文件<strong>xftp</strong></p><p>需要linux服务器开启sshd服务，22号端口</p><p><strong>ifconfig</strong> 查看ip</p>]]></content>
    
    
    <categories>
      
      <category>学习日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024-12-09</title>
    <link href="/2024/12/09/2024-12-09/"/>
    <url>/2024/12/09/2024-12-09/</url>
    
    <content type="html"><![CDATA[<h3 id="2024-12-09"><a href="#2024-12-09" class="headerlink" title="2024-12-09"></a>2024-12-09</h3><p>B&#x2F;S和C&#x2F;S</p><p><strong>B&#x2F;S 架构：</strong> 基于浏览器和服务器的架构，用户通过浏览器访问服务器上的应用程序。</p><p><strong>C&#x2F;S 架构：</strong> 基于客户端和服务器的架构，需要专门的客户端软件来与服务器进行交互。</p><p>Browser:浏览器</p><p>服务器程序通常需要处理三类事件：I&#x2F;O事件，信号及定时事件。有两种事件处理模式：</p><p><strong>Reactor模式：</strong>要求主线程（I&#x2F;O处理单元）只负责监听文件描述符上是否有事件发生（可读、可写），若有，则立即通知工作线程（逻辑单元），将socket可读可写事件放入请求队列，交给工作线程处理。这个过程是同步的，读取完数据后应用进程才能处理数据。<br><strong>Proactor模式：</strong>将所有的I&#x2F;O操作都交给主线程和内核来处理（进行读、写），工作线程仅负责处理逻辑，如主线程读完成后users[sockfd].read()，选择一个工作线程来处理客户请求pool-&gt;append(users + sockfd)。</p><p><strong>无论是 Reactor，还是 Proactor，都是一种基于「事件分发」的网络编程模式，区别在于 Reactor 模式是基于「待完成」的 I&#x2F;O 事件，而 Proactor 模式则是基于「已完成」的 I&#x2F;O 事件。</strong></p><p><strong>文件描述符 (File Descriptor)</strong> 是操作系统中用于标识打开文件的整数标识符，常见于类 Unix 系统。</p><p><strong><code>std::atomic</code>的作用：</strong></p><p><strong><code>std::atomic</code>：</strong></p><ul><li>提供对某些变量的<strong>原子操作支持</strong>，避免多线程操作时的数据竞争（Data Race）。</li><li>确保对变量的操作是线程安全的，操作不可分割。</li><li>典型操作包括：读取、写入、加减等，所有操作会在硬件级别（如CPU指令）上保持一致性。</li></ul><p><strong><code>std::size_t</code>：</strong></p><ul><li>是一种无符号整数类型，用于表示内存大小或数组索引。</li><li>平台相关：在32位系统上通常为32位整数，在64位系统上通常为64位整数。</li><li>例如，<code>sizeof</code> 运算符的结果类型就是 <code>std::size_t</code>。</li></ul><p><strong>为什么使用<code>std::size_t</code>？</strong></p><ul><li><code>std::size_t</code> 是一种平台无关的无符号整数类型，专门用于表示对象的大小或数组的索引。</li><li>使用 <code>std::atomic&lt;std::size_t&gt;</code> 可以在线程安全的情况下操作这些大小或索引变量。</li></ul><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p><strong>单例模式是最常用的设计模式之一，目的是保证一个类只有一个实例，并提供一个他的全局访问点，该实例被所有程序模块共享。此时需要把该类的构造和析构函数放入private中。</strong></p><p>单例模式有两种实现方法，一种是懒汉模式，另一种是饿汉模式。</p><p><strong>懒汉模式：</strong> 顾名思义，非常的懒，只有当调用getInstance的时候，才会去初始化这个单例。其中在C++11后，不需要加锁，直接使用函数内局部静态对象即可。<br><strong>饿汉模式：</strong> 即迫不及待，在程序运行时立即初始化。饿汉模式不需要加锁，就可以实现线程安全，原因在于，在程序运行时就定义了对象，并对其初始化。之后，不管哪个线程调用成员函数getinstance()，都只不过是返回一个对象的指针而已。所以是线程安全的，不需要在获取实例的成员函数中加锁。</p><h4 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h4><p><strong>什么是RAII？</strong></p><p>RAII是<strong>Resource Acquisition Is Initialization</strong>（wiki上面翻译成 “资源获取就是初始化”）的简称，是C++语言的一种管理资源、避免泄漏的惯用法。利用的就是C++构造的对象最终会被销毁的原则。RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。</p><p><strong>为什么要使用RAII？</strong></p><p>上面说到RAII是用来管理资源、避免资源泄漏的方法。那么，用了这么久了，也写了这么多程序了，口头上经常会说资源，那么资源是如何定义的？在计算机系统中，资源是数量有限且对系统正常运行具有一定作用的元素。比如：网络套接字、互斥锁、文件句柄和内存等等，它们属于系统资源。由于系统的资源是有限的，就好比自然界的石油，铁矿一样，不是取之不尽，用之不竭的，所以，我们在编程使用系统资源时，都必须遵循一个步骤：<br>1 申请资源；<br>2 使用资源；<br>3 释放资源。<br>第一步和第三步缺一不可，因为资源必须要申请才能使用的，使用完成以后，必须要释放，如果不释放的话，就会造成资源泄漏。</p><p>skip:跳过</p><p>cmd输入services.msc可以查看运行的服务</p><p>ipconfig&#x2F;ip a查看ip地址</p><p>hexo new post +文章名称</p><p>或者直接在post添加文件&#x2F;？</p><p>hexo clean</p><p>hexo generate</p><p>hexo deploy</p>]]></content>
    
    
    <categories>
      
      <category>学习日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
