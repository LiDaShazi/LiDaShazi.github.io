<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>雅思</title>
    <link href="/2025/03/15/%E9%9B%85%E6%80%9D/"/>
    <url>/2025/03/15/%E9%9B%85%E6%80%9D/</url>
    
    <content type="html"><![CDATA[<p><strong>一，personal interview(个人采访)</strong></p><p>4-5 minutes</p><p>2-3topics</p><p>3-4questions related to each topic</p><p><strong>二，individual speech(个人演讲)</strong></p><p>3-4minute</p><p>1-2min get ready</p><p>给一个书面题目</p><p><strong>三，Two-way discusstion(双边讨论)</strong></p><p>至少要有三句话，大概15-20s</p><h4 id="流利度和连贯性"><a href="#流利度和连贯性" class="headerlink" title="流利度和连贯性"></a>流利度和连贯性</h4><p>1.内容  2.犹豫，重复，自我纠正 3.连接词，语篇标记词</p><p>cup of tea 喜好</p><p>apple of one’e eye 掌上明珠</p><p>a piece of cake 小菜一碟</p><p>once in a blue moon 千载难逢</p><h4 id="词汇多样性"><a href="#词汇多样性" class="headerlink" title="词汇多样性"></a>词汇多样性</h4><p>1.词汇丰富 2.同义替换（用其他单词来代替自己不会的单词） 3.高级词汇，俚语（成语）注意语境</p><p>terrific</p><p>极好的</p><h4 id="语法错误和准确性"><a href="#语法错误和准确性" class="headerlink" title="语法错误和准确性"></a>语法错误和准确性</h4><p>1.复杂类型 2.语法错误</p><h4 id="发音"><a href="#发音" class="headerlink" title="发音"></a>发音</h4><p>1母语&#x2F;使用者多发音特征 2.避免常见错误，产生歧义</p><p>assessment 评估</p><h4 id="提问形式"><a href="#提问形式" class="headerlink" title="提问形式"></a>提问形式</h4><p>特殊疑问句，一般疑问句</p><p>direct answer</p><p>supporting details</p><p>conclusion(optional)</p><p>不要重复提问的句子，直接回应问题</p><p>注意提问的时态，回答的首句一定与问题时态一致</p><p>Yes,absolutedly&#x2F;definitely&#x2F;sure…I really</p><p>Not really…&#x2F;Not at all…in fact&#x2F;to be honest,I dont’t</p><p>well,it depends&#x2F;it’s a bit hard to say …if…and if</p><p>特殊疑问句</p><p>直接回答</p><p>there are plenty of things I enjoy</p><p>How often</p><p>usually often sometims seldom nerver</p><p>once&#x2F;twice</p><h4 id="如何拓展"><a href="#如何拓展" class="headerlink" title="如何拓展"></a>如何拓展</h4><p>reasons feelings examples comparisons facts influence</p><h4 id="如何连接"><a href="#如何连接" class="headerlink" title="如何连接"></a>如何连接</h4><p><img src="/%5Cimages%5C2025-3-15-1.jpg" alt="2025-3-15-1"></p><p>explain  exp(b) clarify(re)</p><p>on account of(接名词)  n a 连读（ne）</p><p><img src="/%5Cimages%5C2025-3-15-2.jpg" alt="2025-3-15-2"></p><p>competitive &#x2F;te&#x2F;</p><p>bachelor 学士</p>]]></content>
    
    
    <categories>
      
      <category>English</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++重新学习</title>
    <link href="/2025/02/28/C++%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/02/28/C++%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>C++ 是一门多范式的通用编程语言</strong></p><p>多范式，是因为 C++ 支持面向过程编程，也支持面向对象编程，也支持泛型编程，新版本还可以说是支持了函数式编程。</p><h4 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h4><h5 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h5><p>在内存管理的语境下，指的是动态分配内存的区域。这个堆跟数据结构里的堆不是一回事。这里的内存，被分配之后需要手工释放，否则，就会造成内存泄漏。</p><p>C++ 标准里一个相关概念是自由存储区，英文是 free store，特指使用 new 和 delete 来分配和释放内存的区域。</p><p>一般而言，这是堆的一个子集：new 和 delete 操作的区域是 free store malloc 和 free 操作的区域是 heap但 new 和 delete 通常底层使用 malloc 和 free 来实现，所以 free store 也是 heap。</p><h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h5><p>在内存管理的语境下，指的是函数调用过程中产生的本地变量和调用数据的区域。这个栈和数据结构里的栈高度相似，都满足“后进先出”（last-in-first-out 或 LIFO）。</p><h5 id="RAII-1"><a href="#RAII-1" class="headerlink" title="RAII"></a>RAII</h5><p>是 C++ 所特有的资源管理方式。</p><p>RAII 依托栈和析构函数，来对所有的资源——包括堆内存在内——进行管理。对 RAII 的使用，使得 C++ 不需要类似于 Java 那样的垃圾收集方法，也能有效地对内存进行管理。RAII 的存在，也是垃圾收集虽然理论上可以在 C++ 使用，但从来没有真正流行过的主要原因。</p><h5 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> ptr = <span class="hljs-keyword">new</span> std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;();<br></code></pre></td></tr></table></figure><p>程序通常需要牵涉到三个可能的内存管理器的操作：</p><p>1.让内存管理器分配一个某个大小的内存块</p><p>2.让内存管理器释放一个之前分配的内存块</p><p>3.让内存管理器进行垃圾收集操作，寻找不再使用的内存块并予以释放</p><p>C++ 通常会做上面的操作 1 和 2。Java 会做上面的操作 1 和 3。而 Python 会做上面的操作 1、2、3。这是语言的特性和实现方式决定的。</p><p><strong>如果要申请堆的空间的话最好是分配和释放不在同一个函数里面</strong></p><h5 id="栈展开"><a href="#栈展开" class="headerlink" title="栈展开"></a>栈展开</h5><p>在 C++ 中，当一个异常被抛出时，程序需要寻找合适的 <code>catch</code> 语句来处理异常。如果异常在当前函数中没有被捕获，<strong>程序会逐层退出函数，直到找到合适的 <code>catch</code> 块，或者终止程序</strong>。</p><p>在这个过程中，<strong>所有局部对象的析构函数都会被调用</strong>，以确保资源不会泄漏——这就是<strong>栈展开</strong>（Stack Unwinding）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Obj</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Obj</span>() &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Obj()&quot;</span>); &#125;<br>  ~<span class="hljs-built_in">Obj</span>() &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;~Obj()&quot;</span>); &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  Obj obj;<br>  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">42</span>)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;life, the universe and everything&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-built_in">foo</span>(<span class="hljs-number">41</span>);<br>    <span class="hljs-built_in">foo</span>(<span class="hljs-number">42</span>);<br>  &#125;<br>  <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s) &#123;<br>    <span class="hljs-built_in">puts</span>(s);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>异常会向上传播到直到遇见 <code>catch</code> 语句。</p><p>在 C++ 里，<strong>大部分变量默认是“值语义”（Value Semantics）</strong></p><ul><li>变量<strong>直接存储数据</strong>，而不是存储指向堆的引用。</li><li>赋值、拷贝等操作<strong>默认是值拷贝</strong>（拷贝整个对象）。</li></ul><p>C++ 支持将对象存储在栈上面。但是，在很多情况下，对象不能，或不应该，存储在栈上。</p><p>1.对象很大；</p><p>2.对象的大小在编译时不能确定；</p><p>3.对象是函数的返回值，但由于特殊的原因，不应使用对象的值返回。</p><p>常见情况之一是，在工厂方法或其他面向对象编程的情况下，返回值类型是基类（的指针或引用）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">shape_type</span> &#123;<br>  circle,<br>  triangle,<br>  rectangle,<br>  …<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">shape</span> &#123; … &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">circle</span> : <span class="hljs-keyword">public</span> shape &#123; … &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">triangle</span> : <span class="hljs-keyword">public</span> shape &#123; … &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">rectangle</span> : <span class="hljs-keyword">public</span> shape &#123; … &#125;;<br><br><span class="hljs-function">shape* <span class="hljs-title">create_shape</span><span class="hljs-params">(shape_type type)</span></span><br><span class="hljs-function"></span>&#123;<br>  …<br>  <span class="hljs-keyword">switch</span> (type) &#123;<br>  <span class="hljs-keyword">case</span> shape_type::circle:<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">circle</span>(…);<br>  <span class="hljs-keyword">case</span> shape_type::triangle:<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">triangle</span>(…);<br>  <span class="hljs-keyword">case</span> shape_type::rectangle:<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">rectangle</span>(…);<br>  …<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>工厂模式（Factory Pattern）</strong>：该函数隐藏了具体子类的创建逻辑，使得调用者可以简单地调用 <code>create_shape(shape_type::circle)</code> 来获得 <code>circle</code> 对象，而不需要关心 <code>circle</code> 类的构造细节。</p><p>那么，我们怎样才能确保，在使用 create_shape 的返回值时不会发生内存泄漏呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">shape_wrapper</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">shape_wrapper</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    shape* ptr = <span class="hljs-literal">nullptr</span>)</span></span><br><span class="hljs-function">    : ptr_(ptr) &#123;</span>&#125;<br>  ~<span class="hljs-built_in">shape_wrapper</span>()<br>  &#123;<br>    <span class="hljs-keyword">delete</span> ptr_;<br>  &#125;<br>  <span class="hljs-function">shape* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> ptr_; &#125;<br><span class="hljs-keyword">private</span>:<br>  shape* ptr_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  …<br>  <span class="hljs-function">shape_wrapper <span class="hljs-title">ptr_wrapper</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    create_shape(…))</span></span>;<br>  …<br>&#125;<br></code></pre></td></tr></table></figure><p>explicit防止构造函数的隐式转换</p><p><strong>单参数构造函数</strong> 通常 **加 <code>explicit</code>**，防止隐式转换导致的 bug。</p><p><strong>转换运算符</strong> 需要时加 <code>explicit</code>，防止意外转换。</p><p>把指向堆内存的指针包裹到一个局部对象中，该对象的析构函数在析构时会 delete 自己的指针变量，这样可以通过栈展开保证new出来的内存被释放，不会遗漏。</p><p>new 的时候先分配内存（失败时整个操作失败并向外抛出异常，通常是 bad_alloc），然后在这个结果指针上构造对象；构造成功则 new 操作整体完成，否则释放刚分配的内存并继续向外抛构造函数产生的异常。delete 时则判断指针是否为空，在指针不为空时调用析构函数并释放之前分配的内存。</p><p><strong>在析构函数里做必要的清理工作，这就是 RAII 的基本用法。</strong></p><p>RAII的基本用法： 将清理工作（删除指针，释放资源等等…）放在析构函数中，而不是手动的在代码中显式调用； 这样伴随着栈变量无论如何在退出的时候都会调用析构函数的特性，将清理这一操作成为必然，而不会因为人工遗漏导致内存泄漏； 一句话总结就是将清理逻辑通过析构函数告诉编译器，由编译器来帮助程序员完成清理工作。</p><p><strong>虽然C++在做内存管理时，会在栈上分配和释放内存块，但这些动态分配的对象仍然需要用栈中的局部变量包裹（管理）起来，这样才是最“自然”的——可以利用基于栈和析构函数的RAII。</strong></p><h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">shape_wrapper</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">shape_wrapper</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    shape* ptr = <span class="hljs-literal">nullptr</span>)</span></span><br><span class="hljs-function">    : ptr_(ptr) &#123;</span>&#125;<br>  ~<span class="hljs-built_in">shape_wrapper</span>()<br>  &#123;<br>    <span class="hljs-keyword">delete</span> ptr_;<br>  &#125;<br>  <span class="hljs-function">shape* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> ptr_; &#125;<br><br><span class="hljs-keyword">private</span>:<br>  shape* ptr_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个类可以对超出作用域的对象进行释放。</p><p>但相比与智能指针它缺了点东西：这个类只适用于 shape 类该类对象的行为不够像指针拷贝该类对象会引发程序行为异常</p><h5 id="模板化和易用性"><a href="#模板化和易用性" class="headerlink" title="模板化和易用性"></a>模板化和易用性</h5><p>要让这个类能够包装任意类型的指针，我们需要把它变成一个类模板。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">smart_ptr</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">smart_ptr</span><span class="hljs-params">(T* ptr = <span class="hljs-literal">nullptr</span>)</span></span><br><span class="hljs-function">    : ptr_(ptr) &#123;</span>&#125;<br>  ~<span class="hljs-built_in">smart_ptr</span>()<br>  &#123;<br>    <span class="hljs-keyword">delete</span> ptr_;<br>  &#125;<br>  <span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> ptr_; &#125;<br><span class="hljs-keyword">private</span>:<br>  T* ptr_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>目前这个 smart_ptr 的行为还是和指针有点差异的：</p><p>它不能用 * 运算符解引用</p><p>它不能用 -&gt; 运算符指向对象成员</p><p>它不能像指针一样用在布尔表达式里</p><p>加几个成员函数就可以：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">smart_ptr</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  …<br>  T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> *ptr_; &#125;<br>  T* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> ptr_; &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> ptr_ != <span class="hljs-literal">nullptr</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="拷贝构造和赋值"><a href="#拷贝构造和赋值" class="headerlink" title="拷贝构造和赋值"></a>拷贝构造和赋值</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">smart_ptr&lt;shape&gt; ptr1&#123;<span class="hljs-built_in">create_shape</span>(shape_type::circle)&#125;;<br>smart_ptr&lt;shape&gt; ptr2&#123;ptr1&#125;;<br></code></pre></td></tr></table></figure><p>如果构造函数是 <code>explicit</code>，建议用 <code>&#123;&#125;</code> 以避免隐式转换。</p><p>在模板代码中，<code>&#123;&#125;</code> 更安全，可以防止“最具争议的解析”问题。</p><p>避免 <code>()</code> 误解析成函数声明，特别是在变量声明时。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">smart_ptr</span> &#123;<br>  …<br>  <span class="hljs-built_in">smart_ptr</span>(<span class="hljs-type">const</span> smart_ptr&amp;)<br>    = <span class="hljs-keyword">delete</span>;<br>  smart_ptr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> smart_ptr&amp;)<br>    = <span class="hljs-keyword">delete</span>;<br>  …<br>&#125;;<br></code></pre></td></tr></table></figure><p>禁用这两个函数非常简单，但却解决了一种可能出错的情况。否则，smart_ptr ptr2{ptr1}; 在编译时不会出错，但在运行时却会有未定义行为——由于会对同一内存释放两次，通常情况下会导致程序崩溃。</p><p>如果没有编写深拷贝函数，将会出现一份内存，被析构两次的问题 默认的拷贝函数一般是浅拷贝。 考虑问题要从一般性入手，不能假定编程人员都会为一个需要深拷贝的对象提供深拷贝构造函数。</p><p>我们是不是可以考虑在拷贝智能指针时把对象拷贝一份？不行，通常人们不会这么用，因为使用智能指针的目的就是要减少对象的拷贝啊。何况，虽然我们的指针类型是 shape，但实际指向的却应该是 circle 或 triangle 之类的对象。因为 <code>smart_ptr&lt;shape&gt;</code> 只知道它存储的是 <code>shape*</code>，但它<strong>不知道</strong>这个 <code>shape*</code> 具体指向的是 <code>circle</code>、<code>triangle</code> 还是 <code>rectangle</code>。</p><p>我们要么试试在拷贝时转移指针的所有权？大致实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">smart_ptr</span> &#123;<br>  …<br>  <span class="hljs-built_in">smart_ptr</span>(smart_ptr&amp; other)<br>  &#123;<br>    ptr_ = other.<span class="hljs-built_in">release</span>();<br>  &#125;<br>  smart_ptr&amp; <span class="hljs-keyword">operator</span>=(smart_ptr&amp; rhs)<br>  &#123;<br>    <span class="hljs-built_in">smart_ptr</span>(rhs).<span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>  &#125;<br>  …<br>  <span class="hljs-function">T* <span class="hljs-title">release</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    T* ptr = ptr_;<br>    ptr_ = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">return</span> ptr;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(smart_ptr&amp; rhs)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">using</span> std::swap;<br>    <span class="hljs-built_in">swap</span>(ptr_, rhs.ptr_);<br>  &#125;<br>  …<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>release()</strong></p><p>返回当前持有的指针 <code>ptr_</code>（让调用者接管它）。</p><p>将 <code>ptr_</code> 置为 <code>nullptr</code>（避免 <code>smart_ptr</code> 再次 <code>delete</code> 这个指针）。</p><p>为什么不用这个？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">smart_ptr&amp; <span class="hljs-keyword">operator</span>=(smart_ptr&amp; rhs) &#123;    <br>    ptr_ = rhs.<span class="hljs-built_in">release</span>();    <br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">smart_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">42</span>))</span></span>;  <span class="hljs-comment">// p1 持有 42</span><br><span class="hljs-function">smart_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">99</span>))</span></span>;  <span class="hljs-comment">// p2 持有 99</span><br><br>p2 = p1; <span class="hljs-comment">// 这里会发生什么？</span><br></code></pre></td></tr></table></figure><p>rhs.release()（即 <code>p1.release()</code>）：</p><p>1.<code>p1.ptr_</code> 是 <code>42</code>，返回 <code>42</code> 并置 <code>p1.ptr_ = nullptr</code>，表示 <code>p1</code> 不再持有 <code>42</code>。</p><p>2.<code>ptr_ = rhs.release();</code>（即 <code>p2.ptr_ = p1.release();</code>）：</p><ul><li><code>p2.ptr_</code> 现在指向 <code>42</code>，但 <code>p2</code> 原本指向的 <code>99</code> 仍然存在，没人 <code>delete</code> 它！</li><li>内存泄漏了！</li></ul><p><code>p2.ptr_</code> <strong>在被覆盖之前，原来的 <code>99</code> 没有被释放</strong>。</p><p><code>release()</code> 只是<strong>转移所有权</strong>，并不释放内存，所以 <code>99</code> 仍然存在。</p><p>总结：因为初始化的时候p2指针没有值，可以直接转移，但是&#x3D;操作p2指针是能有值的</p><p>于是：</p><ul><li><code>smart_ptr(rhs)</code> <strong>创建临时对象</strong>，接管 <code>rhs</code> 的指针，<code>rhs.ptr_ = nullptr</code>。</li><li><code>swap(*this)</code> <strong>交换指针</strong>，<code>this</code> 指的是当前对象，于是this持有 <code>rhs</code> 的资源，临时对象持有 <code>this</code> 原来的资源。</li><li>临时对象<strong>析构时自动释放</strong>原来的 <code>ptr_</code>，<strong>不会内存泄漏</strong>！</li></ul><p>上面代码里的这种惯用法保证了强异常安全性：赋值分为拷贝构造和交换两步，异常只可能在第一步发生；而第一步如果发生异常的话，this 对象完全不受任何影响。无论拷贝构造成功与否，结果只有赋值成功和赋值没有效果两种状态，而不会发生因为赋值破坏了当前对象这种场景。</p><p>上面实现的最大问题是，它的行为会让程序员非常容易犯错。一不小心把它传递给另外一个 smart_ptr，你就不再拥有这个对象了……</p><h5 id="“移动”指针？"><a href="#“移动”指针？" class="headerlink" title="“移动”指针？"></a>“移动”指针？</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">smart_ptr</span> &#123;<br>  …<br>  <span class="hljs-built_in">smart_ptr</span>(smart_ptr&amp;&amp; other)<br>  &#123;<br>    ptr_ = other.<span class="hljs-built_in">release</span>();<br>  &#125;<br>  smart_ptr&amp; <span class="hljs-keyword">operator</span>=(smart_ptr rhs)<br>  &#123;<br>    rhs.<span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>  &#125;<br>  …<br>&#125;;<br></code></pre></td></tr></table></figure><p>1.把拷贝构造函数中的参数类型 smart_ptr&amp; 改成了 smart_ptr&amp;&amp;；现在它成了移动构造函数。</p><p>2.把赋值函数中的参数类型 smart_ptr&amp; 改成了 smart_ptr，在构造参数时直接生成新的智能指针，从而不再需要在函数体中构造临时对象。现在赋值函数的行为是移动还是拷贝，完全依赖于构造参数时走的是移动构造还是拷贝构造。</p><p>3.注意注意：smart_ptr rhs这里相当于一个构造了一个临时对象，同时删除了原先指针的所有权（调用了release）</p><p>如果我提供了移动构造函数而没有手动提供拷贝构造函数，那后者自动被禁用（不推荐在代码里默认使用这些规则，它使得代码的可读性降低。 根据C++ core guideline C.21，如果定义这些构造函数中的一个，请显示地delete或者default其他的。）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">smart_ptr&lt;shape&gt; ptr1&#123;<span class="hljs-built_in">create_shape</span>(shape_type::circle)&#125;;<br>smart_ptr&lt;shape&gt; ptr2&#123;ptr1&#125;;             <span class="hljs-comment">// 编译出错</span><br>smart_ptr&lt;shape&gt; ptr3;<br>ptr3 = ptr1;                             <span class="hljs-comment">// 编译出错</span><br>ptr3 = std::<span class="hljs-built_in">move</span>(ptr1);                  <span class="hljs-comment">// OK，可以</span><br>smart_ptr&lt;shape&gt; ptr4&#123;std::<span class="hljs-built_in">move</span>(ptr3)&#125;;  <span class="hljs-comment">// OK，可以</span><br></code></pre></td></tr></table></figure><h5 id="子类指针向基类指针的转换"><a href="#子类指针向基类指针的转换" class="headerlink" title="子类指针向基类指针的转换"></a>子类指针向基类指针的转换</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-built_in">smart_ptr</span>(smart_ptr&lt;U&gt;&amp;&amp; other)<br>&#123;<br>  ptr_ = other.<span class="hljs-built_in">release</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>子类和父类不同模版，模板构造函数的作用是允许 <code>smart_ptr&lt;U&gt;</code> 作为 <code>smart_ptr&lt;T&gt;</code> 的参数</p><p>上面这个构造函数不被编译器看作移动构造函数，因而不能自动触发删除拷贝构造函数的行为</p><h5 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h5><p>unique_ptr一个对象只能被一个只能指针拥有，多个智能指针同时拥有一个对象是shared_ptr.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">shared_count</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">shared_count</span>();<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_count</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">reduce_count</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">get_count</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个 shared_count 类除构造函数之外有三个方法：一个增加计数，一个减少计数，一个获取计数。注意上面的接口增加计数不需要返回计数值；但减少计数时需要返回计数值，以供调用者判断是否它已经是最后一个指向共享计数的 shared_ptr 了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">smart_ptr</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">smart_ptr</span><span class="hljs-params">(T* ptr = <span class="hljs-literal">nullptr</span>)</span></span><br><span class="hljs-function">    : ptr_(ptr)</span><br><span class="hljs-function">  &#123;</span><br>    <span class="hljs-keyword">if</span> (ptr) &#123;<br>      shared_count_ =<br>        <span class="hljs-keyword">new</span> <span class="hljs-built_in">shared_count</span>();<br>    &#125;<br>  &#125;<br>  ~<span class="hljs-built_in">smart_ptr</span>()<br>  &#123;<br>    <span class="hljs-keyword">if</span> (ptr_ &amp;&amp;<br>      !shared_count_<br>         -&gt;<span class="hljs-built_in">reduce_count</span>()) &#123;<br>      <span class="hljs-keyword">delete</span> ptr_;<br>      <span class="hljs-keyword">delete</span> shared_count_;<br>    &#125;<br>  &#125;<br><br><span class="hljs-keyword">private</span>:<br>  T* ptr_;<br>  shared_count* shared_count_;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">smart_ptr</span>(<span class="hljs-type">const</span> smart_ptr&amp; other)<br>  &#123;<br>    ptr_ = other.ptr_;<br>    <span class="hljs-keyword">if</span> (ptr_) &#123;<br>      other.shared_count_<br>        -&gt;<span class="hljs-built_in">add_count</span>();<br>      shared_count_ =<br>        other.shared_count_;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>  <span class="hljs-built_in">smart_ptr</span>(<span class="hljs-type">const</span> smart_ptr&lt;U&gt;&amp; other)<br>  &#123;<br>    ptr_ = other.ptr_;<br>    <span class="hljs-keyword">if</span> (ptr_) &#123;<br>      other.shared_count_<br>        -&gt;<span class="hljs-built_in">add_count</span>();<br>      shared_count_ =<br>        other.shared_count_;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>  <span class="hljs-built_in">smart_ptr</span>(smart_ptr&lt;U&gt;&amp;&amp; other)<br>  &#123;<br>    ptr_ = other.ptr_;<br>    <span class="hljs-keyword">if</span> (ptr_) &#123;<br>      shared_count_ =<br>        other.shared_count_;<br>      other.ptr_ = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>  &#125;<span class="hljs-comment">//这里没有release函数，代表不删除原先指针的所有权</span><br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(smart_ptr&amp; rhs)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">using</span> std::swap;<br>    <span class="hljs-built_in">swap</span>(ptr_, rhs.ptr_);<br>    <span class="hljs-built_in">swap</span>(shared_count_,<br>         rhs.shared_count_);<br>  &#125;<br>  smart_ptr&amp; <span class="hljs-keyword">operator</span>=(smart_ptr rhs) &#123; <br>  rhs.<span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>); <br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <br>  &#125;<br></code></pre></td></tr></table></figure><p>此外，我们之前的实现（类似于单一所有权的 unique_ptr ）中用 release 来手工释放所有权。在目前的引用计数实现中，它就不太合适了，应当删除。但我们要加一个对调试非常有用的函数，返回引用计数值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">use_count</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (ptr_) &#123;<br>    <span class="hljs-keyword">return</span> shared_count_<br>      -&gt;<span class="hljs-built_in">get_count</span>();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>模板的各个实例间并不天然就有 friend 关系，因而不能互访私有成员 ptr_ 和 shared_count_。我们需要在 smart_ptr 的定义中显式声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">smart_ptr</span>;<br></code></pre></td></tr></table></figure><p><code>noexcept</code> 是 C++11 引入的关键字，<strong>用于声明某个函数不会抛出异常</strong>，在标准库（如 <code>std::vector</code>）中，如果对象的<strong>移动构造函数是 <code>noexcept</code> 的</strong>，那么 <code>std::vector</code> 会优先使用<strong>移动操作</strong>而不是<strong>拷贝操作</strong>，从而提高效率。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>力扣刷题</title>
    <link href="/2025/02/26/%E5%8A%9B%E6%89%A3/"/>
    <url>/2025/02/26/%E5%8A%9B%E6%89%A3/</url>
    
    <content type="html"><![CDATA[<h4 id="2-26"><a href="#2-26" class="headerlink" title="2-26"></a>2-26</h4><h5 id="每日一题"><a href="#每日一题" class="headerlink" title="每日一题"></a>每日一题</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BrowserHistory</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> index;<br>    <span class="hljs-type">int</span> size;<br>    vector&lt;string&gt; sps;<br><br>    <span class="hljs-built_in">BrowserHistory</span>(string homepage): <span class="hljs-built_in">index</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">size</span>(<span class="hljs-number">1</span>) &#123;<br>        sps.<span class="hljs-built_in">push_back</span>(homepage);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(string url)</span> </span>&#123;<br>        sps.<span class="hljs-built_in">erase</span>(sps.<span class="hljs-built_in">begin</span>() + index + <span class="hljs-number">1</span>, sps.<span class="hljs-built_in">end</span>());<br>        sps.<span class="hljs-built_in">push_back</span>(url);<br>        index++;<br>        size = index + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">back</span><span class="hljs-params">(<span class="hljs-type">int</span> steps)</span> </span>&#123;<br>        index = (index - steps) &lt;= <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : index - steps;<br>        <span class="hljs-comment">//currIndex  = max(currIndex - steps, 0);</span><br>        <span class="hljs-keyword">return</span> sps[index];<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-type">int</span> steps)</span> </span>&#123;<br>        index = (index + steps) &gt;= size ? size - <span class="hljs-number">1</span> : index + steps;<br>        <span class="hljs-keyword">return</span> sps[index];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-27"><a href="#2-27" class="headerlink" title="2-27"></a>2-27</h4><p>左边一个栈，右边一个栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextEditor</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">char</span>&gt; left;<br>    vector&lt;<span class="hljs-type">char</span>&gt; right;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TextEditor</span>() &#123;<br>        <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addText</span><span class="hljs-params">(string text)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : text) &#123;<br>            left.<span class="hljs-built_in">push_back</span>(c);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">deleteText</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (; !left.<span class="hljs-built_in">empty</span>() &amp;&amp; k &gt; <span class="hljs-number">0</span>; k--) &#123;<br>            left.<span class="hljs-built_in">pop_back</span>();<br>            n++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>    <br>    <span class="hljs-function">string <span class="hljs-title">cursorLeft</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (!left.<span class="hljs-built_in">empty</span>() &amp;&amp; k &gt; <span class="hljs-number">0</span>) &#123;<br>            right.<span class="hljs-built_in">push_back</span>(left.<span class="hljs-built_in">back</span>());<br>            left.<span class="hljs-built_in">pop_back</span>();<br>            k--;<br>        &#125;<br>        <span class="hljs-type">int</span> n = left.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>(left.<span class="hljs-built_in">begin</span>() + <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, n - <span class="hljs-number">10</span>), left.<span class="hljs-built_in">end</span>());<br>    &#125;<br>    <br>    <span class="hljs-function">string <span class="hljs-title">cursorRight</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (!right.<span class="hljs-built_in">empty</span>() &amp;&amp; k &gt; <span class="hljs-number">0</span>) &#123;<br>            left.<span class="hljs-built_in">push_back</span>(right.<span class="hljs-built_in">back</span>());<br>            right.<span class="hljs-built_in">pop_back</span>();<br>            k--;<br>        &#125;<br>        <span class="hljs-type">int</span> n = left.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>(left.<span class="hljs-built_in">begin</span>() + <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, n - <span class="hljs-number">10</span>), left.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-27-1"><a href="#2-27-1" class="headerlink" title="2-27"></a>2-27</h4><p>可以用有序表，也可以用堆</p><p>但是堆的话涉及到堆的修改，可以自己实现堆</p><p>也可以采用懒删除的方法，将维护操作推迟到查询时才进行</p><p>对于 changeRating 操作，直接将记录添加到堆中，而不删除其过期的值；<br>对于 highestRated 操作，查看堆顶的食物评分与其实际值是否一致，如果不一致说明对应的元素值已经过期，直接弹出，否则堆顶就是答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FoodRatings</span> &#123;<br>    <span class="hljs-keyword">private</span> Map&lt;String, Pair&lt;Integer, String&gt;&gt; foodMap;<br>    <span class="hljs-keyword">private</span> Map&lt;String, PriorityQueue&lt;Pair&lt;Integer, String&gt;&gt;&gt; ratingMap;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FoodRatings</span><span class="hljs-params">(String[] foods, String[] cuisines, <span class="hljs-type">int</span>[] ratings)</span> </span>&#123;<br>        n = foods.length;<br>        foodMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        ratingMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            String food = foods[i];<br>            String cuisine = cuisines[i];<br>            <span class="hljs-type">int</span> rating = ratings[i];<br>            foodMap.<span class="hljs-built_in">put</span>(food, <span class="hljs-keyword">new</span> Pair&lt;&gt;(rating, cuisine));<br>            ratingMap.<span class="hljs-built_in">computeIfAbsent</span>(cuisine, k -&gt; <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; &#123;<br>                <span class="hljs-keyword">if</span> (!a.<span class="hljs-built_in">getKey</span>().<span class="hljs-built_in">equals</span>(b.<span class="hljs-built_in">getKey</span>())) &#123;<br>                    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">getKey</span>() - b.<span class="hljs-built_in">getKey</span>();<br>                &#125;<br>                <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">getValue</span>().<span class="hljs-built_in">compareTo</span>(b.<span class="hljs-built_in">getValue</span>());<br>            &#125;)).<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> Pair&lt;&gt;(n - rating, food));<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">changeRating</span><span class="hljs-params">(String food, <span class="hljs-type">int</span> newRating)</span> </span>&#123;<br>        Pair&lt;Integer, String&gt; pair = foodMap.<span class="hljs-built_in">get</span>(food);<br>        String cuisine = pair.<span class="hljs-built_in">getValue</span>();<br>        ratingMap.<span class="hljs-built_in">get</span>(cuisine).<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> Pair&lt;&gt;(n - newRating, food));<br>        foodMap.<span class="hljs-built_in">put</span>(food, <span class="hljs-keyword">new</span> Pair&lt;&gt;(newRating, cuisine));<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">highestRated</span><span class="hljs-params">(String cuisine)</span> </span>&#123;<br>        PriorityQueue&lt;Pair&lt;Integer, String&gt;&gt; q = ratingMap.<span class="hljs-built_in">get</span>(cuisine);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">isEmpty</span>()) &#123;<br>            Pair&lt;Integer, String&gt; top = q.<span class="hljs-built_in">peek</span>();<br>            String food = top.<span class="hljs-built_in">getValue</span>();<br>            <span class="hljs-keyword">if</span> (n - top.<span class="hljs-built_in">getKey</span>() == foodMap.<span class="hljs-built_in">get</span>(food).<span class="hljs-built_in">getKey</span>()) &#123;<br>                <span class="hljs-keyword">return</span> food;<br>            &#125;<br>            q.<span class="hljs-built_in">poll</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-1"><a href="#3-1" class="headerlink" title="3-1"></a>3-1</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; f;<br>    vector&lt;vector&lt;string&gt;&gt; ret;<br>    vector&lt;string&gt; ans;<br>    <span class="hljs-type">int</span> n;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (i == n) &#123;<br>            ret.<span class="hljs-built_in">push_back</span>(ans);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; n; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPalindrome</span>(s, i, j) == <span class="hljs-number">1</span>) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(s.<span class="hljs-built_in">substr</span>(i, j - i + <span class="hljs-number">1</span>));<br>                <span class="hljs-built_in">dfs</span>(s, j + <span class="hljs-number">1</span>);<br>                ans.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 记忆化搜索中，f[i][j] = 0 表示未搜索，1 表示是回文串，-1 表示不是回文串</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (f[i][j]) &#123;<br>            <span class="hljs-keyword">return</span> f[i][j];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &gt;= j) &#123;<br>            <span class="hljs-keyword">return</span> f[i][j] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[i][j] = (s[i] == s[j] ? <span class="hljs-built_in">isPalindrome</span>(s, i + <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>) : <span class="hljs-number">-1</span>);<br>    &#125;<br><br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        n = s.<span class="hljs-built_in">size</span>();<br>        f.<span class="hljs-built_in">assign</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br><br>        <span class="hljs-built_in">dfs</span>(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="3-2"><a href="#3-2" class="headerlink" title="3-2"></a>3-2</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(string &amp;s, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = L;<br>    <span class="hljs-type">int</span> j = R;<br>    <span class="hljs-keyword">while</span> (i &lt;= j) &#123;<br>        <span class="hljs-keyword">if</span> (s[i++] != s[j--]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(string &amp;s, <span class="hljs-type">int</span> i,<span class="hljs-type">int</span> dp[])</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i == s.<span class="hljs-built_in">length</span>()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dp[i]!=<span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> dp[i];<br>    &#125;<br>    <span class="hljs-type">int</span> minNum = INT_MAX;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; s.<span class="hljs-built_in">length</span>(); ++j) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">judge</span>(s, i, j)) &#123;<br>            minNum = <span class="hljs-built_in">min</span>(minNum, <span class="hljs-built_in">f</span>(s, j + <span class="hljs-number">1</span>,dp) + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    dp[i] = minNum;<br>    <span class="hljs-keyword">return</span> dp[i];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCut</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> dp[s.<span class="hljs-built_in">size</span>()<span class="hljs-number">+1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>()<span class="hljs-number">+1</span>; ++i) &#123;<br>        dp[i] = <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(s,<span class="hljs-number">0</span>,dp)<span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3"><a href="#3-3" class="headerlink" title="3-3"></a>3-3</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">toHuiwen</span><span class="hljs-params">(string &amp;s, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = L;<br>    <span class="hljs-type">int</span> j = R;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= j) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] != s[j]) &#123;<br>            num++;<br>        &#125;<br>        i++;<br>        j--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> num;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> i, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; &amp;dp)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (dp[k][i] != <span class="hljs-number">-2</span>) &#123;<br>        <span class="hljs-keyword">return</span> dp[k][i];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> (i == s.<span class="hljs-built_in">size</span>()) ? <span class="hljs-number">0</span> : INT_MAX; <span class="hljs-comment">// 只有正好分完才返回0，否则无解</span><br>    <span class="hljs-keyword">if</span> (i == s.<span class="hljs-built_in">size</span>())<br>        <span class="hljs-keyword">return</span> INT_MAX; <span class="hljs-comment">// `k &gt; 0` 但字符串走完了，返回无解</span><br>    <span class="hljs-type">int</span> minSum = INT_MAX;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; s.<span class="hljs-built_in">size</span>(); ++j) &#123;<br>        <span class="hljs-type">int</span> num = <span class="hljs-built_in">toHuiwen</span>(s, i, j);<br>        <span class="hljs-type">int</span> next = <span class="hljs-built_in">f</span>(s, k - <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>, dp);<br>        <span class="hljs-keyword">if</span> (next != INT_MAX) &#123;<br>            minSum = <span class="hljs-built_in">min</span>(num + <span class="hljs-built_in">f</span>(s, k - <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>, dp), minSum);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[k][i] = minSum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">palindromePartition</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">dp</span>(k + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(s.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">-2</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(s, k, <span class="hljs-number">0</span>, dp);<br>&#125;<br></code></pre></td></tr></table></figure><p>当所有 <code>next == -1</code> 时，<code>minSum</code> 不会被更新，仍然是 <code>INT_MAX</code>。无效状态定义为INT_MAX</p><h4 id="3-4"><a href="#3-4" class="headerlink" title="3-4"></a>3-4</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkPartitioning1</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">dp</span>(<span class="hljs-number">4</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(s.<span class="hljs-built_in">length</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    dp[<span class="hljs-number">0</span>][s.<span class="hljs-built_in">length</span>()] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= <span class="hljs-number">3</span>; ++k) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; s.<span class="hljs-built_in">length</span>(); ++j) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isHuiwen</span>(s, i, j) &amp;&amp; dp[k<span class="hljs-number">-1</span>][j<span class="hljs-number">+1</span>]==<span class="hljs-number">1</span>) &#123;<br>                    dp[k][i] = <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">preDo</span>(string&amp; s) &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pre</span>(s.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; s.<span class="hljs-built_in">size</span>(); ++j) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isHuiwen</span>(s, i, j)) &#123;<br>                pre[i].<span class="hljs-built_in">push_back</span>(j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkPartitioning</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(<span class="hljs-number">4</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(s.<span class="hljs-built_in">length</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    dp[<span class="hljs-number">0</span>][s.<span class="hljs-built_in">length</span>()] = <span class="hljs-number">1</span>;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; pre = <span class="hljs-built_in">preDo</span>(s);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= <span class="hljs-number">3</span>; ++k) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : pre[i]) &#123; <span class="hljs-comment">// 遍历存储的索引</span><br>                <span class="hljs-keyword">if</span> (dp[k - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) &#123;<br>                    dp[k][i] = <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>];<br><br>&#125;<br><span class="hljs-comment">//预处理</span><br></code></pre></td></tr></table></figure><h4 id="3-5"><a href="#3-5" class="headerlink" title="3-5"></a>3-5</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">breakPalindrome</span><span class="hljs-params">(string palindrome)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (palindrome.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = palindrome.<span class="hljs-built_in">size</span>() &gt;&gt; <span class="hljs-number">1</span>;<br>    cout &lt;&lt;mid&lt;&lt;endl;<br>    string ans = palindrome;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (; i &lt; mid; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (palindrome[i] != <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>            ans[i] = <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>    &#125;<br>    ans[palindrome.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>] = <span class="hljs-string">&#x27;b&#x27;</span>;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-comment">//简单贪心</span><br></code></pre></td></tr></table></figure><h4 id="3-6"><a href="#3-6" class="headerlink" title="3-6"></a>3-6</h4><p>暴力遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getCnt</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; &amp;cnt)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-type">int</span> now = nums[i];<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (now != <span class="hljs-number">0</span>) &#123;<br>            cnt[i][j] = (now % <span class="hljs-number">2</span>);<br>            now /= <span class="hljs-number">2</span>;<br>            j++;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBeautiful</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;ans)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ans.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (ans[i] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">beautifulSubarrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> maxNum = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &gt; maxNum) &#123;<br>            maxNum = nums[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> digit = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (maxNum != <span class="hljs-number">0</span>) &#123;<br>        maxNum /= <span class="hljs-number">2</span>;<br>        digit++;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">cnt</span>(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(digit, <span class="hljs-number">0</span>));<br>    <span class="hljs-built_in">getCnt</span>(nums, cnt);<br><br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(digit, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; nums.<span class="hljs-built_in">size</span>(); ++j) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; digit; ++k) &#123;<br>                ans[k] += cnt[j][k];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isBeautiful</span>(ans)) &#123;<br>                sum++;<br>                <span class="hljs-comment">// for (int no = 0; no &lt; digit; ++no) &#123;</span><br>                <span class="hljs-comment">//     cout &lt;&lt; ans[no] &lt;&lt; &quot; &quot;;</span><br>                <span class="hljs-comment">// &#125;</span><br>                <span class="hljs-comment">// cout &lt;&lt; endl;</span><br>                <span class="hljs-comment">// for (int m = i; m &lt;= j; ++m) &#123;</span><br>                <span class="hljs-comment">//     cout &lt;&lt; nums[m] &lt;&lt; &quot; &quot;;</span><br>                <span class="hljs-comment">// &#125;</span><br>                <span class="hljs-comment">// cout &lt;&lt; endl;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-comment">//时间复杂度O(n2k)</span><br></code></pre></td></tr></table></figure><p>优化思路一：利用前缀和统计 每一个子数组不用计算大小了，直接用前缀和计算</p><p>优化思路二：异或操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">beautifulSubarrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt; <span class="hljs-comment">//存储每个0-i位置的前缀和，也就是总的异或值</span><br>        <span class="hljs-type">int</span> mask = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>        cnt[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums) &#123;<br>            mask ^= x;<br>            ans += cnt[mask]; <span class="hljs-comment">//如果之前有相同的异或值，那么就代表中间的那段是美丽的</span><br>            cnt[mask]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="3-7"><a href="#3-7" class="headerlink" title="3-7"></a>3-7</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">beautifulSubsets</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;<br>        function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> i) &#123;<br>            <span class="hljs-keyword">if</span> (i == nums.<span class="hljs-built_in">size</span>()) &#123;<br>                ans++;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (cnt[nums[i] - k] == <span class="hljs-number">0</span> &amp;&amp; cnt[nums[i] + k] == <span class="hljs-number">0</span>) &#123;<br>                ++cnt[nums[i]];<br>                <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>);<br>                --cnt[nums[i]];<br>            &#125;<br>        &#125;;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//暴力递归</span><br></code></pre></td></tr></table></figure><h4 id="3-10"><a href="#3-10" class="headerlink" title="3-10"></a>3-10</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">toArr</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; arr;<br>    <span class="hljs-keyword">while</span> (num != <span class="hljs-number">0</span>) &#123;<br>        arr.<span class="hljs-built_in">push_back</span>(num % <span class="hljs-number">10</span>);<br>        num /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">divisorSubstrings</span><span class="hljs-params">(<span class="hljs-type">int</span> num, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; arr = <span class="hljs-built_in">toArr</span>(num);<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= arr.<span class="hljs-built_in">size</span>() - k; ++i) &#123;<br>        <span class="hljs-type">int</span> now = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k; ++j) &#123;<br>            now += <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, j) * arr[i + j];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (num != <span class="hljs-number">0</span> &amp;&amp; num % now == <span class="hljs-number">0</span>) &#123;<br>            cnt++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-11"><a href="#3-11" class="headerlink" title="3-11"></a>3-11</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOfBeauties</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> N = nums.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxNums</span><span class="hljs-params">(N)</span></span>; <span class="hljs-comment">//记录当前数左边的最大数</span><br>    <span class="hljs-type">int</span> maxNum = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N - <span class="hljs-number">1</span>; ++i) &#123;<br>        maxNum = <span class="hljs-built_in">max</span>(nums[i - <span class="hljs-number">1</span>], maxNum);<br>        maxNums[i] = maxNum;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minNums</span><span class="hljs-params">(N)</span></span>;<br>    <span class="hljs-type">int</span> minNum = nums[N - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = N - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">1</span>; --i) &#123;<br>        minNum = <span class="hljs-built_in">min</span>(minNum, nums[i + <span class="hljs-number">1</span>]);<br>        minNums[i] = minNum;<br>    &#125;<br><br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N - <span class="hljs-number">2</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (maxNums[i] &lt; nums[i] &amp;&amp; nums[i] &lt; minNums[i]) &#123;<br>            cnt += <span class="hljs-number">2</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i - <span class="hljs-number">1</span>] &lt; nums[i] &amp;&amp; nums[i] &lt; nums[i + <span class="hljs-number">1</span>]) &#123;<br>            cnt += <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-12"><a href="#3-12" class="headerlink" title="3-12"></a>3-12</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countOfSubstrings</span><span class="hljs-params">(string word, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">bool</span> jug[<span class="hljs-number">5</span>];<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p = <span class="hljs-number">0</span>; p &lt; word.<span class="hljs-built_in">size</span>(); p++) &#123;<br>            <span class="hljs-built_in">memset</span>(jug, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(jug));<br>            <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>            <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = p; i &lt; word.<span class="hljs-built_in">size</span>(); i++) &#123;<br>                <span class="hljs-keyword">if</span> (word[i] == <span class="hljs-string">&#x27;a&#x27;</span>)<br>                    jug[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (word[i] == <span class="hljs-string">&#x27;e&#x27;</span>)<br>                    jug[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (word[i] == <span class="hljs-string">&#x27;i&#x27;</span>)<br>                    jug[<span class="hljs-number">2</span>] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (word[i] == <span class="hljs-string">&#x27;o&#x27;</span>)<br>                    jug[<span class="hljs-number">3</span>] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (word[i] == <span class="hljs-string">&#x27;u&#x27;</span>)<br>                    jug[<span class="hljs-number">4</span>] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">else</span><br>                    count++;<br>                <span class="hljs-keyword">if</span> (count &gt; k) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (!flag) &#123;<br>                    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">for</span> (; j &lt; <span class="hljs-number">5</span>; j++) &#123;<br>                        <span class="hljs-keyword">if</span> (jug[j] == <span class="hljs-literal">false</span>)<br>                            <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (j == <span class="hljs-number">5</span>)<br>                        flag = <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (flag) &#123;<br>                    <span class="hljs-keyword">if</span> (count == k)<br>                        ans++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//滑动窗口进行优化</span><br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">countOfSubstrings</span><span class="hljs-params">(string <span class="hljs-type">word</span>, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        set&lt;<span class="hljs-type">char</span>&gt; vowels = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>&#125;;<br>        <span class="hljs-keyword">auto</span> count = [&amp;](<span class="hljs-type">int</span> m) -&gt; <span class="hljs-type">long</span> <span class="hljs-type">long</span> &#123;<br>            <span class="hljs-type">int</span> n = <span class="hljs-type">word</span>.<span class="hljs-built_in">size</span>(), consonants = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">0</span>;<br>            map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; occur;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; (consonants &lt; m || occur.<span class="hljs-built_in">size</span>() &lt; vowels.<span class="hljs-built_in">size</span>())) &#123;<br>                    <span class="hljs-keyword">if</span> (vowels.<span class="hljs-built_in">count</span>(<span class="hljs-type">word</span>[j])) &#123;<br>                        occur[<span class="hljs-type">word</span>[j]]++;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        consonants++;<br>                    &#125;<br>                    j++;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (consonants &gt;= m &amp;&amp; occur.<span class="hljs-built_in">size</span>() == vowels.<span class="hljs-built_in">size</span>()) &#123;<br>                    res += n - j + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (vowels.<span class="hljs-built_in">count</span>(<span class="hljs-type">word</span>[i])) &#123;<br>                    occur[<span class="hljs-type">word</span>[i]]--;<br>                    <span class="hljs-keyword">if</span> (occur[<span class="hljs-type">word</span>[i]] == <span class="hljs-number">0</span>) &#123;<br>                        occur.<span class="hljs-built_in">erase</span>(<span class="hljs-type">word</span>[i]);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    consonants--;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">count</span>(k) - <span class="hljs-built_in">count</span>(k + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="3-13"><a href="#3-13" class="headerlink" title="3-13"></a>3-13</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">countOfSubstrings</span><span class="hljs-params">(string word, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        set&lt;<span class="hljs-type">char</span>&gt; vowels = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>&#125;;<br>        <span class="hljs-keyword">auto</span> count = [&amp;](<span class="hljs-type">int</span> m) -&gt; <span class="hljs-type">long</span> <span class="hljs-type">long</span> &#123;<br>            <span class="hljs-type">int</span> n = word.<span class="hljs-built_in">size</span>(), consonants = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">0</span>;<br>            map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; occur;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; (consonants &lt; m || occur.<span class="hljs-built_in">size</span>() &lt; vowels.<span class="hljs-built_in">size</span>())) &#123;<br>                    <span class="hljs-keyword">if</span> (vowels.<span class="hljs-built_in">count</span>(word[j])) &#123;<br>                        occur[word[j]]++;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        consonants++;<br>                    &#125;<br>                    j++;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (consonants &gt;= m &amp;&amp; occur.<span class="hljs-built_in">size</span>() == vowels.<span class="hljs-built_in">size</span>()) &#123;<br>                    res += n - j + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (vowels.<span class="hljs-built_in">count</span>(word[i])) &#123;<br>                    occur[word[i]]--;<br>                    <span class="hljs-keyword">if</span> (occur[word[i]] == <span class="hljs-number">0</span>) &#123;<br>                        occur.<span class="hljs-built_in">erase</span>(word[i]);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    consonants--;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">count</span>(k) - <span class="hljs-built_in">count</span>(k + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="3-14"><a href="#3-14" class="headerlink" title="3-14"></a>3-14</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(string num)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ou = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> ji = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (i &amp; <span class="hljs-number">1</span> != <span class="hljs-number">0</span>) &#123;<br>            ou += num[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ji += num[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ji == ou ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-15"><a href="#3-15" class="headerlink" title="3-15"></a>3-15</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">scoreOfString</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        ans += <span class="hljs-built_in">abs</span>(s[i] - s[i - <span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔记</title>
    <link href="/2025/02/26/%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/02/26/%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h4 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h4><p>文件有三种状态 分别是未跟踪,未提交,已提交</p><p>$ git config –global user.name “OI Wiki” </p><p>$ git config –global user.email <a href="mailto:&#x6f;&#105;&#45;&#119;&#105;&#x6b;&#x69;&#64;&#101;&#120;&#97;&#109;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#x6d;">&#x6f;&#105;&#45;&#119;&#105;&#x6b;&#x69;&#64;&#101;&#120;&#97;&#109;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#x6d;</a></p><p>git init</p><p>$ git clone <a href="https://github.com/OI-wiki/OI-wiki">https://github.com/OI-wiki/OI-wiki</a>  把一个仓库拷贝到本地</p><p>git status 查询当前状态</p><p>git add +文件名字 </p><p>git commit +文件名字 -m表示添加提交的信息</p><p>前两者不加文件表示对所有文件执行</p><p>为了不将一些文件纳入跟踪,可以创建<code>.gitignore</code>文件 </p><p>例如，<code>*.exe</code> 将自动忽略仓库里的所有扩展名为 <code>.exe</code> 的文件。</p><p>git log 查看当前提交记录</p><p>head指针指向当前分支</p><p>git branch 查看分支  加上名称可以创建新分支</p><p>git Switch 切换分支 -c表示创建并切换</p><p>*指向的分支是当前分支</p><p>可以理解为按照时间线为当前节点创建一个快照</p><p>git merge +分支名称 将该分支合并到当前分支上</p><p>git branch -d   +分支名称 删除分支</p><p>如果在两个分支中，对同一个文件的同一部分进行了不同的更改，Git 就无法自动合并这两个分支，也就是发生了合并冲突。</p><p><img src="D:\files\图片\Snipaste_2024-09-28_18-20-19.png" alt="Snipaste_2024-09-28_18-20-19"></p><p>Sqash压缩合并:B-&gt;A</p><p>merge合并会将B分支的所有commit并入A分支的提交历史中</p><p>squash会把B分支的commit合并为一次commit提交到A分支中</p><p>git merge B –squash</p><p>此时只将B分支存入了A的缓存区中,之后还需要git commit</p><p>Rebase(变基)</p><p>就相当于从未有过B分支,只是在A分支上进行修改</p><p>git checkout&#x2F;&#x2F;应该和Switch是一样的 B git rebase A git checkout A git merge B</p><p>git remote 查看当前仓库的远程仓库列表</p><p>origin代表克隆用的链接</p><p>$ git remote show origin 查看详细信息</p><p>执行 <code>git remote add &lt;name&gt; &lt;url&gt;</code> 命令可以添加一个名字为 <code>name</code>，链接为 <code>url</code> 的远程仓库。</p><p>执行 <code>git remote rename &lt;oldname&gt; &lt;newname&gt;</code> 可以将名字为 <code>oldname</code> 的远程仓库改名为 <code>newname</code>。</p><p>执行 <code>git remote rm &lt;name&gt;</code> 可以删除名字为 <code>name</code> 的远程仓库。</p><p>执行 <code>git remote get-url &lt;name&gt;</code> 可以查看名字为 <code>name</code> 的远程仓库的链接。</p><p>执行 <code>git remote set-url &lt;name&gt; &lt;newurl&gt;</code> 可以将名字为 <code>name</code> 的远程仓库的链接更改为 <code>newurl</code>。</p><p>$ git fetch <remote-name> # 获取 <remote-name> 的更改</p><p>$ git pull <remote-name> <branch> # 获取 <remote-name> 的更改，然后将这些更改合并到 HEAD</p><p>$ git push <remote-name> <from>:<to> # 将本地 <from> 分支的更改推送至 <remote-name> 的 <to> 分支</p><p>根据远程仓库的要求，可能会要求你输入远程仓库账户的用户名和密码。</p><p>需要注意的是，你的更改能成功推送，需要满足两个条件：你拥有向这个仓库（分支）的写入权限，且你的这个分支比远程仓库的相应分支新（可以理解为没有人在你进行更改的这段时间进行了推送）。当远程分支有当前分支没有的新更改时，可以执行 <code>git pull</code> 命令完成合并再提交</p><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><p>谓词,谓词就是返回值为真或者假的函数  可以用函数对象来实现</p><ul><li><strong>栈</strong>(<code>stack</code>) 后进先出 (LIFO) 的容器，默认是对双端队列（<code>deque</code>）的包装。</li><li><strong>队列</strong>(<code>queue</code>) 先进先出 (FIFO) 的容器，默认是对双端队列（<code>deque</code>）的包装。</li><li><strong>优先队列</strong>(<code>priority_queue</code>) 元素的次序是由作用于所存储的值对上的某种谓词决定的的一种队列，默认是对向量（<code>vector</code>）的包装。</li></ul><p><code>array</code> 实际上是 STL 对数组的封装。它相比 <code>vector</code> 牺牲了动态扩容的特性，但是换来了与原生数组几乎一致的性能（在开满优化的前提下）。因此如果能使用 C++11 特性的情况下，能够使用原生数组的地方几乎都可以直接把定长数组都换成 <code>array</code>，而动态分配的数组可以替换为 <code>vector</code>。</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><h5 id="1-splice"><a href="#1-splice" class="headerlink" title="1. splice()"></a>1. <strong>splice()</strong></h5><ul><li><strong>用途</strong>：将一个 <code>list</code> 的部分或全部元素插入到另一个 <code>list</code> 的指定位置。</li><li><strong>场景</strong>：当你需要高效地移动元素而不进行复制或重新分配时，例如从一个列表中移除某些元素并将其添加到另一个列表。</li></ul><h5 id="2-remove"><a href="#2-remove" class="headerlink" title="2. remove()"></a>2. <strong>remove()</strong></h5><ul><li><strong>用途</strong>：移除列表中所有与给定值相等的元素。</li><li><strong>场景</strong>：需要清理列表中的特定值，如去掉所有的特定错误代码或标记。</li></ul><h5 id="3-sort"><a href="#3-sort" class="headerlink" title="3. sort()"></a>3. <strong>sort()</strong></h5><ul><li><strong>用途</strong>：对 <code>list</code> 中的元素进行排序。</li><li><strong>场景</strong>：在处理大量动态数据时，需要对列表进行排序，而不需要随机访问的情况下（如用户输入的任务列表）。</li></ul><h5 id="4-unique"><a href="#4-unique" class="headerlink" title="4. unique()"></a>4. <strong>unique()</strong></h5><ul><li><strong>用途</strong>：移除连续重复的元素。</li><li><strong>场景</strong>：在处理数据流时，可能需要消除连续的重复数据，如去重用户输入或日志中的相同事件。</li></ul><h5 id="5-merge"><a href="#5-merge" class="headerlink" title="5. merge()"></a>5. <strong>merge()</strong></h5><ul><li><strong>用途</strong>：将两个已排序的 <code>list</code> 合并成一个有序的 <code>list</code>。</li><li><strong>场景</strong>：在合并两个结果集时，例如将两个不同来源的任务列表合并为一个，同时保持顺序。</li></ul><p>set</p><p><code>set</code> 是关联容器，含有键值类型对象的已排序集，搜索、移除和插入拥有对数复杂度。<code>set</code> 内部通常采用 <a href="https://oi-wiki.org/ds/rbtree/">红黑树</a> 实现。<a href="https://oi-wiki.org/ds/bst/">平衡二叉树</a> 的特性使得 <code>set</code> 非常适合处理需要同时兼顾查找、插入与删除的情况。</p><ul><li><p><code>insert(x)</code> 当容器中没有等价元素的时候，将元素 x 插入到 <code>set</code> 中。</p></li><li><p><code>erase(x)</code> 删除值为 x 的 <strong>所有</strong> 元素，返回删除元素的个数。</p></li><li><p><code>erase(pos)</code> 删除迭代器为 pos 的元素，要求迭代器必须合法。</p></li><li><p><code>erase(first,last)</code> 删除迭代器在 ![<a href="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">first,last)</a> 范围内的所有元素。</p></li><li><p><code>clear()</code> 清空 <code>set</code>。</p></li><li><p><code>count(x)</code> 返回 <code>set</code> 内键为 x 的元素数量。</p></li><li><p><code>find(x)</code> 在 <code>set</code> 内存在键为 x 的元素时会返回该元素的迭代器，否则返回 <code>end()</code>。</p></li><li><p><code>lower_bound(x)</code> 返回指向首个不小于给定键的元素的迭代器。如果不存在这样的元素，返回 <code>end()</code>。</p></li><li><p><code>upper_bound(x)</code> 返回指向首个大于给定键的元素的迭代器。如果不存在这样的元素，返回 <code>end()</code>。</p></li><li><p><code>empty()</code> 返回容器是否为空。</p></li><li><p><code>size()</code> 返回容器内元素个数。</p></li></ul><p><code>set</code> 自带的 <code>lower_bound</code> 和 <code>upper_bound</code> 的时间复杂度为 logn。</p><p>但使用 <code>algorithm</code> 库中的 <code>lower_bound</code> 和 <code>upper_bound</code> 函数对 <code>set</code> 中的元素进行查询，时间复杂度为 n。</p><p><code>set</code> 没有提供自带的 <code>nth_element</code>。使用 <code>algorithm</code> 库中的 <code>nth_element</code> 查找第 k大的元素时间复杂度为n。</p><p>如果需要实现平衡二叉树所具备的logn查找第k大元素的功能，需要自己手写平衡二叉树或权值线段树，或者选择使用 pb_ds 库中的平衡二叉树。</p><p>map</p><p>在利用下标访问 <code>map</code> 中的某个元素时，如果 <code>map</code> 中不存在相应键的元素，会自动在 <code>map</code> 中插入一个新元素，并将其值设置为默认值（对于整数，值为零；对于有默认构造函数的类型，会调用默认构造函数进行初始化）。</p><p>当下标访问操作过于频繁时，容器中会出现大量无意义元素，影响 <code>map</code> 的效率。因此一般情况下推荐使用 <code>find()</code> 函数来寻找特定键的元素。</p><ul><li><code>count(x)</code>: 返回容器内键为 x 的元素数量。复杂度为 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="O(\log(size)+ans)">（关于容器大小对数复杂度，加上匹配个数）。</li><li><code>find(x)</code>: 若容器内存在键为 x 的元素，会返回该元素的迭代器；否则返回 <code>end()</code>。</li><li><code>lower_bound(x)</code>: 返回指向首个不小于给定键的元素的迭代器。</li><li><code>upper_bound(x)</code>: 返回指向首个大于给定键的元素的迭代器。若容器内所有元素均小于或等于给定键，返回 <code>end()</code>。</li><li><code>empty()</code>: 返回容器是否为空。</li><li><code>size()</code>: 返回容器内元素个数</li></ul><p>stl算法</p><ul><li><code>sort</code>：排序。<code>sort(v.begin(), v.end(), cmp)</code> 或 <code>sort(a + begin, a + end, cmp)</code>，其中 <code>end</code> 是排序的数组最后一个元素的后一位，<code>cmp</code> 为自定义的比较函数。</li><li><code>stable_sort</code>：稳定排序，用法同 <code>sort()</code>。</li><li><code>nth_element</code>：按指定范围进行分类，即找出序列中第 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="n"> 大的元素，使其左边均为小于它的数，右边均为大于它的数。<code>nth_element(v.begin(), v.begin() + mid, v.end(), cmp)</code> 或 <code>nth_element(a + begin, a + begin + mid, a + end, cmp)</code>。</li><li><code>binary_search</code>：二分查找。<code>binary_search(v.begin(), v.end(), value)</code>，其中 <code>value</code> 为需要查找的值</li><li><code>merge</code>：将两个（已排序的）序列 <strong>有序合并</strong> 到第三个序列的 <strong>插入迭代器</strong> 上。<code>merge(v1.begin(), v1.end(), v2.begin(), v2.end() ,back_inserter(v3))</code>。</li><li><code>inplace_merge</code>：将两个（已按小于运算符排序的）：<code>[first,middle), [middle,last)</code> 范围 <strong>原地合并为一个有序序列</strong>。<code>inplace_merge(v.begin(), v.begin() + middle, v.end())</code>。</li></ul><p><code>shuffle</code> 函数代替原来的 <code>random_shuffle</code>。使用方法为 <code>shuffle(v.begin(), v.end(), rng)</code>（最后一个参数传入的是使用的随机数生成器，一般情况使用以真随机数生成器 <a href="https://zh.cppreference.com/w/cpp/numeric/random/random_device"><code>random_device</code></a> 播种的梅森旋转伪随机数生成器 <a href="https://zh.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine"><code>mt19937</code></a>）。</p><ul><li><code>next_permutation</code>：将当前排列更改为 <strong>全排列中的下一个排列</strong>。如果当前排列已经是 <strong>全排列中的最后一个排列</strong>（<code>元素完全从大到小排列</code>），函数返回 <code>false</code> 并将排列更改为 <strong>全排列中的第一个排列</strong>（元素完全从小到大排列）；否则，函数返回 <code>true</code>。<code>next_permutation(v.begin(), v.end())</code> 或 <code>next_permutation(v + begin, v + end)</code>。</li><li><code>prev_permutation</code>：将当前排列更改为 <strong>全排列中的上一个排列</strong>。用法同 <code>next_permutation</code>。</li><li><code>partial_sum</code>：求前缀和。 <code>partial_sum(src.begin(), src.end(), back_inserter(dst))</code>。</li></ul><p>bitset</p><p>std::bitset&lt;1000&gt; bs;  需要指定大小</p><ul><li><code>bitset()</code>: 每一位都是 <code>false</code>。</li><li><code>bitset(unsigned long val)</code>: 设为 <code>val</code> 的二进制形式。</li><li><code>bitset(const string&amp; str)</code>: 设为 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="01"> 串 <code>str</code>。</li></ul><p>成员函数</p><ul><li><code>count()</code>: 返回 <code>true</code> 的数量。</li><li><code>size()</code>: 返回 <code>bitset</code> 的大小。</li><li><code>test(pos)</code>: 它和 <code>vector</code> 中的 <code>at()</code> 的作用是一样的，和 <code>[]</code> 运算符的区别就是越界检查。</li><li><code>any()</code>: 若存在某一位是 <code>true</code> 则返回 <code>true</code>，否则返回 <code>false</code>。</li><li><code>none()</code>: 若所有位都是 <code>false</code> 则返回 <code>true</code>，否则返回 <code>false</code>。</li><li><code>all()</code>: 若所有位都是 <code>true</code> 则返回 <code>true</code>，否则返回 <code>false</code>。</li><li><ol><li><code>set()</code>: 将整个 <code>bitset</code> 设置成 <code>true</code>。</li><li><code>set(pos, val = true)</code>: 将某一位设置成 <code>true</code>&#x2F;<code>false</code>。</li></ol></li><li><ol><li><code>reset()</code>: 将整个 <code>bitset</code> 设置成 <code>false</code>。</li><li><code>reset(pos)</code>: 将某一位设置成 <code>false</code>。相当于 <code>set(pos, false)</code>。</li></ol></li><li><ol><li><code>flip()</code>: 翻转每一位。(相当于异或一个全是1的 <code>bitset</code>）</li><li><code>flip(pos)</code>: 翻转某一位。</li></ol></li><li><code>to_string()</code>: 返回转换成的字符串表达。</li><li><code>to_ulong()</code>: 返回转换成的 <code>unsigned long</code> 表达（<code>long</code> 在 NT 及 32 位 POSIX 系统下与 <code>int</code> 一样，在 64 位 POSIX 下与 <code>long long</code> 一样）。</li><li><code>to_ullong()</code>:（<strong>C++11</strong> 起）返回转换成的 <code>unsigned long long</code> 表达。</li><li></li></ul><p>另外，libstdc++ 中有一些较为实用的内部成员函数<a href="https://oi-wiki.org/lang/csl/bitset/#fn:bitset1">1</a>：</p><ul><li><code>_Find_first()</code>: 返回 <code>bitset</code> 第一个 <code>true</code> 的下标，若没有 <code>true</code> 则返回 <code>bitset</code> 的大小。</li><li><code>_Find_next(pos)</code>: 返回 <code>pos</code> 后面（下标严格大于 <code>pos</code> 的位置）第一个 <code>true</code> 的下标，若 <code>pos</code> 后面没有 <code>true</code> 则返回 <code>bitset</code> 的大小。</li></ul><p>string</p><p>string有两个成员函数能够将自己转换为 char 指针——<code>data()</code>&#x2F;c_str() <code>c_str()</code> 保证末尾有空字符，而 <code>data()</code> 则不保证</p><p><code>find(str,pos)</code> 函数可以用来查找字符串中一个字符&#x2F;字符串在 <code>pos</code>（含）之后第一次出现的位置（若不传参给 <code>pos</code> 则默认为 <code>0</code>）。如果没有出现，则返回 <code>string::npos</code>（被定义为 <code>-1</code>，但类型仍为 <code>size_t</code>&#x2F;<code>unsigned long</code>）。</p><p><code>substr(pos, len)</code> 函数的参数返回从 <code>pos</code> 位置开始截取最多 <code>len</code> 个字符组成的字符串（如果从 <code>pos</code> 开始的后缀长度不足 <code>len</code> 则截取这个后缀）。</p><p><code>insert(index,count,ch)</code> 和 <code>insert(index,str)</code> 是比较常见的插入函数。它们分别表示在 <code>index</code> 处连续插入 <code>count</code> 次字符串 <code>ch</code> 和插入字符串 <code>str</code>。</p><p><code>erase(index,count)</code> 函数将字符串 <code>index</code> 位置开始（含）的 <code>count</code> 个字符删除（若不传参给 <code>count</code> 则表示删去 <code>index</code> 位置及以后的所有字符）。</p><p><code>replace(pos,count,str)</code> 和 <code>replace(first,last,str)</code> 是比较常见的替换函数。它们分别表示将从 <code>pos</code> 位置开始 <code>count</code> 个字符的子串替换为 <code>str</code> 以及将以 <code>first</code> 开始（含）、<code>last</code> 结束（不含）的子串替换为 <code>str</code>，其中 <code>first</code> 和 <code>last</code> 均为迭代器。</p><p>将字符串 s 的第 3~7 位替换为空串后得到的字符串是 OI 将字符串 s 的前两位替换为 NOI 后得到的字符串是 NOI</p><p>左值是有内存地址的对象，而右值只是一个中间计算结果（虽然编译器往往需要在内存中分配地址来储存这个值，但这个内存地址是无法被程序员感知的，所以可以认为它不存在）。中间计算结果就意味着这个值马上就没用了，以后不会再访问它。</p><p>在大多数情况下，数组名（例如 <code>arr</code>）表示的是整个数组。它可以隐式转换为指向数组首个元素的指针，但这并不意味着它本身就是一个指针。</p><p><strong>隐式转换</strong>：当你在表达式中使用数组名时，编译器会自动将其视为指向数组首个元素的指针。例如，<code>arr</code> 在大多数上下文中会被视为 <code>&amp;arr[0]</code>。</p><p><strong>取地址运算符</strong> <code>&amp;</code>：对数组名使用取地址运算符 <code>&amp;</code>，会得到整个数组的地址，而不仅仅是首个元素的地址。</p><p><strong>左值引用</strong>：适用于需要访问和修改已有对象的情况。</p><p><strong>右值引用</strong>：适用于处理临时对象，提供资源管理的优化手段，减少不必要的复制。</p><p><strong>一个对象被移动后不应对其进行任何操作，无论是修改还是访问</strong></p><p><code>#ifdef</code> 之后通常会跟一个宏名，如果该宏已被定义，则编译器会编译 <code>#ifdef</code> 和相应的 <code>#endif</code> 之间的代码。</p><p>如果该宏未被定义，编译器会忽略这些代码。</p><p>[capture] (parameters) mutable -&gt; return-type {statement}</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法:"></a>算法:</h3><p>递归</p><p>int func(传入数值) {  </p><p>if (终止条件) return 最小子问题解;  </p><p>return func(缩小规模); }</p><p>分治算法的核心思想就是「分而治之」。</p><p>大概的流程可以分为三步：分解 -&gt; 解决 -&gt; 合并。</p><ol><li>分解原问题为结构相同的子问题。</li><li>分解到某个容易求解的边界之后，进行递归求解。</li><li>将子问题的解合并成原问题的解。</li></ol><p>分治法能解决的问题一般有如下特征：</p><ul><li>该问题的规模缩小到一定的程度就可以容易地解决。</li><li>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质，利用该问题分解出的子问题的解可以合并为该问题的解。</li><li>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。</li><li>如果各子问题是不独立的，则分治法要重复地解公共的子问题，也就做了许多不必要的工作。此时虽然也可用分治法，但一般用 <a href="https://oi-wiki.org/dp/basic/">动态规划</a> 较好。</li></ul><p><strong>分解 -&gt; 解决（触底）-&gt; 合并（回溯）</strong></p><p><strong>明白一个函数的作用并相信它能完成这个任务，千万不要跳进这个函数里面企图探究更多细节，</strong> 否则就会陷入无穷的细节无法自拔，人脑能压几个栈啊。</p><p>周赛</p><p>3306</p><p>出现次数为k&#x3D;出现次数至少为k-出现至少次数为k+1</p><p>由于满足子串越长,越满足要求,使用滑动窗口</p><p>右指针依次递增,当满足要求时</p><p>向右移动左指针,首次不满足时,代表了左边可以省去的字符个数</p><p>随后结果加上左指针的合理性在于</p><p>右边的字符是满足要求的,即使加上左边的依旧满足要求</p><p>根本思想是先确定一个满足要求最长的串(尾数一定),在找比它长的串有多少</p><p>3307</p><p>递归:</p><p>数量每次都*2,找子问题与边界</p><p>1LL &lt;&lt; n表示2^n</p><p>明白每个函数能做的事，并相信他们能够完成–递归</p><p>三种创建对象的方式</p><p>MyClass obj1;         &#x2F;&#x2F; 默认构造    </p><p>MyClass obj2(10);    &#x2F;&#x2F; 参数化构造    </p><p>MyClass* obj3 &#x3D; new MyClass(20);  &#x2F;&#x2F; 动态创建</p><p>链表,可以创建一个虚拟头指针,防止头指针为空的情况</p><p>且可以更好的处理头指针,防止频繁跟换头指针</p><p>删除某个指针,其实就是将前面那个节点的后指针移动</p><p>删除某个指针,可以将后面的那个指针放到这个位置,并删除后面那个节点</p><p> 链表解题经典三板斧，哑巴节点，栈，快慢指针。哑巴节点一般是为了处理头尾节点用的。dummy</p><p><code>private</code>：只有类内部成员函数能访问。</p><p><code>protected</code>：派生类和类内部成员函数都能访问。</p><p><code>public</code>：任何代码都能访问。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QPaintEvent</span></span>;<br></code></pre></td></tr></table></figure><ul><li>这是前向声明（forward declaration）。它告诉编译器 <code>QPaintEvent</code> 是一个类，但没有提供详细定义。</li><li>前向声明常用于减少头文件依赖，减少编译时间。这里它表明我们在类声明中会用到 <code>QPaintEvent*</code> 指针，而不需要包含完整的 <code>QPaintEvent</code> 头文件。</li></ul><p><code>Q_OBJECT</code> 是一个宏，用于启用 Qt 的信号和槽机制。它必须出现在所有包含信号和槽的类中，它让类具有动态属性、信号与槽等功能。</p><p>递归的题注意一种情况是否影响另一种情况</p><p>记忆化搜索,每次记录已经计算的值</p><p>能用动态规划解决的问题，需要满足三个条件：最优子结构，无后效性和子问题重叠。</p><p>114, 先用链表存储节点</p><p>移动可以用反转来考虑,全反转,前k个反转,后n-k个反转</p><p>92 注意指针结束的位置与相互关系</p><p>注意不要修改后面要用的变量</p><p>86</p><p>因为是链表而不是数组，构建子链不增加空间复杂度。勇敢地构造子链即可，无需考虑节点交换。</p><p>遍历结束后，我们将 <em>large</em> 的 <em>next</em> 指针置空，这是因为当前节点复用的是原链表的节点，而其 <em>next</em> 指针可能指向一个小于 <em>x</em> 的节点</p><p>我们在建造链表时一定要牢记，最后一个节点一定要有所指向，是头结点形成循环链表也好，指向一个NULL值也好。 总而言之是不可以空着的！</p><p>环形链表</p><p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p><p>相交链表</p><p>计算各个链表的长度</p><p>532</p><p>由于集合不重复,可以直接多放几个</p><p>在 C++ 中使用 <code>std::map&lt;int, int&gt;</code> 并尝试访问一个尚未存在的键时，C++ 会自动为这个键插入一个默认值。对于 <code>int</code> 类型的值，默认值是 <code>0</code>。</p><p>注意递归是否能够出来</p><p>前驱,和后继</p><p>350</p><p>得到hash表后,可以随着操作的进行逐渐对hash表键值进行修改</p><p>609</p><p>熟练掌握string的分割</p><p>454</p><p>看到形如：A+B….+N&#x3D;0的式子，要转换为(A+…T)&#x3D;-((T+1)…+N)再计算，这个T的分割点一般是一半，特殊情况下需要自行判断。定T是解题的关键。</p><p>560</p><p><strong>滑动窗口算法</strong>本质上是用来解决<strong>和大于等于</strong>某个值的问题</p><p>滑动窗口计算子数组和大于等于 <code>k</code> 或 <code>k + 1</code> 的子数组个数。但是滑动窗口算法的基本假设是，当窗口内的和大于等于 <code>k</code> 时，可以通过移动左边界来缩小窗口。然而，对于和为 <code>k</code> 的子数组问题，尤其是带有负数的情况下，这种方法会导致窗口的和出现波动，进而无法正确找到和为 <code>k</code> 的子数组。</p><p>代码实现时，通常来说「枚举右，寻找左」是更加好写的。</p><p>前缀和来处理</p><p>计算 <em>nums</em>2[<em>i</em>] 的<strong>下一个更大元素</strong>的值（注意是值不是下标），这是单调栈的标准应用</p><p>从右往左是加入有用的数</p><p>从左往右是去掉无用的数</p><p>当思路不明确是,先想一想暴力解法</p><p>1209</p><p>栈中就保存计数器,对原数组进行操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">stringstream <span class="hljs-title">ss</span><span class="hljs-params">(logs[i])</span></span>;<br>string segment;<br>vector&lt;string&gt; parts;<br><br><span class="hljs-comment">// 使用getline函数，按&#x27;:&#x27;进行分割</span><br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(ss, segment, <span class="hljs-string">&#x27;:&#x27;</span>)) &#123;<br>    parts.<span class="hljs-built_in">push_back</span>(segment);<br>&#125;<br><br><span class="hljs-type">int</span> id = <span class="hljs-built_in">stoi</span>(parts[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 将第一个部分转换为int</span><br>string way = parts[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 第二个部分是string</span><br><span class="hljs-type">int</span> time = <span class="hljs-built_in">stoi</span>(parts[<span class="hljs-number">2</span>]); <span class="hljs-comment">// 将第三个部分转换为int</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> type[<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> idx, timestamp;<br><span class="hljs-built_in">sscanf</span>(log.<span class="hljs-built_in">c_str</span>(), <span class="hljs-string">&quot;%d:%[^:]:%d&quot;</span>, &amp;idx, type, &amp;timestamp);<br></code></pre></td></tr></table></figure><p>用不着每次比较时候都&#x2F;2，最后返回答案的时候&#x2F;2即可</p><p>32.最长有效括号</p><p>1.动态规划</p><p>考虑以每一个字符为结尾的情况,如何根据已有的知识计算现在的值</p><p>2.栈匹配</p><p>将起点位置压栈,始终保持栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」</p><p>3.双向匹配</p><p>因为只有两种字符,贪心地考虑了以当前字符下标结尾的有效括号长度，每次当右括号数量多于左括号数量的时候之前的字符我们都扔掉不再考虑，重新从下一个字符开始计算，但这样会漏掉一种情况，就是遍历的时候左括号的数量始终大于右括号的数量，即 (() ，这种时候最长有效括号是求不出来的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">stk.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">atoi</span>(token.<span class="hljs-built_in">c_str</span>()));<br></code></pre></td></tr></table></figure><p>基本计算器1</p><p>+- 与()全是二元</p><p>由于字符串除了数字与括号外，只有加号和减号两种运算符。</p><p>由于数字不会发生变化,从前往后遍历进行计算,记录当前的符号即可</p><p>每个左括号出现表示记录一下当前括号的符号</p><p>基本计算器2</p><p>+-*&#x2F;全是二元</p><p>只需将乘除的式子结果算出来就行了,于是就压带符号的数字</p><p>移动应用开发基础结构</p><p>第一阶:交互界面,网络协议,数据存储</p><p>第二阶:终端安全,音频视频多媒体,性能稳定性,外设前沿技术</p><p>ZIP文件是一种常见的<strong>压缩文件格式</strong>，用于减少文件或文件夹的大小，方便存储和传输。ZIP文件通过<strong>压缩算法</strong>将多个文件打包到一个单独的文件中，同时减少文件的大小。压缩后的文件体积更小，这样可以节省存储空间或加快传输速度。</p><p><strong>文件结构</strong>：JAR和APK文件本质上都基于ZIP格式，但它们有特定的用途和内容结构。</p><ul><li><strong>JAR</strong>文件是为<strong>Java程序</strong>打包和分发设计的。</li><li><strong>APK</strong>文件则是为<strong>Android应用程序</strong>打包和安装设计的。</li></ul><p>可执行代码文件classes[N].dex 与exe文件类似</p><p>res与resources.arsc文件</p><p>扩展资源assets</p><p>Native共享库lib</p><h3 id="res与resources-arsc的关系："><a href="#res与resources-arsc的关系：" class="headerlink" title="res与resources.arsc的关系："></a><code>res</code>与<code>resources.arsc</code>的关系：</h3><ul><li><strong>编译过程</strong>：<code>res</code>文件夹中的资源在编译过程中，<strong>未编译的资源文件</strong>（如图片）直接打包进APK中，而<strong>编译后的资源</strong>（如字符串、颜色等）则会被打包进<code>resources.arsc</code>文件中。</li><li><strong>资源查找机制</strong>：当应用运行时，如果需要访问资源（例如加载一张图片或一个字符串），系统首先根据资源ID在<code>resources.arsc</code>文件中查找。如果是预编译的资源（如字符串、颜色），系统直接从<code>resources.arsc</code>中读取；如果是未编译的资源（如图片），则会从<code>res</code>文件夹中找到并加载。</li></ul><p><strong>65535限制</strong>在计算机科学中出现于多个不同的领域，通常与数据的最大数量有关，原因是65535（即<strong>2^16 - 1</strong>）是一个16位无符号整数所能表示的最大值。</p><h3 id="Android-65535-方法数限制（方法数限制-DEX-64K-限制）"><a href="#Android-65535-方法数限制（方法数限制-DEX-64K-限制）" class="headerlink" title="Android 65535 方法数限制（方法数限制&#x2F;DEX 64K 限制）"></a><strong>Android 65535 方法数限制（方法数限制&#x2F;<code>DEX</code> 64K 限制）</strong></h3><ul><li><strong>背景</strong>：在Android应用中，编译生成的字节码会被打包成<strong>DEX文件</strong>（Dalvik Executable），这个文件是Android运行时加载并执行的主要文件。DEX文件有一个限制：它的一个索引表（Method ID）只能存放<strong>最多65535个方法</strong>。</li><li><strong>原因</strong>：DEX文件格式使用16位的索引来表示方法，这意味着一个DEX文件最多可以包含65535个方法（包括所有类和库中的方法）。</li><li><strong>解决办法</strong>：如果应用的代码规模超过这个限制（比如使用了大量的第三方库），就会导致“64K方法数”问题。为了解决这个问题，可以使用<strong>MultiDex</strong>技术，将应用拆分成多个DEX文件，避免方法数超限。</li></ul><p>程序应用生命周期用四大组件进行封装:Activity,Service,BroadcastReceiver,ContentProvider</p><p>微信1.0</p><p>登录模块,主界面,聊天功能,消息推送</p><p>软件分层思想:状态相关:界面层,逻辑控制 状态无关:数据存储,网络通信,工具类</p><p>高内聚,低耦合 +轻重分离</p><h3 id="单进程"><a href="#单进程" class="headerlink" title="单进程"></a>单进程</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li><strong>简化数据共享</strong>：同一进程中的不同组件（如<code>Activity</code>、<code>Service</code>、<code>BroadcastReceiver</code>等）可以直接共享内存和数据，避免了复杂的序列化和跨进程通信（IPC）。</li><li><strong>降低复杂性</strong>：应用架构相对简单，管理和调试更容易。无需考虑进程间的同步问题。</li><li><strong>资源使用效率高</strong>：使用单一进程可以减少系统资源开销，如内存和CPU使用率。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li><strong>单点故障</strong>：如果进程发生崩溃，整个应用会被迫关闭。所有组件会受到影响，用户体验不佳。</li><li><strong>性能瓶颈</strong>：在处理耗时操作（如网络请求、数据库操作）时，主线程可能会被阻塞，导致应用无响应（ANR）。</li><li><strong>内存限制</strong>：单个进程的内存限制可能导致在处理大量数据时出现内存溢出。</li></ol><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol><li><strong>增强稳定性</strong>：一个进程的崩溃不会影响到其他进程，提高了应用的稳定性和容错能力。</li><li><strong>更好的资源管理</strong>：可以将不同功能的组件分布在不同的进程中，从而优化内存使用，例如将后台任务放在单独的进程中。</li><li><strong>实现异步处理</strong>：将耗时的操作放在不同的进程中执行，避免主线程被阻塞，提高用户体验。</li></ol><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol><li><strong>复杂的IPC</strong>：跨进程通信需要使用AIDL、Binder等机制，增加了开发的复杂性和维护成本。</li><li><strong>资源开销</strong>：多个进程会占用更多的系统资源，增加内存和CPU的使用。每个进程都有自己的内存空间，可能导致资源浪费。</li><li><strong>数据共享困难</strong>：进程间不能直接共享内存，需通过序列化和反序列化等方式进行数据交换，影响性能。</li></ol><p>横向拆分</p><p>all-in-one</p><p>组合App设计</p><p>单一APP,内部模块化</p><p>开发质量管理:</p><p>持续集成系统: Jenkins+Plugins</p><p>静态代码扫描: CheckStyle Findbugs Android Lint</p><p>单元测试: 逻辑层为主</p><p>稳定性监控: Crash监控 ANR监控</p><p>UI技术探究与应用</p><p>资源管理框架</p><p>res目录</p><p>animator&#x2F;anim 属性动画;补间动画</p><p>color&#x2F; 颜色状态Selector</p><p>drawable&#x2F; Bitmap或XML Drawable files</p><p>layout&#x2F; UI布局</p><p>menu&#x2F; 应用菜单</p><p>values&#x2F; 包含颜色值,字符串,数组等各种常量定义的资源文件</p><p>xml&#x2F; xml属性配置文件</p><p>raw&#x2F; 保存原始格式文件,如音频视频等</p><p>388</p><p>因为是计算叶子节点的长度,直接用深度优先搜索,栈来实现</p><p>动态规划的核心是状态定义和状态转移方程</p><p>选&#x2F;不选&#x2F;选哪个  得到二叉搜索树</p><p>一般从头或尾开始思考</p><p>三问 当前操作 子问题 下一个子问题</p><p>找最后一个为1的数位 x&amp;(~x+1)</p><p>归并排序为什么好</p><p>比较行为没有浪费,变成了整体有序的部分去和其他的比较</p><p>小和问题</p><p>找左侧小于这个数的和</p><p>转变思路:找右侧大于这个数的个数</p><p>用merge的方法,左侧加入需要改变,右边不需要</p><p>因为右边已经排好序,可以直接加上右边的数</p><p>当左组的数等于右组的数时,加入右组的数,这样才知道有多少个数比左组的数大</p><p>求右边有多少个数比当前位置大</p><p>快排1.0</p><p>维护小于</p><p>快排2.0</p><p>维护小于等于大于 一次性成功等于的数  最坏O(N2)</p><p>注意相撞的时候也要判断,为了对边界确定</p><p>快排3.0</p><p>随机需要比较的数</p><p>桶排序</p><p>i位置 左孩子 2*i+1 右孩子2i+2 父(i-1)&#x2F;2</p><p>基本有序，移动不超过k位<br>考虑第0位的数不会来自第7位之后 使用堆排</p><p>基于比较的排序<br>不基于比较的排序<br>计数排序，统计词频<br>基数排序</p><p>有负数可以先加上最小负数最后减去最小负数<br>桶排序，利用前缀和分片，找到每个数应该到的那个位置</p><p>相邻交换的能做到稳定性，不相邻交换的没有稳定性，不基于比较的能很轻易做到稳定<br>稳定性:冒泡，插入，归并，桶排<br>不稳定:选择，快排，堆排</p><p><img src="D:\files\图片\学习\Snipaste_2024-10-23_13-46-28.png" alt="Snipaste_2024-10-23_13-46-28"></p><p><img src="D:\files\图片\学习\Snipaste_2024-10-23_13-47-13.png" alt="Snipaste_2024-10-23_13-47-13"></p><p>快排就是0,1标准的排序</p><p>数量级小的时候用插入（常数项低）</p><p>快排常数项最低，一般最快</p><p>基础类型用快排，自定义用归并（追求稳定性）</p><p><img src="D:\files\图片\学习\Snipaste_2024-10-23_14-51-21.png" alt="Snipaste_2024-10-23_14-51-21"></p><p>回文链表</p><p>栈：将链表进入栈中，随后再次遍历，考查每次pop的值与遍历的值是否一样</p><p>可以找中间节点</p><p>快慢指针:可以根据哪个先走几步调整,慢指针最后</p><p>停在那个位置</p><p>可以快慢找中间节点,然后反转,然后同时走,然后反转</p><p>荷兰国旗问题链表</p><p>复制成数组</p><p><img src="D:\files\图片\学习\Snipaste_2024-10-23_15-08-42.png" alt="Snipaste_2024-10-23_15-08-42"></p><p>带随机指针的链表</p><p>空间 map<img src="D:\files\图片\学习\Snipaste_2024-10-23_15-16-35.png" alt="Snipaste_2024-10-23_15-16-35"></p><p>利用克隆节点的位置</p><p><img src="D:\files\图片\学习\Snipaste_2024-10-23_15-20-35.png" alt="Snipaste_2024-10-23_15-20-35"></p><p>两个单链表相交</p><p>是否有环 用hashset</p><p>手机的 DPI（Dots Per Inch，像素密度）是指每英寸屏幕中所包含的像素数量，用于衡量屏幕的显示精细度</p><p>使用索引放式提高读取速度</p><p>编译成二进制提高即系速度</p><p>减少资源的大小</p><p>XML（eXtensible Markup Language，可扩展标记语言）是一种用于存储和传输数据的标记语言</p><p>资源的编译 R.java res资源ID常量表, resource.arsc res资源索引表</p><p>资源的读取</p><p><img src="D:\files\图片\学习\Snipaste_2024-10-23_16-42-07.png" alt="Snipaste_2024-10-23_16-42-07"></p><p>UI分为窗口与控件</p><p><strong>res目录</strong>，<strong>assets目录</strong>，虽然这里没有，但是我们可以自己创建，两者的区别在于是否前者下所有的资源文件都会在R.java文件下生成对应的资源id，而后者并不会；前者我们可以直接通过资源id访问到对应的资源；而后者则需要我们通过AssetManager以二进制流的形式来读取！对了，这个R文件可以理解为字典，res下每个资源都都会在这里生成一个唯一的id！</p><p>3175</p><p>找连续赢下K次的赢家</p><p>设想有一个玩家位置是i,对于与i比较后输掉的玩家来说,他们一定不是赢家.</p><p>假设玩家i赢了,那么结果是玩家i</p><p>假设玩家i输了,那么也不可能是他们,因为后续拼接再次遍历到他们时,往后遍历还没到k个就一定会出现玩家i,那么他们也不可能赢</p><p>非递归方式完成二叉树的先序，中序，后序遍历</p><p>实质就是先打印头,后打印左,后打印右</p><p>递归序遍历二叉树，每个节点都会来到三次<br>先序中序后序，分别对应第一二三次打印</p><p>栈实现先序，弹出，先压右再压左</p><p>后序先压左后压右,反序就行</p><p>中序,对每一个节点先把左边界压入栈中,这样做的意义是左子树永远先打印,压完后弹出打印,弹出时压右子树</p><p>只考虑需要改的情况</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>华迪实习</title>
    <link href="/2025/02/25/%E5%8D%8E%E8%BF%AA%E5%AE%9E%E4%B9%A0/"/>
    <url>/2025/02/25/%E5%8D%8E%E8%BF%AA%E5%AE%9E%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="2-24"><a href="#2-24" class="headerlink" title="2-24"></a>2-24</h3><p><strong>环境配置</strong></p><p>jdk idea vs code mysql tomcat</p><h3 id="2-25"><a href="#2-25" class="headerlink" title="2-25"></a>2-25</h3><p>javac(编译) .java -&gt;.class(可跨平台使用)</p><p>Java 源代码（<code>.java</code>）经过编译器 (<code>javac</code>) 编译后生成的字节码文件。</p><p>不能直接运行，需要 Java 虚拟机 (JVM) 解析并执行，</p><p>string[] args 命令行参数数组</p><p>六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型</p><p><code>const</code> 对象，意味着：只能调用 <code>const</code> 成员函数。</p><p>const修饰成员函数确保成员函数不会修改对象的成员变量（除 <code>mutable</code> 变量外）。允许 <code>const</code> 对象调用这个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[capture](parameters)-&gt;<span class="hljs-keyword">return</span>-type&#123;body&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>实习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>华迪</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法学习</title>
    <link href="/2025/02/14/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/02/14/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>算法时间复杂度：操作次数只要最高阶的项 O()：最差时间复杂度  工程上会采用平均时间复杂度</p><p>实际需要考虑到操作所需时间，比如位运算和乘法运算的时间差距很大</p><h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selectionSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-type">int</span> minindex = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minindex]) &#123;<br>                minindex = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i != minindex) &#123;<br>            <span class="hljs-built_in">swap</span>(arr[i], arr[minindex]);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printArr</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i: arr) &#123;<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; arr = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>    <span class="hljs-built_in">selectionSort</span>(arr);<br>    <span class="hljs-built_in">printArr</span>(arr);<br>&#125;<br><span class="hljs-comment">//时间复杂度：O(N2) 空间复杂度O(1)</span><br></code></pre></td></tr></table></figure><h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-built_in">swap</span>(arr[j], arr[j + <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//时间复杂度：O(N2) 空间复杂度O(1)</span><br></code></pre></td></tr></table></figure><h5 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h5><p>相同为0，不同为1 符号^  还可以理解为不进位相加</p><p>性质：（实质是同一位上的0和1的个数，奇数个1就是1，偶数个1就是0）</p><p>1.0^N&#x3D;N  N^N&#x3D;0</p><p>2.满足交换律和结合律</p><p>3.满足无序性，同一批数运算出来结果是相同的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap2</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>    arr[i] = arr[i] ^ arr[j];<br>    arr[j] = arr[i] ^ arr[j];<br>    arr[i] = arr[i] ^ arr[j];<br>&#125;<br><span class="hljs-comment">//能够这么做的前提是两个数不是同一块内存(会将两个数都洗成0)，数字可以相等</span><br><span class="hljs-comment">//原理在于当两个数的内存是同一块地址时，会同时改变两个数</span><br></code></pre></td></tr></table></figure><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><p>1.在一个数组中，已知中有一种数出现了奇数次，其他的都出现了偶数次，找出这个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//偶数的都和成0了</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bitex</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        res = arr[i]^res;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.在一个数组中，已知中有两种数出现了奇数次，其他的都出现了偶数次，找出这两个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bitex2</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> eor = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        eor = eor ^ arr[i];<br>    &#125;<br>    <span class="hljs-type">int</span> group = eor &amp; (~eor + <span class="hljs-number">1</span>); <span class="hljs-comment">//提取出最右侧的1，剩下的都是0</span><br>    <span class="hljs-type">int</span> onlyOne = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> ((group &amp; arr[i]) != <span class="hljs-number">0</span>) &#123;<br>            onlyOne ^= arr[i];<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; onlyOne &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; (eor ^ onlyOne) &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//通过eor最低位一个不为1的位将原数组分成两组，一组那一位为0，一组为1，反正偶数个数的数字一定在一组，奇数个数的数字分别在两组</span><br></code></pre></td></tr></table></figure><h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &gt; <span class="hljs-number">0</span>; --j) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[j - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-built_in">swap</span>(arr[j], arr[j - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//逐步实现0~i范围上有序</span><br></code></pre></td></tr></table></figure><h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h5><p>只要是能够构建出一种排他性的问题就可以二分了，比如左边一定有，右边一定没有，又或是左边一定有，右边可能有，只需找一个</p><p>左右两侧与求的问题有关，并且确定可以利用条件甩掉一边就可以二分</p><p>1.在一个有序数组中，找某个数是否存在</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">nt <span class="hljs-title">binarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123; <span class="hljs-comment">//注意这里是&lt;=</span><br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (target == arr[mid]) &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.在一个有序数组中，找&gt;&#x3D;某个数最左侧的位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bigLeft</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (arr[mid] &gt;= target) &#123;<br>            ans = mid;<span class="hljs-comment">//只要是找到新的一定比原来记录的值的小</span><br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;;<br>&#125;<br><span class="hljs-comment">//一直二分到底直到结束，找到最小的那个数</span><br></code></pre></td></tr></table></figure><p>3.局部最小值问题，一个无序数组中，任何两个相邻的位置不同，求一个局部最小的位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLocalMin</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br><span class="hljs-comment">// arr[mid] &lt; arr[mid - 1]：确保 mid 比左邻居小。</span><br><span class="hljs-comment">// arr[mid] &lt; arr[mid + 1]：确保 mid 比右邻居小。</span><br><span class="hljs-comment">// 另外还需要考虑数组的边界：mid == 0 时没有左邻居，mid == arr.size() - 1 时没有右邻居。</span><br>        <span class="hljs-keyword">if</span> ((mid == <span class="hljs-number">0</span> || arr[mid] &lt; arr[mid - <span class="hljs-number">1</span>]) &amp;&amp; (mid == arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> || arr[mid] &lt; arr[mid + <span class="hljs-number">1</span>])) &#123;<br>            <span class="hljs-keyword">return</span> mid; <span class="hljs-comment">// 找到局部最小</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (arr[mid] &gt; arr[mid + <span class="hljs-number">1</span>]) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="对数器（随机样本产生器）"><a href="#对数器（随机样本产生器）" class="headerlink" title="对数器（随机样本产生器）"></a>对数器（随机样本产生器）</h5><p>abs(取绝对值)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//对数器</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">generateRandomArray</span><span class="hljs-params">(<span class="hljs-type">int</span> maxSize, <span class="hljs-type">int</span> maxValue)</span> </span>&#123;<br>    <span class="hljs-type">int</span> size = <span class="hljs-built_in">rand</span>() % (maxSize + <span class="hljs-number">1</span>);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(size)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>        arr[i] = <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">rand</span>() % (maxValue + <span class="hljs-number">1</span>) - <span class="hljs-built_in">rand</span>() % (maxValue + <span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><span class="hljs-comment">//用arr[i] = abs(rand() % (maxValue + 1) - rand() % (maxValue + 1));而不是arr[i]=rand() % (maxValue + 1)</span><br><span class="hljs-comment">//更偏向于 数值差异 的分布，而非均匀的单一随机数</span><br></code></pre></td></tr></table></figure><p>递归行为和递归行为的时间复杂度</p><p>注意mid&#x3D;(L+R)&#x2F;2可能会溢出，应该写成mid&#x3D;L+(R-L)&#x2F;2或者mid&#x3D;L+(R-L)&gt;&gt;1（右移一位就等同于除二）</p><p>master公式：（子问题规模等量）</p><p><img src="/images/2025-02-15-1.png" alt="1"></p><p><img src="/images/2025-02-15-2.png" alt="2"></p><h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> R)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = R - L + <span class="hljs-number">1</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">copy</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-type">int</span> i = L;<br>    <span class="hljs-type">int</span> j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= R) &#123;<br>        copy[k++] = arr[i] &lt;= arr[j] ? arr[i++] : arr[j++];<span class="hljs-comment">//这段代码很精髓</span><br>    &#125;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;<br>        copy[k++] = arr[i++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (j &lt;= R) &#123;<br>        copy[k++] = arr[j++];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p = <span class="hljs-number">0</span>; p &lt; n; ++p) &#123;<br>        arr[L + p] = copy[p];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (L == R) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = L + ((R - L) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">process</span>(arr, L, mid);<br>    <span class="hljs-built_in">process</span>(arr, mid + <span class="hljs-number">1</span>, R);<br>    <span class="hljs-built_in">merge</span>(arr, L, mid, R);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (arr.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">process</span>(arr, <span class="hljs-number">0</span>, arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">//时间复杂度O(nlogn),空间复杂度O(n)</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 使用 std::merge 合并两个已排序的数组</span><br>std::<span class="hljs-built_in">merge</span>(vec<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), vec<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>(), vec<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(), vec<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>(), result.<span class="hljs-built_in">begin</span>());<br><span class="hljs-comment">//注意begin是第一个元素，end是最后一个元素的后一个</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (L == R) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = L + ((R - L) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">process</span>(arr, L, mid);<br>    <span class="hljs-built_in">process</span>(arr, mid + <span class="hljs-number">1</span>, R);<br><br>    <span class="hljs-type">int</span> n = R - L + <span class="hljs-number">1</span>;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(n)</span></span>;<br>    <br>    <span class="hljs-comment">// 使用 std::merge 合并两个已排序的区间</span><br>    std::<span class="hljs-built_in">merge</span>(arr.<span class="hljs-built_in">begin</span>() + L, arr.<span class="hljs-built_in">begin</span>() + mid + <span class="hljs-number">1</span>, arr.<span class="hljs-built_in">begin</span>() + mid + <span class="hljs-number">1</span>, arr.<span class="hljs-built_in">begin</span>() + R + <span class="hljs-number">1</span>, temp.<span class="hljs-built_in">begin</span>());<br>   <br>    <span class="hljs-comment">// 将合并后的结果复制回原数组</span><br>    std::<span class="hljs-built_in">copy</span>(temp.<span class="hljs-built_in">begin</span>(), temp.<span class="hljs-built_in">end</span>(), arr.<span class="hljs-built_in">begin</span>() + L);<br>&#125;<br></code></pre></td></tr></table></figure><p>归并排序为什么复杂度到了O(nlogn)</p><p>比如选择排序，大量的浪费了比较行为，而归并排序的比较行为没有被浪费，而是将其保留到了一个有序的部分，下一次再次进行归并的时候利用到以前进行比较的信息，避免了过多的无效比较</p><h5 id="小和问题"><a href="#小和问题" class="headerlink" title="小和问题"></a>小和问题</h5><p>在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和，求一个数组的小和</p><p>分析：分析数组中每一个数字会产生几个小和，也就是求一个数右边有几个数比它大</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">merge2</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> R)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = L;<br>    <span class="hljs-type">int</span> j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> n = R - L + <span class="hljs-number">1</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">copy</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= R) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] &lt; arr[j]) &#123;<br>            sum += arr[i] * (R - j + <span class="hljs-number">1</span>);<br>            copy[k++] = arr[i++];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            copy[k++] = arr[j++];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;<br>        copy[k++] = arr[i++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (j &lt;= R) &#123;<br>        copy[k++] = arr[j++];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p = <span class="hljs-number">0</span>; p &lt; n; ++p) &#123;<br>        arr[L + p] = copy[p];<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">process2</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (L == R) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = L + ((R - L) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> one = <span class="hljs-built_in">process2</span>(arr, L, mid);<br>    <span class="hljs-type">int</span> two = <span class="hljs-built_in">process2</span>(arr, mid + <span class="hljs-number">1</span>, R);<br>    <span class="hljs-keyword">return</span> one + two + <span class="hljs-built_in">merge2</span>(arr, L, mid, R);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">smallsum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (arr.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">process2</span>(arr, <span class="hljs-number">0</span>, arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="逆序对数量"><a href="#逆序对数量" class="headerlink" title="逆序对数量"></a>逆序对数量</h5><p>也就是求右边有多少个数比左边小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mergeAndCount</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> R)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = L, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> n = R - L + <span class="hljs-number">1</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(n)</span></span>;<br><br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= R) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] &lt;= arr[j]) &#123;<br>            temp[k++] = arr[i++];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 右边的元素小于左边的元素</span><br>            temp[k++] = arr[j++];<br>            count += (mid - i + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 统计逆序对的数量</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 复制剩余部分</span><br>    <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;<br>        temp[k++] = arr[i++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (j &lt;= R) &#123;<br>        temp[k++] = arr[j++];<br>    &#125;<br>    <span class="hljs-comment">// 将合并后的结果复制回原数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p = <span class="hljs-number">0</span>; p &lt; n; ++p) &#123;<br>        arr[L + p] = temp[p];<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="荷兰国旗"><a href="#荷兰国旗" class="headerlink" title="荷兰国旗"></a>荷兰国旗</h5><p>先定一个小于区域的右边界，和大于区域的左边界于是形成下面的结构</p><p>《《《&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;待定。。。》》》</p><p>​          p             i                q</p><p>小于区域右边界指针p，大于区域左边界指针q，遍历指针i（同时也是等于区域右边界）</p><p>当遍历指针碰到等于的时候直接往右走扩充等于区域</p><p>当小于的时候与小于区域后边一个交换，小于区域扩充，交换过来的也是等于，也扩充等于区域</p><p>当大于的时候与右边界左边一个交换，扩充大于区域，换过来的待定，i不变，继续判定待定的那个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dutchNationalFlag</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> pivot)</span> </span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 小于区域的右边界</span><br>    <span class="hljs-type">int</span> q = arr.<span class="hljs-built_in">size</span>();  <span class="hljs-comment">// 大于区域的左边界</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 遍历指针</span><br>    <span class="hljs-comment">// 遍历数组直到i与q相遇</span><br>    <span class="hljs-keyword">while</span> (i &lt; q) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] &lt; pivot) &#123;<br>            <span class="hljs-comment">// 小于区域，交换arr[i]和arr[p+1]，并扩大小于区域</span><br>            <span class="hljs-built_in">swap</span>(arr[i++], arr[++p]);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[i] == pivot) &#123;<br>            <span class="hljs-comment">// 等于区域，直接移动i</span><br>            i++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 大于区域，交换arr[i]和arr[q-1]，并缩小大于区域</span><br>            <span class="hljs-built_in">swap</span>(arr[i], arr[--q]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><p>划分值打到中点的情况是最好情况，如果划分值一直打到最左或者最右就是O(n2)的算法</p><p>如果随机这个划分值那么就是O(nlogn)的算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>&#123;<br>    <span class="hljs-type">int</span> p = L - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> q = R;<br>    <span class="hljs-type">int</span> i = L;<br>    <span class="hljs-keyword">while</span> (i &lt; q) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] == arr[R]) &#123;<br>            i++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[i] &lt; arr[R]) &#123;<br>            <span class="hljs-built_in">swap</span>(arr[++p], arr[i++]);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">swap</span>(arr[i], arr[--q]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">swap</span>(arr[R], arr[q]);<br>    <span class="hljs-keyword">return</span> &#123;p + <span class="hljs-number">1</span>, q&#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (L &lt; R) &#123;<br>        <span class="hljs-type">int</span> random = <span class="hljs-built_in">rand</span>() % (R - L + <span class="hljs-number">1</span>) + L;<br>        <span class="hljs-built_in">swap</span>(arr[R], arr[random]);<br>        vector&lt;<span class="hljs-type">int</span>&gt; equal = <span class="hljs-built_in">partition</span>(arr, L, R);<br>        <span class="hljs-built_in">quickSort</span>(arr, L, equal[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">quickSort</span>(arr, equal[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, R);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort3</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (arr.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">quickSort</span>(arr, <span class="hljs-number">0</span>, arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">//时间复杂度O(nlogn),空间复杂度O(logn)</span><br></code></pre></td></tr></table></figure><h5 id="堆结构"><a href="#堆结构" class="headerlink" title="堆结构"></a>堆结构</h5><p>堆是一个完全二叉数（从左往右依次遍满），可以把数组看成一个二叉树</p><p>i位置的左孩子  2*i+1</p><p>i位置的右孩子  2*i+2</p><p>i位置的父亲   （i-1)&#x2F;2</p><p>大根堆：堆的每一棵子树的最大值都是根节点   小根堆则相反</p><p>堆结构单次扩容代价是O(nlogn&#x2F;n), 就是logn水平</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapInsert</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (arr[index] &gt; arr[(index - <span class="hljs-number">1</span>) /<span class="hljs-number">2</span>]) &#123;<br>        <span class="hljs-built_in">swap</span>(arr[index],arr[(index - <span class="hljs-number">1</span>) /<span class="hljs-number">2</span>]);<br>        index = (index<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// cout &lt;&lt;(0-1)/2&lt;&lt;endl;      0</span><br><span class="hljs-comment">// cout &lt;&lt;((0-1)&gt;&gt;1)&lt;&lt;endl;   -1</span><br><span class="hljs-comment">//时间复杂度 O(logn)</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> heapsize, <span class="hljs-type">int</span> index)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; heapsize) &#123;<br>        <span class="hljs-type">int</span> largest = left + <span class="hljs-number">1</span> &lt; heapsize &amp;&amp; arr[left + <span class="hljs-number">1</span>] &gt; arr[left] ? left + <span class="hljs-number">1</span> : left;<br>        largest = arr[largest] &gt; arr[index] ? largest : index;<br>        <span class="hljs-keyword">if</span> (largest == index) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(arr[largest], arr[index]);<br>        index = largest;<br>        left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//时间复杂度 O(logn)</span><br></code></pre></td></tr></table></figure><p>当有一个i位置的值变了，只要先进行heapInsert（变大），再进行heapify就行（变小）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (arr.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-built_in">heapInsert</span>(arr, i);<br>    &#125;<br>    <br>    <span class="hljs-comment">//for(int i = n - 1;i &gt;= 0;i--)&#123;</span><br>    <span class="hljs-comment">//    heapify(arr, n, i);</span><br>    <span class="hljs-comment">//&#125;</span><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n - <span class="hljs-number">1</span>; j &gt; <span class="hljs-number">0</span>; --j) &#123;<br>        <span class="hljs-built_in">swap</span>(arr[<span class="hljs-number">0</span>], arr[j]);<br>        <span class="hljs-built_in">heapify</span>(arr, j, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//时间复杂度 O(nlogn) 空间复杂度 O(l)</span><br><span class="hljs-comment">//构建大根堆时，当已经有一个数组时，可以从最后一个开始进行heapify，这样的时间复杂度是O(n)</span><br><br><span class="hljs-comment">//小根堆使用 &gt; 号是因为：</span><br><span class="hljs-comment">//a &gt; b 时，需要让 a 排在 b 之后，以维持最小堆的结构（根节点最小）。</span><br></code></pre></td></tr></table></figure><h5 id="堆排序扩展题目"><a href="#堆排序扩展题目" class="headerlink" title="堆排序扩展题目"></a>堆排序扩展题目</h5><p>已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapexap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    priority_queue&lt;<span class="hljs-type">int</span>&gt; heap;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (; i &lt; <span class="hljs-built_in">min</span>(k, n); ++i) &#123;<br>        heap.<span class="hljs-built_in">push</span>(arr[i]);<br>    &#125;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (; i &lt; n; ++i) &#123;<br>        heap.<span class="hljs-built_in">push</span>(arr[i]);<br>        arr[j++] = heap.<span class="hljs-built_in">top</span>();<br>        heap.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!heap.<span class="hljs-built_in">empty</span>()) &#123;<br>        arr[j++] = heap.<span class="hljs-built_in">top</span>();<br>        heap.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//模版库不提供对某一位置的修改</span><br></code></pre></td></tr></table></figure><h5 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    string name;<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">int</span> ege;<br>    <span class="hljs-comment">// 带参数的构造函数</span><br>    <span class="hljs-built_in">Student</span>(string n, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> e) : <span class="hljs-built_in">name</span>(n), <span class="hljs-built_in">id</span>(i), <span class="hljs-built_in">ege</span>(e) &#123;&#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Student&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> id &lt; other.id;  <span class="hljs-comment">// 按 id 排序</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CompareById</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Student&amp; a, <span class="hljs-type">const</span> Student&amp; b)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a.id &lt; b.id;  <span class="hljs-comment">// 按照 id 从小到大排序</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// sort(students.begin(), students.end(), CompareById());</span><br><br><span class="hljs-comment">// sort(students.begin(), students.end(), [](const Student&amp; a, const Student&amp; b) &#123;</span><br><span class="hljs-comment">//         return a.id &lt; b.id;  // 按照 id 从小到大排序</span><br><span class="hljs-comment">//     &#125;);</span><br></code></pre></td></tr></table></figure><h5 id="不基于比较的排序"><a href="#不基于比较的排序" class="headerlink" title="不基于比较的排序"></a>不基于比较的排序</h5><p>计数排序（词频统计）</p><h5 id="基数排序（桶排序）"><a href="#基数排序（桶排序）" class="headerlink" title="基数排序（桶排序）"></a>基数排序（桶排序）</h5><p>通过统计词频表，再计算前缀和的方式，直接得到将该位排序后的位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getdigit</span><span class="hljs-params">(<span class="hljs-type">int</span> num, <span class="hljs-type">int</span> d)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (num / (<span class="hljs-type">int</span>)(<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, d - <span class="hljs-number">1</span>))) % <span class="hljs-number">10</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">radixSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R, <span class="hljs-type">int</span> digit)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = R - L + <span class="hljs-number">1</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">help</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= digit; ++k) &#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = L; i &lt;= R; ++i) &#123;<br>            <span class="hljs-type">int</span> index = <span class="hljs-built_in">getdigit</span>(arr[i], k);<br>            count[index]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>            count[i] = count[i] + count[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-comment">//这里从后往前确保稳定性</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = R; i &gt;= L; --i) &#123;<br>            <span class="hljs-type">int</span> index = <span class="hljs-built_in">getdigit</span>(arr[i], k);<br>            help[--count[index]] = arr[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            arr[i + L] = help[i];<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxbits</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> maxnum = INT_MIN;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        maxnum = <span class="hljs-built_in">max</span>(maxnum, arr[i]);<br>    &#125;<br>    <span class="hljs-type">int</span> digit = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (maxnum != <span class="hljs-number">0</span>) &#123;<br>        maxnum /= <span class="hljs-number">10</span>;<br>        digit++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> digit;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">radixSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (arr.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">radixSort</span>(arr, <span class="hljs-number">0</span>, arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, <span class="hljs-built_in">maxbits</span>(arr));<br>&#125;<br><span class="hljs-comment">//时间复杂度 O(n) 空间复杂度O(radix)</span><br></code></pre></td></tr></table></figure><h5 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a>排序算法总结</h5><table><thead><tr><th>排序</th><th>时间复杂度</th><th>空间复杂度</th><th>稳定性</th><th>描述</th></tr></thead><tbody><tr><td>选择排序</td><td>n2</td><td>1</td><td>否</td><td></td></tr><tr><td>冒泡排序</td><td>n2</td><td>1</td><td>是</td><td></td></tr><tr><td>插入排序</td><td>n2</td><td>1</td><td>是</td><td></td></tr><tr><td>归并排序</td><td>nlogn</td><td>n</td><td>是</td><td>需要用到稳定性</td></tr><tr><td>快速排序</td><td>nlogn</td><td>logn</td><td>是</td><td>常数项最低，最快</td></tr><tr><td>堆排序</td><td>nlogn</td><td>1</td><td>否</td><td>有空间限制选择</td></tr><tr><td>基数排序和计数排序</td><td>n</td><td>桶的数量</td><td>否</td><td></td></tr></tbody></table><p>1.基于比较的排序目前没有nlogn以下的时间复杂度</p><p>2.时间nlogn, 空间n以下，且具有稳定性，没有</p><p>3.工程上对排序的使用：</p><p>​当样本量较小的时候（如小于60），可以直接用插入排序，插入排序更快（常数项低）</p><p>​当需要利用到稳定性，就用归并排序</p><p>​如当对基础类型进行排序就用快排，当对自定义排序就用归并排序</p><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>链表换头需要有返回值</p><p>链表笔试：不在乎空间复杂度，一切为了时间复杂度</p><p>链表面试：时间复杂度第一位，但一定要找到空间复杂度最省的方法</p><p>重要技巧：</p><p>1.数据结构（如哈希表，栈）</p><p>2.快慢指针</p><p>3.多开几个链表头</p><p>4.申请一个空节点作为链表头</p><h5 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h5><p>笔试：放进栈里面，栈弹出式逆序的顺序</p><p>面试：先用快满指针找出链表的中间节点，然后从中间节点开始到最后将链表反转，然后分别从两个头结点进行遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Node *<span class="hljs-title">findMidNode</span><span class="hljs-params">(Node *head)</span> </span>&#123;<br>    Node *fast = head;<br>    Node *slow = head;<br>    <span class="hljs-keyword">while</span> (fast-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow-&gt;next;<br>&#125;<br><span class="hljs-function">Node *<span class="hljs-title">reverselist</span><span class="hljs-params">(Node *head)</span> </span>&#123;<br>    Node *pre = <span class="hljs-literal">nullptr</span>;<br>    Node *cur = head;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>        Node *next = cur-&gt;next;<br>        cur-&gt;next = pre;<br>        pre = cur;<br>        cur = next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judgeList</span><span class="hljs-params">(Node *head)</span> </span>&#123;<br>    Node *mid = <span class="hljs-built_in">findMidNode</span>(head);<br>    Node *tail = <span class="hljs-built_in">reverselist</span>(mid);<br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">nullptr</span> &amp;&amp; tail != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">if</span> (head-&gt;value != tail-&gt;value) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        head = head-&gt;next;<br>        tail = tail-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="单链表荷兰国旗问题"><a href="#单链表荷兰国旗问题" class="headerlink" title="单链表荷兰国旗问题"></a>单链表荷兰国旗问题</h5><p>笔试：申请一个node类型的数组，将链表放入数组，在数组中进行操作，再将其串成链表</p><p>面试：申请6个头尾节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Node *<span class="hljs-title">partitionList</span><span class="hljs-params">(Node *head, <span class="hljs-type">int</span> num)</span> </span>&#123;<br>    Node *lessHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">0</span>);<br>    Node *lessTail = lessHead;<br>    Node *equalHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">0</span>);<br>    Node *equalTail = equalHead;<br>    Node *moreHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">0</span>);<br>    Node *moreTail = moreHead;<br><br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">if</span> (head-&gt;value &lt; num) &#123;<br>            lessTail-&gt;next = head;<br>            lessTail = lessTail-&gt;next;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (head-&gt;value == num) &#123;<br>            equalTail-&gt;next = head;<br>            equalTail = equalTail-&gt;next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            moreTail-&gt;next = head;<br>            moreTail = moreTail-&gt;next;<br>        &#125;<br>        head = head-&gt;next;<br>    &#125;<br>    moreTail-&gt;next = <span class="hljs-literal">nullptr</span>;<br>    lessTail-&gt;next = equalHead-&gt;next;<br>    equalTail-&gt;next = moreHead-&gt;next;<br><br>    <span class="hljs-keyword">return</span> lessHead-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="复制含有随机指针节点的链表"><a href="#复制含有随机指针节点的链表" class="headerlink" title="复制含有随机指针节点的链表"></a>复制含有随机指针节点的链表</h5><p>笔试：用一个hash表设置原链表节点对应新链表的节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>    unordered_map&lt;Node*, Node*&gt; mp;<br>    Node* cur = head;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>        mp[cur] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(cur-&gt;val);<br>        cur = cur-&gt;next;<br>    &#125;<br><br>    Node* cur1 = head;<br>    <span class="hljs-keyword">while</span> (cur1 != <span class="hljs-literal">nullptr</span>) &#123;<br>        mp[cur1]-&gt;next = mp[cur1-&gt;next];<br>        mp[cur1]-&gt;random = mp[cur1-&gt;random];<br>        cur1 = cur1-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> mp[head];<br>&#125;<br></code></pre></td></tr></table></figure><p>面试：在原链表节点后面复制一个新链表的节点串起来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-comment">// 第一步：创建新节点并插入到每个原节点之后</span><br>    Node* cur1 = head;<br>    <span class="hljs-keyword">while</span> (cur1 != <span class="hljs-literal">nullptr</span>) &#123;<br>        Node* next = cur1-&gt;next;<br>        cur1-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(cur1-&gt;val);<br>        cur1-&gt;next-&gt;next = next;<br>        cur1 = next;<br>    &#125;<br><br>    <span class="hljs-comment">// 第二步：设置新节点的 random 指针</span><br>    Node* cur2 = head;<br>    <span class="hljs-keyword">while</span> (cur2 != <span class="hljs-literal">nullptr</span>) &#123;<br>        cur2-&gt;next-&gt;random = cur2-&gt;random ? cur2-&gt;random-&gt;next : <span class="hljs-literal">nullptr</span>;<br>        cur2 = cur2-&gt;next-&gt;next;<br>    &#125;<br><br>    <span class="hljs-comment">// 第三步：分离新链表与原链表</span><br>    Node* res = head-&gt;next;<br>    Node* cur3 = res;<br>    Node* cur4 = head;<br>    <span class="hljs-keyword">while</span> (cur4 != <span class="hljs-literal">nullptr</span>) &#123;<br>        cur4-&gt;next = cur4-&gt;next-&gt;next;          <span class="hljs-comment">// 恢复原链表的 next 指针</span><br>        cur3-&gt;next = cur3-&gt;next ? cur3-&gt;next-&gt;next : <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 更新新链表的 next 指针</span><br>        cur4 = cur4-&gt;next;<br>        cur3 = cur3-&gt;next;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="两个单链表相交"><a href="#两个单链表相交" class="headerlink" title="两个单链表相交"></a>两个单链表相交</h5><p>给定连个可能有环也可能无环的单链表，头节点head1和head2，请实现一个函数，如果两个链表相交，返回相交的第一个节点，如果不想交，返回null</p><p>笔试：用unordeded_set将list1每个node放入，遍历list2看是否有相交节点</p><p>面试：判断是否有环，分情况讨论</p><p><strong>判断链表是否有环</strong></p><p>笔试：用unordeded_set将每个node放入</p><p>面试：快慢指针，当快慢指针相遇后，快指针指向头，慢指针不动，快慢指针依次走一步，快指针慢指针再次相遇在第一个入环节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//如何判断一个链表是否有环</span><br><span class="hljs-function">Node *<span class="hljs-title">detectCycle</span><span class="hljs-params">(Node *head)</span> </span>&#123;<br>    Node *slow = head;<br>    Node *fast = head;<br>    <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;<br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next-&gt;next;<br>        <span class="hljs-keyword">if</span> (slow == fast) &#123;<br>            fast = head;<br>            <span class="hljs-keyword">while</span> (fast != slow) &#123;<br>                fast = fast-&gt;next;<br>                slow = slow-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">return</span> slow;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>情况1：两个链表都无环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//两个无环链表相交</span><br><span class="hljs-function">Node *<span class="hljs-title">f1</span><span class="hljs-params">(Node *head1, Node *head2)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len1 = <span class="hljs-number">1</span>;<br>    Node *cur1 = head1;<br>    <span class="hljs-keyword">while</span> (cur1-&gt;next) &#123;<br>        cur1 = cur1-&gt;next;<br>        len1++;<br>    &#125;<br><br>    <span class="hljs-type">int</span> len2 = <span class="hljs-number">1</span>;<br>    Node *cur2 = head2;<br>    <span class="hljs-keyword">while</span> (cur2-&gt;next) &#123;<br>        cur2 = cur2-&gt;next;<br>        len2++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cur1 != cur2) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">abs</span>(len1 - len2);<br>    Node *cur3, *cur4;<br>    <span class="hljs-keyword">if</span> (len1 == len2) &#123;<br>        <span class="hljs-keyword">return</span> cur1;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len1 &gt; len2) &#123;<br>        cur3 = head1;<br>        cur4 = head2;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cur3 = head2;<br>        cur4 = head1;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (len--) &#123;<br>        cur3 = cur3-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (cur3 != cur4) &#123;<br>        cur3 = cur3-&gt;next;<br>        cur4 = cur4-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cur3;<br>&#125;<br></code></pre></td></tr></table></figure><p>情况2：一个有环，一个无环</p><p>不可能相交</p><p>情况3：两个都有环</p><p>可不在环上相遇：无环链表相交问题</p><p>也可在环上相遇：loop1继续往下走遇到loop2能遇到loop2那么就相交（loop1或loop2)</p><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><h5 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>    <span class="hljs-comment">//1</span><br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//在这里看一下就是先序</span><br>    <span class="hljs-comment">//1</span><br>    <span class="hljs-built_in">f</span>(head-&gt;left);<br>    <span class="hljs-comment">//2</span><br>    <span class="hljs-comment">//在这里看一下就是中序</span><br>    <span class="hljs-comment">//2</span><br>    <span class="hljs-built_in">f</span>(head-&gt;right);<br>    <span class="hljs-comment">//3</span><br>    <span class="hljs-comment">//在这里看一下就是后序</span><br>    <span class="hljs-comment">//3</span><br>&#125;<br><span class="hljs-comment">//一共会三次到自己</span><br></code></pre></td></tr></table></figure><p>​                   1</p><p>​           2               3</p><p>​     4        5       6       7</p><p> 。  。  。 。 。 。。  。</p><p>递归序就是1,2,4,4,4,2,5,5,5,2,1,3,6,6,6,3,7,7,7,3,1</p><p>先序：先看根节点，再左节点，再右节点（第一次到一个节点看）</p><p>1,2,4,5,3,6,7</p><p>中序：先看左节点，再根节点，在右节点（第二次到一个节点看）</p><p>4,2,5,1,6,3,7</p><p>后序：先看左节点，再右节点，在根节点（第二次到一个节点看）</p><p>4,5,2,6,7,3,1</p><h5 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h5><p><strong>先序遍历</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(Node *head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    stack&lt;Node *&gt; st;<br>    st.<span class="hljs-built_in">push</span>(head);<br>    <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>        Node *now = st.<span class="hljs-built_in">top</span>();<br>        cout &lt;&lt; now-&gt;value &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>;<br>        st.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (now-&gt;right != <span class="hljs-literal">nullptr</span>) &#123;<br>            st.<span class="hljs-built_in">push</span>(now-&gt;right);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (now-&gt;left != <span class="hljs-literal">nullptr</span>) &#123;<br>            st.<span class="hljs-built_in">push</span>(now-&gt;left);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//注意是先右后左，出来就是先左后右</span><br></code></pre></td></tr></table></figure><p><strong>后序遍历</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">midOrder</span><span class="hljs-params">(Node *head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    stack&lt;Node *&gt; st1;<br>    stack&lt;Node *&gt; st2;<br>    st<span class="hljs-number">1.</span><span class="hljs-built_in">push</span>(head);<br>    <span class="hljs-keyword">while</span> (!st<span class="hljs-number">1.</span><span class="hljs-built_in">empty</span>()) &#123;<br>        Node *now = st<span class="hljs-number">1.</span><span class="hljs-built_in">top</span>();<br>        st<span class="hljs-number">2.</span><span class="hljs-built_in">push</span>(now);<br>        st<span class="hljs-number">1.</span><span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(now-&gt;left!=<span class="hljs-literal">nullptr</span>) &#123;<br>            st<span class="hljs-number">1.</span><span class="hljs-built_in">push</span>(now-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(now-&gt;right!=<span class="hljs-literal">nullptr</span>) &#123;<br>            st<span class="hljs-number">1.</span><span class="hljs-built_in">push</span>(now-&gt;right);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!st<span class="hljs-number">2.</span><span class="hljs-built_in">empty</span>()) &#123;<br>        Node* now = st<span class="hljs-number">2.</span><span class="hljs-built_in">top</span>();<br>        st<span class="hljs-number">2.</span><span class="hljs-built_in">pop</span>();<br>        cout &lt;&lt;now-&gt;value&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//头右左-&gt;左右头</span><br></code></pre></td></tr></table></figure><p><strong>中序遍历</strong></p><p>每棵子树整个左边界进栈，依次弹出过程中打印，对弹出节点的右树周而复始</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">midOrder</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    stack&lt;Node*&gt; st;<br>    Node* node = head;<br><br>    <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span> || !st.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-comment">// 将整个左边界的节点进栈</span><br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>            st.<span class="hljs-built_in">push</span>(node);<br>            node = node-&gt;left;<br>        &#125;<br>        <span class="hljs-comment">// 弹出栈顶节点并访问</span><br>        node = st.<span class="hljs-built_in">top</span>();<br>        st.<span class="hljs-built_in">pop</span>();<br>        cout &lt;&lt; node-&gt;value &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>;<br>        <span class="hljs-comment">// 处理右子树</span><br>        node = node-&gt;right;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//如果我们只依赖 !st.empty()，那样我们会错过处理右子树的机会，因为一旦我们到达左子树的底部（node == nullptr），我们就无法确保还会访问右子树。加上 node != nullptr 的条件，我们能在进入栈之前继续将左子树的节点压栈，直到遍历完整个左边界。</span><br>比如当上面的二叉树访问到了<span class="hljs-number">1</span>后，栈就空了，但是node不为空，所以需要继续<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">midOrder</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">nullptr</span> || !st.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-comment">// 将整个左边界的节点进栈</span><br>        <span class="hljs-keyword">if</span> (head != <span class="hljs-literal">nullptr</span>) &#123;<br>            st.<span class="hljs-built_in">push</span>(head);<br>            head = head-&gt;left;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 弹出栈顶节点并访问</span><br>        head = st.<span class="hljs-built_in">top</span>();<br>        st.<span class="hljs-built_in">pop</span>();<br>        cout &lt;&lt; head-&gt;value &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>;<br>        <span class="hljs-comment">// 处理右子树</span><br>        node = head-&gt;right;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//需要加上else，确保当左边界进完了之后再对右子树进行操作</span><br><span class="hljs-comment">//头左进栈，然后左头出栈后处理右，就是左头右</span><br></code></pre></td></tr></table></figure><h5 id="广度优先遍历（宽度优先遍历）"><a href="#广度优先遍历（宽度优先遍历）" class="headerlink" title="广度优先遍历（宽度优先遍历）"></a>广度优先遍历（宽度优先遍历）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wideOrder</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    queue&lt;Node*&gt; q;<br>    q.<span class="hljs-built_in">push</span>(head);<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        Node* node = q.<span class="hljs-built_in">front</span>();<br>        cout &lt;&lt;node-&gt;value&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>;<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(node-&gt;left!=<span class="hljs-literal">nullptr</span>) &#123;<br>            q.<span class="hljs-built_in">push</span>(node-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node-&gt;right!=<span class="hljs-literal">nullptr</span>) &#123;<br>            q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="二叉树的最大宽度"><a href="#二叉树的最大宽度" class="headerlink" title="二叉树的最大宽度"></a><strong>二叉树的最大宽度</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxwide</span><span class="hljs-params">(Node *head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    queue&lt;Node *&gt; q;<br>    q.<span class="hljs-built_in">push</span>(head);<br>    unordered_map&lt;Node *, <span class="hljs-type">int</span>&gt; levelMap;<br>    levelMap.<span class="hljs-built_in">insert</span>(&#123;head, <span class="hljs-number">1</span>&#125;);<br>    <span class="hljs-type">int</span> curlevel = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> curlevelnodes = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> maxnode = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        Node *node = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> curnodelevel = levelMap[node];<br>        <span class="hljs-keyword">if</span> (curlevel == curnodelevel) &#123;<br>            curlevelnodes++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            maxnode = <span class="hljs-built_in">max</span>(maxnode,curlevelnodes);<br>            curlevel++;<br>            curlevelnodes = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">nullptr</span>) &#123;<br>            levelMap.<span class="hljs-built_in">insert</span>(&#123;node-&gt;left,curlevel<span class="hljs-number">+1</span>&#125;);<br>            q.<span class="hljs-built_in">push</span>(node-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (node-&gt;right != <span class="hljs-literal">nullptr</span>) &#123;<br>            levelMap.<span class="hljs-built_in">insert</span>(&#123;node-&gt;right,curlevel<span class="hljs-number">+1</span>&#125;);<br>            q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxnode;<br>&#125;<br><span class="hljs-comment">//用一个hash表记录每个节点所在层数</span><br><span class="hljs-comment">//不用hash，可以通过设置curend,nextend，两个变量来求解</span><br></code></pre></td></tr></table></figure><h5 id="二叉树的递归套路（树型DP"><a href="#二叉树的递归套路（树型DP" class="headerlink" title="二叉树的递归套路（树型DP)"></a>二叉树的递归套路（树型DP)</h5><p>当前节点可以从左子树和右子树要信息，通过这些信息构建一个结构体，利用这个结构体来判断</p><h5 id="搜索二叉树（BST"><a href="#搜索二叉树（BST" class="headerlink" title="搜索二叉树（BST)"></a>搜索二叉树（BST)</h5><p>对每一棵子树来说，他的左树的节点都比他小，右树的节点都比他大</p><p>中序遍历升序</p><h5 id="完全二叉树（CBT"><a href="#完全二叉树（CBT" class="headerlink" title="完全二叉树（CBT)"></a>完全二叉树（CBT)</h5><p>堆，从左到右依次遍满</p><p>宽度优先遍历</p><p>1.如果有右孩子，没有左孩子，false</p><p>2.如果遇到第一个左右孩子不双全的情况，那么接下来所有节点都需要是叶节点</p><h5 id="满二叉树（FBT"><a href="#满二叉树（FBT" class="headerlink" title="满二叉树（FBT)"></a>满二叉树（FBT)</h5><p>节点个数(n)和深度(l)满足：n&#x3D;2l-1</p><h5 id="平衡二叉树（AVL"><a href="#平衡二叉树（AVL" class="headerlink" title="平衡二叉树（AVL)"></a>平衡二叉树（AVL)</h5><p>每一棵子树，左子树和右子树的高度差不超过1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReturnType</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> height;<br>    <span class="hljs-type">bool</span> isBalanced;<br>    <span class="hljs-built_in">ReturnType</span>(<span class="hljs-type">bool</span> isBalanced,<span class="hljs-type">int</span> height) :<span class="hljs-built_in">isBalanced</span>(isBalanced),<span class="hljs-built_in">height</span>(height)&#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function">ReturnType* <span class="hljs-title">isAVL</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ReturnType</span>(<span class="hljs-literal">true</span>,<span class="hljs-number">0</span>);<br>    &#125;<br>    ReturnType* leftreturn = <span class="hljs-built_in">isAVL</span>(head-&gt;left);<br>    ReturnType* rightreturn = <span class="hljs-built_in">isAVL</span>(head-&gt;right);<br><br>    <span class="hljs-type">int</span> cha = <span class="hljs-built_in">abs</span>(leftreturn-&gt;height-rightreturn-&gt;height);<br>    <span class="hljs-type">bool</span> isBalanced = leftreturn-&gt;isBalanced==<span class="hljs-literal">true</span>&amp;&amp;rightreturn-&gt;isBalanced==<span class="hljs-literal">true</span>&amp;&amp;(cha&lt;=<span class="hljs-number">1</span>); <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ReturnType</span>(isBalanced,<span class="hljs-built_in">max</span>(leftreturn-&gt;height,rightreturn-&gt;height));<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="最低公共祖先"><a href="#最低公共祖先" class="headerlink" title="最低公共祖先"></a>最低公共祖先</h5><p>1.用hash表，建立每个节点的父节点，然后将n1往上的每一个节点放入set，然后n2往上遍历</p><p>2.递归遍历，一次解决</p><p>情况：1.n1,n2互为公共祖先 2.n1,n2不互为公共祖先</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Node *<span class="hljs-title">lowestAncestor</span><span class="hljs-params">(Node *head, Node *n1, Node *n2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span> || head == n1 || head == n2) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    Node *left = <span class="hljs-built_in">lowestAncestor</span>(head-&gt;left, n1, n2);<br>    Node *right = <span class="hljs-built_in">lowestAncestor</span>(head-&gt;right, n1, n2);<br>    <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">nullptr</span> &amp;&amp; right != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left != <span class="hljs-literal">nullptr</span> ? left : right;<br>&#125;<br><span class="hljs-comment">//当一颗子树左右子树没有n1,n2时返回空</span><br><span class="hljs-comment">//当一颗子树左右子树仅有一个n1或n2时，返回n1或n2</span><br><span class="hljs-comment">//当一颗子树左右子树同时有n1,n1时，先碰到的那个节点会直接返回，此时另一边不可能再有不空的返回值了，于是祖先节点就是该节点</span><br><span class="hljs-comment">//当一颗子树左右子树各有一个n1,n2时，返回当前节点</span><br><span class="hljs-comment">//当已经返回了一个祖先节点后，后面的祖先不可能返回，因为其另一颗子树一定返回空</span><br></code></pre></td></tr></table></figure><h5 id="后继节点，前驱节点"><a href="#后继节点，前驱节点" class="headerlink" title="后继节点，前驱节点"></a>后继节点，前驱节点</h5><p>中序遍历的后一个节点，前一个节点</p><p>如果给出二叉树的父节点指针，怎么在O(K)的时间复杂度找出后继节点</p><p>1.如果x有右树，那么x右树的最左节点就是后继</p><p>2.如果x没有右树，那么x往上找，当一个节点是某一个节点的左节点的时候，那么这就是他的后继节点，左子树的最右节点就是某个节点的前驱节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Node *<span class="hljs-title">getSuccessorNode</span><span class="hljs-params">(Node *node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (node-&gt;right != <span class="hljs-literal">nullptr</span>) &#123;<br>        node = node-&gt;right;<br>        <span class="hljs-keyword">while</span> (node-&gt;left!=<span class="hljs-literal">nullptr</span>) &#123;<br>            node = node-&gt;left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        Node *parent = node-&gt;parent;<br>        <span class="hljs-comment">//注意最后一个节点没有后继</span><br>        <span class="hljs-keyword">while</span> (parent!=<span class="hljs-literal">nullptr</span>||parent-&gt;right==node) &#123;<br>            node = parent;<br>            parent = node-&gt;parent;<br>        &#125;<br>        <span class="hljs-keyword">return</span> parent;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="二叉树的序列化和反序列化"><a href="#二叉树的序列化和反序列化" class="headerlink" title="二叉树的序列化和反序列化"></a>二叉树的序列化和反序列化</h5><p>一个字符串一一对应一种二叉树</p><p>序列化，遍历，需要两个符号记录值的结束和空指针</p><p>反序列化，用一个队列存值，并递归消费这个队列</p><h5 id="折纸问题"><a href="#折纸问题" class="headerlink" title="折纸问题"></a>折纸问题</h5><p>给一个参数n，打印折痕的方向</p><p>​                 1凹</p><p>​           2凹         2凸</p><p>   3凹     3凸   3凹    3凸</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printProcess</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> N,<span class="hljs-type">bool</span> print)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(i&gt;N) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">printProcess</span>(i<span class="hljs-number">+1</span>,N,<span class="hljs-literal">true</span>);<br>    cout &lt;&lt;(print?<span class="hljs-string">&quot;凹&quot;</span>:<span class="hljs-string">&quot;凸&quot;</span>)&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">printProcess</span>(i<span class="hljs-number">+1</span>,N,<span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printAllFolds</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> </span>&#123;<br>    <span class="hljs-built_in">printProcess</span>(<span class="hljs-number">1</span>,N,<span class="hljs-literal">true</span>);<br>&#125;<br><span class="hljs-comment">//直接用递归函数，不要建立2^N-1个数组</span><br><span class="hljs-comment">//由于遍历的时候简单递归无法判断是左子树还是右子树，用一个变量记录当前结点的状态</span><br></code></pre></td></tr></table></figure><h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><h5 id="图的存储方式"><a href="#图的存储方式" class="headerlink" title="图的存储方式"></a>图的存储方式</h5><p>1.邻接表法：每个点的直接邻居</p><p>2.邻接矩阵法：写一个矩阵，行列都是所有的点，没有边就是无穷大</p><h5 id="通用图结构"><a href="#通用图结构" class="headerlink" title="通用图结构"></a>通用图结构</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Edge</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> weight;<br>    Node *from;<br>    Node *to;<br><br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> weight, Node *from, Node *to): <span class="hljs-built_in">weight</span>(weight), <span class="hljs-built_in">from</span>(from), <span class="hljs-built_in">to</span>(to) &#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-type">int</span> in; <span class="hljs-comment">//入度，进入的边几条</span><br>    <span class="hljs-type">int</span> out; <span class="hljs-comment">//出度，出来的边几条</span><br>    vector&lt;Node *&gt; nexts; <span class="hljs-comment">//出去的边相连的邻居，个数等于出度</span><br>    vector&lt;Edge *&gt; edges; <span class="hljs-comment">//出去的边</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>: value(value), in(<span class="hljs-number">0</span>), out(<span class="hljs-number">0</span>) &#123;</span><br>    &#125;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>, Node *&gt; nodes;<br>    unordered_set&lt;Edge *&gt; edges;<br><br>    <span class="hljs-built_in">Graph</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;由[3,1,2]:权值，起点，终点，转化为通用图结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Graph <span class="hljs-title">creatGraph</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; &amp;martix)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> *graph = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Graph</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; martix.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-type">int</span> from = martix[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> to =  martix[i][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">if</span>(!graph-&gt;nodes.<span class="hljs-built_in">count</span>(from)) &#123;<br>            graph-&gt;nodes.<span class="hljs-built_in">insert</span>(&#123;from,<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(from)&#125;);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!graph-&gt;nodes.<span class="hljs-built_in">count</span>(to)) &#123;<br>            graph-&gt;nodes.<span class="hljs-built_in">insert</span>(&#123;to,<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(to)&#125;);<br>        &#125;<br>        Node* fromNode = graph-&gt;nodes[from];<br>        Node* toNode = graph-&gt;nodes[to];<br>        fromNode-&gt;out++;<br>        toNode-&gt;in++;<br>        Edge* edge = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Edge</span>(martix[i][<span class="hljs-number">0</span>],fromNode,toNode);<br>        fromNode-&gt;edges.<span class="hljs-built_in">push_back</span>(edge);<br>        fromNode-&gt;nexts.<span class="hljs-built_in">push_back</span>(toNode);<br>        graph-&gt;edges.<span class="hljs-built_in">insert</span>(edge);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="宽度优先遍历-队列-set"><a href="#宽度优先遍历-队列-set" class="headerlink" title="宽度优先遍历(队列+set)"></a>宽度优先遍历(队列+set)</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(Node* node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    queue&lt;Node*&gt; q;<br>    unordered_set&lt;Node*&gt; st;<br>    q.<span class="hljs-built_in">push</span>(node);<br>    st.<span class="hljs-built_in">insert</span>(node);<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        Node* cur = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        cout &lt;&lt;cur-&gt;value&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cur-&gt;nexts.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span>(!st.<span class="hljs-built_in">count</span>(cur-&gt;nexts[i])) &#123;<br>                q.<span class="hljs-built_in">push</span>(cur-&gt;nexts[i]);<br>                st.<span class="hljs-built_in">insert</span>(cur-&gt;nexts[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//弹出时打印</span><br></code></pre></td></tr></table></figure><h5 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Node *node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    stack&lt;Node *&gt; sk;<br>    unordered_set&lt;Node *&gt; st;<br>    sk.<span class="hljs-built_in">push</span>(node);<br>    st.<span class="hljs-built_in">insert</span>(node);<br>    cout &lt;&lt; node-&gt;value &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">while</span> (!sk.<span class="hljs-built_in">empty</span>()) &#123;<br>        Node *cur = sk.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cur-&gt;nexts.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">count</span>(cur-&gt;nexts[i])) &#123;<br>                sk.<span class="hljs-built_in">push</span>(cur-&gt;nexts[i]);<br>                cout &lt;&lt; cur-&gt;nexts[i]-&gt;value &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>                st.<span class="hljs-built_in">insert</span>(cur-&gt;nexts[i]);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//进入就打印，一条路走到黑</span><br></code></pre></td></tr></table></figure><h5 id="拓扑排序（无环）"><a href="#拓扑排序（无环）" class="headerlink" title="拓扑排序（无环）"></a>拓扑排序（无环）</h5><p>先找入度为0的点，将这个点叉掉，循环进行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;Node*&gt; <span class="hljs-title">sortedTopoLogy</span><span class="hljs-params">(Graph* graph)</span> </span>&#123;<br>    unordered_map&lt;Node*,<span class="hljs-type">int</span>&gt; inMap;<br>    queue&lt;Node*&gt; zeroInQueue;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; graph-&gt;nodes.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        inMap.<span class="hljs-built_in">insert</span>(&#123;graph-&gt;nodes[i],graph-&gt;nodes[i]-&gt;in&#125;);<br>        <span class="hljs-keyword">if</span>(graph-&gt;nodes[i]-&gt;in==<span class="hljs-number">0</span>) &#123;<br>            zeroInQueue.<span class="hljs-built_in">push</span>(graph-&gt;nodes[i]);<br>        &#125;<br>    &#125;<br><br>    vector&lt;Node*&gt; res;<br>    <span class="hljs-keyword">while</span> (!zeroInQueue.<span class="hljs-built_in">empty</span>()) &#123;<br>        res.<span class="hljs-built_in">push_back</span>(zeroInQueue.<span class="hljs-built_in">front</span>());<br>        Node* cur = zeroInQueue.<span class="hljs-built_in">front</span>();<br>        zeroInQueue.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cur-&gt;nexts.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            inMap[cur-&gt;nexts[i]]--;<br>            <span class="hljs-keyword">if</span>(inMap[cur-&gt;nexts[i]]==<span class="hljs-number">0</span>) &#123;<br>                zeroInQueue.<span class="hljs-built_in">push</span>(cur-&gt;nexts[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-comment">//引入inmap的原因是不修改原图的结构</span><br></code></pre></td></tr></table></figure><h5 id="kruskal算法（从边的角度出发）"><a href="#kruskal算法（从边的角度出发）" class="headerlink" title="kruskal算法（从边的角度出发）"></a>kruskal算法（从边的角度出发）</h5><p>无向图，生成最小生成树（保证连通性的同时，使得权值最小）</p><p>加上最小的边，如果有环不加</p><p><strong>简单并查集结构（已经连成两片的区域合起来）</strong></p><p>先建立每个点的自己集合，加上每一条边的时候，看from和to是否是同一个集合，不是就加上，并将集合合并，是就不加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mysets</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;Node *, vector&lt;Node *&gt; &gt; mp;<br><br>    <span class="hljs-built_in">Mysets</span>(vector&lt;Node *&gt; &amp;nodes) &#123;<br>        <span class="hljs-keyword">for</span> (Node *cur: nodes) &#123;<br>            vector&lt;Node *&gt; st;<br>            st.<span class="hljs-built_in">push_back</span>(cur);<br>            mp.<span class="hljs-built_in">insert</span>(&#123;cur, st&#125;);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSameSet</span><span class="hljs-params">(Node *from, Node *to)</span> </span>&#123;<br>        vector&lt;Node *&gt; fromSet = mp[from];<br>        vector&lt;Node *&gt; toSet = mp[to];<br>        <span class="hljs-keyword">return</span> fromSet == toSet;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unionSet</span><span class="hljs-params">(Node* from,Node* to)</span> </span>&#123;<br>        vector&lt;Node *&gt; fromSet = mp[from];<br>        vector&lt;Node *&gt; toSet = mp[to];<br>        <span class="hljs-keyword">for</span>(Node* toNode:toSet) &#123;<br>            fromSet.<span class="hljs-built_in">push_back</span>(toNode);<br>            mp[toNode] = fromSet;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mycompare</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Edge *edge1, Edge *edge2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> edge1-&gt;weight &gt; edge2-&gt;weight;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function">set&lt;Edge *&gt; <span class="hljs-title">kruskalMST</span><span class="hljs-params">(Graph *graph)</span> </span>&#123;<br>    vector&lt;Node *&gt; nodes;<br>    nodes.<span class="hljs-built_in">reserve</span>(graph-&gt;nodes.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-keyword">for</span> (pair&lt;<span class="hljs-type">int</span>, Node *&gt; pair: graph-&gt;nodes) &#123;<br>        nodes.<span class="hljs-built_in">push_back</span>(pair.second);<br>    &#125;<br>    Mysets *mysets = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Mysets</span>(nodes);<br>    priority_queue&lt;Edge *, vector&lt;Edge *&gt;, Mycompare&gt; pq;<br>    <span class="hljs-keyword">for</span> (Edge *edge: graph-&gt;edges) &#123;<br>        pq.<span class="hljs-built_in">push</span>(edge);<br>    &#125;<br>    set&lt;Edge *&gt; res;<br>    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>        Edge* edge = pq.<span class="hljs-built_in">top</span>();<br>        pq.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(!mysets-&gt;<span class="hljs-built_in">isSameSet</span>(edge-&gt;from,edge-&gt;to)) &#123;<br>            mysets-&gt;<span class="hljs-built_in">unionSet</span>(edge-&gt;from,edge-&gt;to);<br>            res.<span class="hljs-built_in">insert</span>(edge);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="prim算法（从点的角度出发）"><a href="#prim算法（从点的角度出发）" class="headerlink" title="prim算法（从点的角度出发）"></a>prim算法（从点的角度出发）</h5><p>从一个点出发，将被解锁的边中最小权值的边使用，将点拿进去，如果该点已经有了，就换另一条最小的边，并将刚刚那条边删除，循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">set&lt;Edge*&gt; <span class="hljs-title">primMST</span><span class="hljs-params">(Graph* graph)</span> </span>&#123;<br>    priority_queue&lt;Edge*,vector&lt;Edge*&gt;,Mycompare&gt; pq;<br>    unordered_set&lt;Node*&gt; st;<br>    set&lt;Edge *&gt; res;<br><br>    vector&lt;Node *&gt; nodes;<br>    nodes.<span class="hljs-built_in">reserve</span>(graph-&gt;nodes.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-keyword">for</span> (pair&lt;<span class="hljs-type">int</span>, Node *&gt; pair: graph-&gt;nodes) &#123;<br>        nodes.<span class="hljs-built_in">push_back</span>(pair.second);<br>    &#125;<br><br>    <span class="hljs-comment">//随便挑一个点，处理森林的问题</span><br>    <span class="hljs-keyword">for</span>(Node* node:nodes) &#123;<br>        <span class="hljs-keyword">if</span>(!st.<span class="hljs-built_in">count</span>(node)) &#123;<br>            st.<span class="hljs-built_in">insert</span>(node);<br>            <span class="hljs-keyword">for</span>(Edge* edge:node-&gt;edges) &#123;<br>                pq.<span class="hljs-built_in">push</span>(edge);<br>            &#125;<br>            <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>                Edge* edge =pq.<span class="hljs-built_in">top</span>();<br>                Node* to = edge-&gt;to;<br>                pq.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(!st.<span class="hljs-built_in">count</span>(to)) &#123;<br>                    st.<span class="hljs-built_in">insert</span>(to);<br>                    res.<span class="hljs-built_in">insert</span>(edge);<br>                    <span class="hljs-keyword">for</span>(Edge* nextEdge:to-&gt;edges) &#123;<br>                        pq.<span class="hljs-built_in">push</span>(nextEdge);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h5><p>没有一个累加和为负数的环，单元最短路径算法，每一个点到图的每一个点的最短路径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Node *<span class="hljs-title">getMinDistanaceAndUnselectedNode</span><span class="hljs-params">(<span class="hljs-type">const</span> unordered_map&lt;Node *, <span class="hljs-type">int</span>&gt;&amp; distanceMap, unordered_set&lt;Node *&gt; selectedNodes)</span> </span>&#123;<br>    Node *minNode = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-type">int</span> minDistance = INT_MAX;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> pair: distanceMap) &#123;<br>        Node *node = pair.first;<br>        <span class="hljs-type">int</span> distance = pair.second;<br>        <span class="hljs-keyword">if</span> (!selectedNodes.<span class="hljs-built_in">count</span>(node) &amp;&amp; distance &lt; minDistance) &#123;<br>            minNode = node;<br>            minDistance = distance;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> minNode;<br>&#125;<br><br><span class="hljs-function">unordered_map&lt;Node *, <span class="hljs-type">int</span>&gt; <span class="hljs-title">dijkstral</span><span class="hljs-params">(Node *head)</span> </span>&#123;<br>    <span class="hljs-comment">//key:从head到达key</span><br>    <span class="hljs-comment">//value:从head出发到达key的最小距离</span><br>    <span class="hljs-comment">//如果在表中，没有T的记录，含义是从head出发到T这个点的距离为无穷大</span><br>    unordered_map&lt;Node *, <span class="hljs-type">int</span>&gt; distanceMap;<br>    distanceMap.<span class="hljs-built_in">insert</span>(&#123;head, <span class="hljs-number">0</span>&#125;);<br>    <span class="hljs-comment">//已经求过距离的节点，存在selectedNodes中，以后再也不碰</span><br>    unordered_set&lt;Node *&gt; selectedNodes;<br>    Node *minNode = <span class="hljs-built_in">getMinDistanaceAndUnselectedNode</span>(distanceMap, selectedNodes);<br>    <span class="hljs-keyword">while</span>(minNode!=<span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-type">int</span> distance = distanceMap[minNode];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> edge:minNode-&gt;edges) &#123;<br>            Node* to = edge-&gt;to;<br>            <span class="hljs-keyword">if</span>(!distanceMap.<span class="hljs-built_in">count</span>(to)) &#123;<br>                distanceMap[to]=distance+edge-&gt;weight;<br>            &#125;<br>            distanceMap[to] = <span class="hljs-built_in">min</span>(distanceMap[to],distance+edge-&gt;weight);<br>        &#125;<br>        selectedNodes.<span class="hljs-built_in">insert</span>(minNode);<br>        minNode = <span class="hljs-built_in">getMinDistanaceAndUnselectedNode</span>(distanceMap,selectedNodes);<br>    &#125;<br>    <span class="hljs-keyword">return</span> distanceMap;<br>&#125;<br></code></pre></td></tr></table></figure><p>优化：选最小边的过程改成堆的方式，因为要改写堆，进行heapify和heapInsert</p><h4 id="前缀树（Trie）"><a href="#前缀树（Trie）" class="headerlink" title="前缀树（Trie）"></a>前缀树（Trie）</h4><p><strong>边表示字符，路径表示单词</strong>：从根到叶子节点的一条路径可以形成一个<strong>完整单词</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> pass;<br>    <span class="hljs-type">int</span> end;<br>    vector&lt;TrieNode *&gt; nexts; <span class="hljs-comment">//或者用unorderd_map&lt;char,TrieNode*&gt;来表示,字符种类特别多</span><br><br>    <span class="hljs-built_in">TrieNode</span>() &#123;<br>        pass = <span class="hljs-number">0</span>;<br>        end = <span class="hljs-number">0</span>;<br>        nexts = <span class="hljs-built_in">vector</span>&lt;TrieNode *&gt;(<span class="hljs-number">26</span>, <span class="hljs-literal">nullptr</span>);<br>    &#125;<br><br>    ~<span class="hljs-built_in">TrieNode</span>() &#123;<br>        <span class="hljs-keyword">for</span>(TrieNode* child:nexts) &#123;<br>            <span class="hljs-keyword">delete</span> child;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    TrieNode *root;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 递归删除 Trie 树的所有节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteTrie</span><span class="hljs-params">(TrieNode* node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">for</span> (TrieNode* child : node-&gt;nexts) &#123;<br>            <span class="hljs-built_in">deleteTrie</span>(child);  <span class="hljs-comment">// 递归删除所有子节点</span><br>        &#125;<br>        <span class="hljs-keyword">delete</span> node;  <span class="hljs-comment">// 释放当前节点</span><br>    &#125;<br>    <span class="hljs-built_in">Trie</span>() &#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>();<br>    &#125;<br>    ~<span class="hljs-built_in">Trie</span>() &#123;<br>        <span class="hljs-built_in">deleteTrie</span>(root);  <span class="hljs-comment">// 递归释放整个 Trie</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string &amp;word)</span> </span>&#123;<br>        TrieNode *node = root;<br>        node-&gt;pass++;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> i : word) &#123;<br>            <span class="hljs-type">int</span> index = i - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (node-&gt;nexts[index] == <span class="hljs-literal">nullptr</span>) &#123;<br>                node-&gt;nexts[index] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>();<br>            &#125;<br>            node = node-&gt;nexts[index];<br>            node-&gt;pass++;<br>        &#125;<br>        node-&gt;end++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(string &amp;word)</span> </span>&#123;<br>        TrieNode* node  = root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> i : word) &#123;<br>            <span class="hljs-type">int</span> index = i-<span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(node-&gt;nexts[index]==<span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            node = node-&gt;nexts[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> node-&gt;end;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prifixNumber</span><span class="hljs-params">(string &amp;word)</span> </span>&#123;<br>        TrieNode* node  = root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> i : word) &#123;<br>            <span class="hljs-type">int</span> index = i-<span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(node-&gt;nexts[index]==<span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            node = node-&gt;nexts[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> node-&gt;pass;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteChar</span><span class="hljs-params">(string &amp;word)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">search</span>(word)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        TrieNode *node = root;<br>        root-&gt;pass--;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> i: word) &#123;<br>            <span class="hljs-type">int</span> index = i-<span class="hljs-string">&#x27;a&#x27;</span>;<br>            node-&gt;nexts[index]-&gt;pass--;<br>            <span class="hljs-keyword">if</span>(node-&gt;nexts[index]-&gt;pass==<span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">delete</span> node-&gt;nexts[index];<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            node = node-&gt;nexts[index];<br>        &#125;<br>        node-&gt;end--;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h4><p>在某一个标准下，优先考虑最满足标准的样本，最中得到一个答案的算法，叫做贪心算法。</p><p>也就是说，不从整体最优上加以考虑，所作出的实在某种意义上的局部最优解</p><p>局部最优   -?-&gt;整体最优</p><p><strong>贪心算法策略</strong></p><p>1.实现一个不依靠贪心策略的解法X，用最暴力的尝试</p><p>2.脑补出策略A，策略B，策略C，有效的比较策略不能形成环（有传递性）</p><p>3.用1，2验证贪心策略</p><p>4.不要纠结贪心策略的证明</p><p><strong>技巧</strong>:</p><p>堆和排序</p><h5 id="会议问题"><a href="#会议问题" class="headerlink" title="会议问题"></a>会议问题</h5><p>一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲，给你每一个项目开始的时间和结束的时间，你来安排宣讲的日程，要求会议室进行的宣讲场次最多</p><p><strong>贪心策略</strong></p><p>1.时间最短的项目先安排，反例：1-8 9-19  8-9</p><p>2.结束时间早的先安排</p><h5 id="最小的字典序"><a href="#最小的字典序" class="headerlink" title="最小的字典序"></a>最小的字典序</h5><p>数组中有很多字符串，将字符串拼接起来做到最小的字典序</p><p>1.如果两个字符串长度一样，直接一个一个比</p><p>2.不一样，将其补成一样的，后面加</p><p><strong>贪心策略</strong></p><p>比较器：a+b&lt;&#x3D;b+a a前，b后</p><h5 id="金条问题"><a href="#金条问题" class="headerlink" title="金条问题"></a>金条问题</h5><p>一块金条切成两半，需要花费和长度数值一样的铜板，怎么切最省</p><p><strong>贪心策略</strong></p><p>哈夫曼编码问题</p><p>将数组变成小根堆，拿出两个结合，放回堆，循环</p><h5 id="项目利润最大化"><a href="#项目利润最大化" class="headerlink" title="项目利润最大化"></a>项目利润最大化</h5><p>一个项目有本金和利润，如何用固定的初始资金和项目个数获得最大的利润，串行进行</p><p><strong>贪心策略</strong></p><p>将所有项目按照本金组成小根堆，初始资金满足的弹出以利润构成大根堆</p><h5 id="数据流中，获得中位数"><a href="#数据流中，获得中位数" class="headerlink" title="数据流中，获得中位数"></a>数据流中，获得中位数</h5><p>也是大根堆和小根堆配合</p><h4 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h4><p>暴力递归就是尝试</p><p>1.把问题转化为规模缩小的同类问题的子问题</p><p>2.有明确的不需要继续进行递归的条件</p><p>3.有当得到了子问题的结果之后的决策过程</p><p>4.不记录每一个子问题的解</p><p><strong>对每个i位置都尝试</strong></p><h5 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h5><p>1.1-i-1 from-other</p><p>2.i        from-to</p><p>3.1-i-1 other-to</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">const</span> string &amp;start, <span class="hljs-type">const</span> string &amp;end, <span class="hljs-type">const</span> string &amp;other)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;移动1从&quot;</span> &lt;&lt; start &lt;&lt; <span class="hljs-string">&quot;到&quot;</span> &lt;&lt; end &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">process</span>(i<span class="hljs-number">-1</span>,start,other,end);<br>    cout &lt;&lt; <span class="hljs-string">&quot;移动&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;从&quot;</span> &lt;&lt; start &lt;&lt; <span class="hljs-string">&quot;到&quot;</span> &lt;&lt; end &lt;&lt; endl;<br>    <span class="hljs-built_in">process</span>(i<span class="hljs-number">-1</span>,other,end,start);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hanoi</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">process</span>(n, <span class="hljs-string">&quot;左&quot;</span>, <span class="hljs-string">&quot;右&quot;</span>, <span class="hljs-string">&quot;中&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="打印一个子串全部子序列"><a href="#打印一个子串全部子序列" class="headerlink" title="打印一个子串全部子序列"></a>打印一个子串全部子序列</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printStr</span><span class="hljs-params">(string &amp;str)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> i: str) &#123;<br>        <span class="hljs-keyword">if</span> (i != <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>            cout &lt;&lt; i;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(string &amp;str, <span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i == str.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-built_in">printStr</span>(str);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">func</span>(str, i + <span class="hljs-number">1</span>);<br>    <span class="hljs-type">char</span> temp = str[i];<br>    str[i] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-built_in">func</span>(str, i + <span class="hljs-number">1</span>);<br>    str[i] = temp;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printAllSubQuence</span><span class="hljs-params">(string &amp;str)</span> </span>&#123;<br>    <span class="hljs-built_in">func</span>(str, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">//系统栈存储需要改的值，运行完后改回去</span><br></code></pre></td></tr></table></figure><h5 id="打印字符串全部的排列（分支限界）"><a href="#打印字符串全部的排列（分支限界）" class="headerlink" title="打印字符串全部的排列（分支限界）"></a>打印字符串全部的排列（分支限界）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printAllSubQuence</span><span class="hljs-params">(string &amp;str)</span> </span>&#123;<br>    <span class="hljs-built_in">func</span>(str, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(string &amp;str, <span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i == str.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-built_in">printStr</span>(str);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; str.<span class="hljs-built_in">size</span>(); j++) &#123;<br>        <span class="hljs-built_in">swap</span>(str[i],str[j]);<br>        <span class="hljs-built_in">func2</span>(str,i<span class="hljs-number">+1</span>);<br>        <span class="hljs-built_in">swap</span>(str[i],str[j]);<br>        <span class="hljs-comment">//为什么仅仅交换了当前i,j的位置就能保证与原来的字符一样，因为在递归函数一次次向上的过程中，会不断修正发生过的修改</span><br>        <span class="hljs-comment">//所以仅仅需要把当前函数内作出的改变还原即可</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">permutation</span><span class="hljs-params">(string &amp;str)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (str.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">func2</span>(str, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visit</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; str.<span class="hljs-built_in">size</span>(); j++) &#123;<br>    <span class="hljs-keyword">if</span>(!visit[str[j]-<span class="hljs-string">&#x27;a&#x27;</span>]) &#123;<br>        visit[str[j]-<span class="hljs-string">&#x27;a&#x27;</span>]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">swap</span>(str[i],str[j]);<br>        <span class="hljs-built_in">func2</span>(str,i<span class="hljs-number">+1</span>);<br>        <span class="hljs-built_in">swap</span>(str[i],str[j]);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//去掉重复的字符串</span><br></code></pre></td></tr></table></figure><h5 id="博弈问题"><a href="#博弈问题" class="headerlink" title="博弈问题"></a>博弈问题</h5><p>给定一个整形数组arr，代表数值不同的纸牌连成一条线，玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后拿，但是每个玩家只能拿走最左或者最右的纸牌，玩家A和B都绝顶聪明，请返回获胜者的分数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">s</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(L==R) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(<span class="hljs-built_in">f</span>(arr,L<span class="hljs-number">+1</span>,R),<span class="hljs-built_in">f</span>(arr,L,R<span class="hljs-number">-1</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(L==R) &#123;<br>        <span class="hljs-keyword">return</span> arr[L];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(arr[L]+<span class="hljs-built_in">s</span>(arr,L<span class="hljs-number">+1</span>,R),arr[R]+<span class="hljs-built_in">s</span>(arr,L,R<span class="hljs-number">-1</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">win</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(arr.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">f</span>(arr,<span class="hljs-number">0</span>,arr.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>),<span class="hljs-built_in">s</span>(arr,<span class="hljs-number">0</span>,arr.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="逆序一个栈"><a href="#逆序一个栈" class="headerlink" title="逆序一个栈"></a>逆序一个栈</h5><p>1.将最后一个数提取出来</p><p>2.将栈反转</p><p>3.将提取出来的数放上去</p><p>如何提取：</p><p>递归提取栈的头，当发现提取后为空时不放回去（代表是最后一个），不为空就放回去</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(stack&lt;<span class="hljs-type">int</span>&gt; &amp;sk)</span> </span>&#123;<br>    <span class="hljs-type">int</span> temp = sk.<span class="hljs-built_in">top</span>();<br>    sk.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span>(sk.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> last = <span class="hljs-built_in">f</span>(sk);<br>        sk.<span class="hljs-built_in">push</span>(temp);<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseStack</span><span class="hljs-params">(stack&lt;<span class="hljs-type">int</span>&gt; &amp;sk)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(sk.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> last = <span class="hljs-built_in">f</span>(sk);<br>        <span class="hljs-built_in">reverseStack</span>(sk);<br>        sk.<span class="hljs-built_in">push</span>(last);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="字符串转化为数字"><a href="#字符串转化为数字" class="headerlink" title="字符串转化为数字"></a>字符串转化为数字</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">way</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i == nums.<span class="hljs-built_in">size</span>() || (i == nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &amp;&amp; nums[i] != <span class="hljs-number">0</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> temp = nums[i] * <span class="hljs-number">10</span> + nums[i + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (temp &gt; <span class="hljs-number">26</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">way</span>(nums, i + <span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">way</span>(nums, i + <span class="hljs-number">1</span>) + <span class="hljs-built_in">way</span>(nums, i + <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">turn</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">way</span>(nums, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="最大价值"><a href="#最大价值" class="headerlink" title="最大价值"></a>最大价值</h5><p>给定两个长度都为N的数组weights和values，分别代表i号物品的重量和价值，计算最大载重bag的最大价值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ff</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;weights, vector&lt;<span class="hljs-type">int</span>&gt; &amp;values, <span class="hljs-type">int</span> remain, <span class="hljs-type">int</span> now)</span> </span>&#123;<br>    <span class="hljs-type">int</span> maxValue = now;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weights.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-type">int</span> weight = weights[i];<br>        <span class="hljs-keyword">if</span> (weight != <span class="hljs-number">-1</span> &amp;&amp; weight &lt;= remain) &#123;<br>            weights[i] = <span class="hljs-number">-1</span>;<br>            <span class="hljs-type">int</span> value = <span class="hljs-built_in">ff</span>(weights, values, remain - weight, now + values[i]);<br>            maxValue = <span class="hljs-built_in">max</span>(maxValue, value);<br>        &#125;<br>        weights[i] = weight;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxValue;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;weights, vector&lt;<span class="hljs-type">int</span>&gt; &amp;values, <span class="hljs-type">int</span> bag)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (bag &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ff</span>(weights, values, bag, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">//从选的角度出发</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++">unordered_map&lt;string, <span class="hljs-type">int</span>&gt; memo;  <span class="hljs-comment">// 记忆化存储</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ff2</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;weights, vector&lt;<span class="hljs-type">int</span>&gt; &amp;values, <span class="hljs-type">int</span> remain, <span class="hljs-type">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (remain &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (index == weights.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    string key = <span class="hljs-built_in">to_string</span>(index) + <span class="hljs-string">&quot;_&quot;</span> + <span class="hljs-built_in">to_string</span>(remain);<br>    <span class="hljs-keyword">if</span> (memo.<span class="hljs-built_in">count</span>(key)) <span class="hljs-keyword">return</span> memo[key];<br><br>    <span class="hljs-type">int</span> notPick = <span class="hljs-built_in">ff</span>(weights, values, remain, index + <span class="hljs-number">1</span>); <span class="hljs-comment">// 不选当前物品</span><br>    <span class="hljs-type">int</span> pick = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (weights[index] &lt;= remain) &#123;<br>        pick = values[index] + <span class="hljs-built_in">ff</span>(weights, values, remain - weights[index], index + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> memo[key] = <span class="hljs-built_in">max</span>(pick, notPick);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxValue2</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;weights, vector&lt;<span class="hljs-type">int</span>&gt; &amp;values, <span class="hljs-type">int</span> bag)</span> </span>&#123;<br>    memo.<span class="hljs-built_in">clear</span>();  <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ff2</span>(weights, values, bag, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">//从被选的角度出发</span><br></code></pre></td></tr></table></figure><h5 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h5><p>一行一行选，不共列和斜线</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;vector, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; i; ++k) &#123;<br>        <span class="hljs-keyword">if</span>(vector[i]==vector[j]||(<span class="hljs-built_in">abs</span>(vector[j]-vector[i]))==(<span class="hljs-built_in">abs</span>(j-i))) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">process1</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;record, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i == n) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= n; j++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>(record, i, j, n)) &#123;<br>            record[i] = j;<br>            res += <span class="hljs-built_in">process1</span>(record, i + <span class="hljs-number">1</span>, n);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">num</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">record</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>; <span class="hljs-comment">//第i行的皇后在第n列</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">process1</span>(record, <span class="hljs-number">0</span>, n);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>加速，位运算</strong></p><p>选择加速，用列限制，左斜限制，右斜限制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">process2</span><span class="hljs-params">(<span class="hljs-type">int</span> limit, <span class="hljs-type">int</span> colLimit, <span class="hljs-type">int</span> leftLimit, <span class="hljs-type">int</span> rightLimit)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (limit == colLimit) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> pos = limit &amp; (~(colLimit | leftLimit | rightLimit));<br>    <span class="hljs-type">int</span> mostRightOne = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (pos != <span class="hljs-number">0</span>) &#123;<br>        mostRightOne = pos &amp; (~pos + <span class="hljs-number">1</span>);<br>        pos = pos - mostRightOne;<br>        res += <span class="hljs-built_in">process2</span>(limit, colLimit | mostRightOne,<br>                        (leftLimit | mostRightOne) &lt;&lt; <span class="hljs-number">1</span>,<br>                        (rightLimit | mostRightOne) &gt;&gt; <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">num2</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> limit = n == <span class="hljs-number">32</span> ? <span class="hljs-number">-1</span> : (<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">process</span>(limit, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="哈希函数和哈希表"><a href="#哈希函数和哈希表" class="headerlink" title="哈希函数和哈希表"></a>哈希函数和哈希表</h4><h5 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h5><p>1.输入域无穷，输出域相对有限</p><p>2.相同的输入参数返回相同的结果，无随机的成分</p><p>3.存在不同的输入导致相同的输出，哈希碰撞，几率很低</p><p>4.哈希函数的映射疏密度基本相同，保证均匀性（每一小块的数量基本相同）和离散性（输入改变一点点，输出会有很大改变），混淆和扩散</p><p>5.在0-n上均匀分布，那么%m后也在0-m-1上均匀分布</p><h5 id="大数据查找"><a href="#大数据查找" class="headerlink" title="大数据查找"></a>大数据查找</h5><p>假设有一个大文件，无符号整数0-2^32-1，42亿，共有40亿个，有1G的内存，返回出现次数最多的数字</p><p>我们发现hash表的空间只和数的种类个数有关（不怕同一种数数量过多），我们将每一个数调一个hash函数，并%100，得到100个大小基本相同（因为hash的均匀性）的小文件</p><p>先用hash在种类上做到均分，然后通过模操作切分</p><h5 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h5><p>unordered_set没有value，unordered_map与value  key-&gt;value</p><p>使用时认为增删改查都是常数操作</p><p>java中基础类型是按值传递，自定义类型引用传递，c++中都是按值传递</p><p>实现过程：先开一个模17的表，串链表的头，将原值经过hash，再模上17，挂载在对应得链表上，由于hash的均匀性，每块链表的长度基本相同。当某一条链的长度超过6之后，就可以认为所有的链都逼近6，那么就将表大小（模37）扩一倍。</p><p>只有扩容的代价是logN*N，单次扩容代价logN</p><p>当链的长度开的大时，扩容代价逼近O(1)</p><p>离线扩容技术，不占用用户的在线时间</p><h5 id="设计RandomPool结构"><a href="#设计RandomPool结构" class="headerlink" title="设计RandomPool结构"></a>设计RandomPool结构</h5><p>1.insert(key):将某个key加入到该结构中，做到不重复加入</p><p>2.delete(key):将原本在结构中的某个key移除</p><p>3.getRandom():等概率随机返回结构中的任何一个key</p><p>用rand()%index随机返回一个key，key-&gt;index，index-&gt;key</p><p>删除的时候李代桃僵</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomPool</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;string, <span class="hljs-type">int</span>&gt; mp1;<br>    unordered_map&lt;<span class="hljs-type">int</span>, string&gt; mp2;<br>    <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">RandomPool</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span>: size(<span class="hljs-number">0</span>) &#123;</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string &amp;str)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!mp<span class="hljs-number">1.</span><span class="hljs-built_in">count</span>(str)) &#123;<br>            mp1[str] = size;<br>            mp2[size] = str;<br>            size++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">getRandom</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(size==<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> index = <span class="hljs-built_in">rand</span>()%size;<br>        <span class="hljs-keyword">return</span> mp2[index];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deletePool</span><span class="hljs-params">(string &amp;key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(mp<span class="hljs-number">1.</span><span class="hljs-built_in">count</span>(key)) &#123;<br>            <span class="hljs-type">int</span> index = mp1[key];<br>            string last = mp2[size<span class="hljs-number">-1</span>];<br>            mp1[last] = index;<br>            mp2[index] = last;<br>            mp<span class="hljs-number">1.</span><span class="hljs-built_in">erase</span>(key);<br>            mp<span class="hljs-number">2.</span><span class="hljs-built_in">erase</span>(size<span class="hljs-number">-1</span>);<br>            size--;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bitset&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::bitset&lt;8&gt; bits;  <span class="hljs-comment">// 创建 8 位的 bitset，初始值为 00000000</span><br>    bits.<span class="hljs-built_in">set</span>(<span class="hljs-number">1</span>);          <span class="hljs-comment">// 设置第 1 位（从 0 开始）为 1</span><br>    bits.<span class="hljs-built_in">set</span>(<span class="hljs-number">3</span>);          <span class="hljs-comment">// 设置第 3 位为 1</span><br>    bits.<span class="hljs-built_in">flip</span>(<span class="hljs-number">2</span>);         <span class="hljs-comment">// 翻转第 2 位</span><br>    bits.<span class="hljs-built_in">reset</span>(<span class="hljs-number">3</span>);        <span class="hljs-comment">// 清除第 3 位</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Bitset: &quot;</span> &lt;&lt; bits &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 01000010</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//也可以用int[]来实现</span><br></code></pre></td></tr></table></figure><h5 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h5><p>有100亿个黑名单（64位url)，如何快速过滤；爬虫进程去重问题 （没有删除行为）</p><p>经典结构：使用哈希表，需要6400亿B</p><p>极大的减少内存，可以允许一定的失误率</p><p>1.如果url是黑名单的东西，但却认为是白名单（不会存在）</p><p>2.如果url是白名单的东西，但却认为是黑名单（会存在这样的问题）</p><p>布隆过滤器就是一个大位图</p><p>长度为m个位图占用大小就是m&#x2F;8</p><p>url1哈希得到k1,k2,k3等，然后%m将对应位图位置描黑</p><p>当url需要判断时，就通过上诉操作，看看是不是所有的位置都是1，一旦有1个位置为白，那么就不在黑名单里面</p><p>失误律怎么确定</p><p>1.m越大，那么就越准确</p><p>2.根据数据量和预期失误率和m大小确定k值，当k很小和很大时都会造成失误律大</p><p><strong>计算公式：</strong></p><p>条件：样本量n，失误律p，单样本大小无关</p><p><img src="/images/2025-02-20-1.png" alt="1"></p><h5 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h5><p>经典的服务器，逻辑端写逻辑，数据端维持数据</p><p>比如来了一个数据x，先将数据哈希，然后模M，得到处在哪个服务器上，在从那个服务器上找</p><p><strong>负载：</strong>会有高频和中频和低频的区别，将三个数量维持差不多就可以做到负载均衡</p><p><strong>哈希key的选择：</strong>一定要选择种类多的，让高频和中频和低频都有数量</p><p><strong>问题：</strong>如果增加或减少机器，那么迁移的代价是全量的</p><p><strong>解决：</strong></p><p>1.设计一个有序数组，表示机器存储的区域（每个数字代表一个机器，当需要放一个数时，就找大于等于他的最左数字（二分查找），如果没找到，就是第一个。那么这样就可以找到每个数字对应的机器。</p><p>2.当要增加或者删除一个机器时，只需要把那一段修改即可</p><p><strong>存在的问题：</strong></p><p>1.如何确保把环，将数量均分</p><p>2.当增加或减少时，怎么做到负载均衡</p><p><strong>虚拟节点技术：</strong>m1,m2,m3都规定一些虚拟节点（按比例），原来是每个机器代表一个节点，现在每个机器代表一批节点，增减都通过节点的归属来弄，这样还可以管理负载</p><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><h5 id="岛问题"><a href="#岛问题" class="headerlink" title="岛问题"></a>岛问题</h5><p>一个矩阵中只有0和1两种值，每个位置都可以和自己的上下左右四个位置相连，如果有一片1连在一起，这个部分叫做一个岛，求一个矩阵中岛的个数</p><p>经典解法：感染，将1改成2，遍历调用感染过程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">infect</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; &amp;matix, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= matix.<span class="hljs-built_in">size</span>() || j &lt; <span class="hljs-number">0</span> || j &gt;= matix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() || matix[i][j != <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    matix[i][j] = <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">infect</span>(matix, i + <span class="hljs-number">1</span>, j);<br>    <span class="hljs-built_in">infect</span>(matix, i - <span class="hljs-number">1</span>, j);<br>    <span class="hljs-built_in">infect</span>(matix, i, j - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">infect</span>(matix, i, j + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dao</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; &amp;martix)</span> </span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; martix.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; martix[i].<span class="hljs-built_in">size</span>(); ++j) &#123;<br>            <span class="hljs-keyword">if</span> (martix[i][j] == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-built_in">infect</span>(martix, i, j);<br>                count++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><span class="hljs-comment">//时间复杂度：O(n*m)</span><br></code></pre></td></tr></table></figure><p><strong>如何设计一个并行算法解决这个问题</strong></p><p>假设给一张非常大的矩阵，能不能先将这个二维数组分片，再合并</p><h5 id="并查集结构"><a href="#并查集结构" class="headerlink" title="并查集结构"></a>并查集结构</h5><p>两片区域是否相同，两片区域合并</p><p>1.链表，合并快，判断相同不快       </p><p>2.哈希，判断相同快，合并不快       点对应点的区域</p><p><strong>运用往上指的图</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//对每个样本包装一下，封装的原因是可以每个元素的内容更加丰富</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Element</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    V value;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Element</span><span class="hljs-params">(V value)</span>: value(value) &#123;</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFindSet</span>&lt;V&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;V, Element&lt;V&gt; *&gt; elementMap;<span class="hljs-comment">//样本对应元素</span><br>    unordered_map&lt;Element&lt;V&gt; *, Element&lt;V&gt; *&gt; fatherMap;<span class="hljs-comment">//每个元素的父</span><br>    unordered_map&lt;Element&lt;V&gt; *, <span class="hljs-type">int</span>&gt; sizeMap;<span class="hljs-comment">//最上面的代表节点的整个集合大小</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">UnionFindSet</span><span class="hljs-params">(vector&lt;V&gt; &amp;list)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; list.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            Element&lt;V&gt; *element = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Element</span>&lt;V&gt;(list[i]);<br>            elementMap[list[i]] = element;<br>            fatherMap[element] = element;<br>            sizeMap[element] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br><span class="hljs-comment">//找最上面的节点</span><br>    <span class="hljs-function">Element&lt;V&gt; *<span class="hljs-title">findHead</span><span class="hljs-params">(Element&lt;V&gt; *element)</span> </span>&#123;<br>        stack&lt;Element&lt;V&gt; *&gt; sk;<span class="hljs-comment">//用一个栈储存沿途的节点</span><br>        <span class="hljs-keyword">while</span> (fatherMap[element] != element) &#123;<br>            sk.<span class="hljs-built_in">push</span>(element);<br>            element = fatherMap[element];<br>        &#125;<br>        <span class="hljs-comment">//扁平化，将沿途的节点父亲改为最上面的节点</span><br>        <span class="hljs-keyword">while</span> (!sk.<span class="hljs-built_in">empty</span>()) &#123;<br>            fatherMap[sk.<span class="hljs-built_in">top</span>()] = element;<br>            sk.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> element;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSameSet</span><span class="hljs-params">(V v1, V v2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!elementMap.<span class="hljs-built_in">count</span>(v1) || !elementMap.<span class="hljs-built_in">count</span>(v2)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        Element&lt;V&gt; *element1 = elementMap[v1];<br>        Element&lt;V&gt; *element2 = elementMap[v2];<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">findHead</span>(element1) == <span class="hljs-built_in">findHead</span>(element2)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unionSet</span><span class="hljs-params">(V v1, V v2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!elementMap.<span class="hljs-built_in">count</span>(v1) || !elementMap.<span class="hljs-built_in">count</span>(v2)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isSameSet</span>(v1, v2)) &#123;<br>            Element&lt;V&gt; *h1 = <span class="hljs-built_in">findHead</span>(elementMap[v1]);<br>            Element&lt;V&gt; *h2 = <span class="hljs-built_in">findHead</span>(elementMap[v2]);<br>            Element&lt;V&gt; *big = sizeMap[h1] &gt;= sizeMap[h2] ? h1 : h2;<br>            Element&lt;V&gt; *small = big == h1 ? h2 : h1;<br>            fatherMap[small] = big;<br>            sizeMap[big] = sizeMap[small] + sizeMap[big];<br>            sizeMap.<span class="hljs-built_in">erase</span>(small);<br>        &#125;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="并查集解决岛的并行问题"><a href="#并查集解决岛的并行问题" class="headerlink" title="并查集解决岛的并行问题"></a>并查集解决岛的并行问题</h5><p>对每一片查询，收集边界上的源头信息，建立源头的集合</p><p>如果边界相碰，看两个源头是否是一个集合，不是的话就将岛的数量减1，并合并两个集合，如果是一个集合就什么都不做。</p><h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p>查str2是不是str1的子串（要求连续），返回开头的位置</p><p>暴力递归：O(n*m)</p><p>kmp也是从左往右依次看</p><h5 id="最长前缀和后缀匹配长度"><a href="#最长前缀和后缀匹配长度" class="headerlink" title="最长前缀和后缀匹配长度"></a><strong>最长前缀和后缀匹配长度</strong></h5><p>一个字符前面的那些字符，前缀后后缀相等的最大长度，等于自身长度不讨论，对str2求</p><h5 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h5><p>[a  a b a a b s]</p><p>[-1 0 1 0 1 2 3]  第一个字符前面没有字符，规定为-1</p><p>…[i                   |j       |x]…  str1</p><p>   [0        k|                |y]…  str2</p><p>当str从i开始配的str2从0配到了y不相等</p><p>1.str2上y的最长前缀和后缀匹配长度到了k，那么从j开始配的str2可以直接匹配k后面的那个数是否和x相等</p><p>2.一定能够知道j前面的不可能匹配出str2，假设有一个p点在j之前能够匹配出str2，那么一定意味着p点开始与str2相同，那么由此可以推断出p点到x点之前一定与0到k值后的某个点，两段字符一定相等，而之前求得y点的最长前缀和后缀匹配长度为k，这段字符长度又比k大，那么肯定从p点开始的str1不可能有str2的子串</p><p>时间复杂度:O(n)</p><h5 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h5><p>对0,1位置规定</p><p>对i位置，看i-1位置的值</p><p>如果i-1值k位置的字符与i-1相等，那么i位置的值为k+1，为什么是加1而不可能更大呢，假设为k+3，对i位置来说，从0-k+2位置，和从j到i-1位置相等，那么i-1的值就应该是k+2</p><p>如果不一样，那就看k位置的next数组值p，如果p位置等于i-1那么就是p+1，一直往前跳</p><p>感觉和kmp匹配过程一个原理</p><p>时间复杂度:O(m)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getIndexof</span><span class="hljs-params">(string &amp;str1, string &amp;str2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (str<span class="hljs-number">1.</span><span class="hljs-built_in">empty</span>() || str<span class="hljs-number">2.</span><span class="hljs-built_in">empty</span>() || str<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>() &gt; str<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; str<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() &amp;&amp; j &lt; str<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (str1[i] == str2[j]) &#123;<br>            i++;<br>            j++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//next[j] == -1;</span><br>            i++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            j = next[j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> j == str<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>() ? i - j : <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getNext</span><span class="hljs-params">(string &amp;str)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (str.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>&#125;;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(str.size())</span></span>;<br>    next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>    next[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> cn = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; next.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (str[i - <span class="hljs-number">1</span>] == str[cn]) &#123;<br>            next[i++] = ++cn;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cn &gt; <span class="hljs-number">0</span>) &#123;<br>            cn = next[cn];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            next[i++] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> next;<br>&#125;<br><span class="hljs-comment">//时间复杂度:O(n)</span><br></code></pre></td></tr></table></figure><h4 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h4><p>计算字符串str中最长的回文子串</p><p>暴力解法，从每一个位置为对称轴向左右两边扩（但是长度为偶数的回文会错过，只能求的奇数的解），解决办法是将每两个字符之间加一个#（加什么字符都行），结果&#x2F;2，时间复杂度O(N2)</p><p>回文半径：从每个数往一边数的大小   回文直径</p><p>生成一个回文半径数组</p><p>之前扩的所有位置中所到达的最右回文右边界(R)与得出这个值的C</p><p>1.当前来到的位置在回味右边界外，暴力扩</p><p>2.当前来到的位置在回文右边界里，必然有下面的拓扑关系</p><p>L      i’       C       i       R</p><p>一，i’的回文区域在L到R里面</p><p>（a（bcb）dk）s（kd（bcb）a ）  (演示不加#)</p><p>那么i位置的回文半径与i’一样，i与i’对称</p><p>二，i’的回文区域有一部分在L到R外面</p><p>(ab(cdedcba))k(abcdedc)ft</p><p>   x      i’     Y         Z     i      P</p><p>那么i位置的回文半径就是R-i，由i’的对称轴X&#x3D;&#x3D;Y，由C的对称轴，Y&#x3D;&#x3D;Z，如果Z&#x3D;&#x3D;P，那么X&#x3D;&#x3D;P，C的对称轴就应该加1，故Z!&#x3D;P</p><p>三，i’的回文区域正好压到L</p><p>有一个至少得区域，剩下的需要判断</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">toManacherStr</span><span class="hljs-params">(string &amp;str)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (str.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>    string s;<br>    s.<span class="hljs-built_in">resize</span>(str.<span class="hljs-built_in">size</span>() * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        s[i] = (i &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> ? <span class="hljs-string">&#x27;#&#x27;</span> : str[j++];<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxLcpsLength</span><span class="hljs-params">(string &amp;s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    string str = <span class="hljs-built_in">toManacherStr</span>(s);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pArr</span><span class="hljs-params">(str.size())</span></span>;<br>    <span class="hljs-type">int</span> C = <span class="hljs-number">-1</span>; <span class="hljs-comment">//中心</span><br>    <span class="hljs-type">int</span> R = <span class="hljs-number">-1</span>; <span class="hljs-comment">//回文右边界，不包括边界</span><br>    <span class="hljs-type">int</span> maxL = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        pArr[i] = i &lt; R ? <span class="hljs-built_in">min</span>(R - i, pArr[<span class="hljs-number">2</span> * C - i]) : <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i + pArr[i] &lt; str.<span class="hljs-built_in">size</span>() &amp;&amp; i - pArr[i] &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (str[i + pArr[i]] == str[i - pArr[i]]) &#123;<br>                pArr[i]++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i + pArr[i] &gt; R) &#123;<br>            R = i+pArr[i];<br>            C = i;<br>        &#125;<br>        maxL = <span class="hljs-built_in">max</span>(maxL,pArr[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxL<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-comment">//时间复杂度：O(n)</span><br></code></pre></td></tr></table></figure><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p><strong>一个数组中，一个区域内的最大值（最小值）</strong></p><p>窗口指的是一开始窗口左边界和右边界都停留在数组的左侧，可以让L，R往右动，不要让L超过R，R往右动代表有一个元素进入，L往右动代表有一个元素出来，如何随时不用遍历的代价给出窗口中的最大值</p><p>构造一个双端队列：放下标还是放值，放下标的话可以由下标得到值，多一个信息，规定从大到小</p><p>流程：R往右动的时候，看最后面的数是否大于它，如果大于直接进，小于等于弹出尾，继续判断，知道队列空或者满足情况</p><p>L往右动的时候，看一眼过期的数字是否是最大值，如果是就弹出，如果不是就不用管</p><p>头部就是最大值</p><h5 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h5><p>双端队列到底维持的什么信息</p><p>维持的信息：如果L往右动的时候，成为最大值的可能性</p><p>当R往右动的时候，进来一个大的数为什么要弹出，因为刚进来的数下标比前面的数大，而且数字也比前面的大，那么前面的比他小的数就不可能是最大值</p><h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><p>每个位置最多进出窗口1次，总的时间复杂的就是O(n)</p><h4 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h4><p><strong>找每个位置的数左边离他最近的比他大（小）的，右边最近的比他大（小）的</strong></p><p>无重复值</p><p>构造一个栈：规定从栈最后到头由大到小，保持单调性，</p><p>流程：进入一个数，判断是否比当前栈头小，若小直接进，如果大，弹出，那么弹出这个数的信息就是：左边比他大的就是下面压着那个数，右边比他大的就是进来的这个数，继续判断</p><p>清算阶段，依次弹出每个数左边比他大的就是下面压着那个数，右边比他大的没有</p><p>有重复值</p><p>压一个链表</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>正数数组中累计和与最小值的乘积，给数组中子数组中指标A最大的值</p><p>对每个数字作为最小值的子数组取结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 找到每个元素左侧和右侧的最近更小值</span><br>vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">finMin</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr) &#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; sk;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">ans</span>(arr.<span class="hljs-built_in">size</span>(), &#123;<span class="hljs-number">-1</span>, arr.<span class="hljs-built_in">size</span>()&#125;); <span class="hljs-comment">// 初始化为默认值</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">while</span> (!sk.<span class="hljs-built_in">empty</span>() &amp;&amp; arr[i] &lt; arr[sk.<span class="hljs-built_in">top</span>()]) &#123;<br>            <span class="hljs-type">int</span> index = sk.<span class="hljs-built_in">top</span>();<br>            sk.<span class="hljs-built_in">pop</span>();<br>            ans[index].first = sk.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">-1</span> : sk.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 更新左边界</span><br>            ans[index].second = arr[i]; <span class="hljs-comment">// 更新右边界</span><br>        &#125;<br>        sk.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br><br>    <span class="hljs-comment">// 处理栈中剩余的元素</span><br>    <span class="hljs-keyword">while</span> (!sk.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> index = sk.<span class="hljs-built_in">top</span>();<br>        sk.<span class="hljs-built_in">pop</span>();<br>        ans[index].second = arr.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 右边界</span><br>        ans[index].first = sk.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">-1</span> : sk.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 左边界</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-comment">// 计算最大指标 A</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findAMax</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;target)</span> </span>&#123;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; minArr = <span class="hljs-built_in">finMin</span>(target);<br>    <span class="hljs-type">int</span> maxA = INT_MIN; <span class="hljs-comment">// 记录最大值</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; minArr.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (minArr[i].first == <span class="hljs-number">-1</span> &amp;&amp; minArr[i].second == target.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 如果没有有效的边界，跳过</span><br><br>        <span class="hljs-type">int</span> left = minArr[i].first == <span class="hljs-number">-1</span> ? i : minArr[i].first + <span class="hljs-number">1</span>; <span class="hljs-comment">// 左边最远</span><br>        <span class="hljs-type">int</span> right = minArr[i].second == target.<span class="hljs-built_in">size</span>() ? i : minArr[i].second - <span class="hljs-number">1</span>; <span class="hljs-comment">// 右边最远</span><br><br>        <span class="hljs-comment">// 计算子数组和</span><br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = left; j &lt;= right; ++j) &#123;<br>            sum += target[j];<br>        &#125;<br><br>        maxA = <span class="hljs-built_in">max</span>(maxA, sum * target[i]); <span class="hljs-comment">// 更新最大值</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> maxA;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="树型dp套路"><a href="#树型dp套路" class="headerlink" title="树型dp套路"></a>树型dp套路</h4><p>如果题目求解目标是S规则，则求解流程可以定成以每一个节点为头节点的子树在S规则下的每一个答案，并且答案一定在其中</p><h5 id="二叉树节点间的最大距离问题"><a href="#二叉树节点间的最大距离问题" class="headerlink" title="二叉树节点间的最大距离问题"></a>二叉树节点间的最大距离问题</h5><p>从二叉树的节点a出法，可以向上走或者向下走，但沿途的节点只能经过依次，到达节点b时路径上的节点个数叫做a到b的距离，求整颗树上的最大距离</p><p>常见分类：</p><p>1.头结点参与</p><p>2.头节点不参与</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReturnType</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> high;<br>    <span class="hljs-type">int</span> maxDistance;<br>    <span class="hljs-built_in">ReturnType</span>(<span class="hljs-type">int</span> high, <span class="hljs-type">int</span> maxDistance) : <span class="hljs-built_in">high</span>(high), <span class="hljs-built_in">maxDistance</span>(maxDistance) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    Node *left;<br>    Node *right;<br>    <span class="hljs-type">int</span> value;<br><br>    <span class="hljs-built_in">Node</span>() : <span class="hljs-built_in">value</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> : value(value), left(nullptr), right(nullptr) &#123;</span>&#125;<br><br>&#125;;<br><br><span class="hljs-comment">// 递归函数，返回节点的高度和最大距离</span><br><span class="hljs-function">ReturnType <span class="hljs-title">f</span><span class="hljs-params">(Node *head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">ReturnType</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    ReturnType left = <span class="hljs-built_in">f</span>(head-&gt;left);<br>    ReturnType right = <span class="hljs-built_in">f</span>(head-&gt;right);<br>    <span class="hljs-type">int</span> high = <span class="hljs-built_in">max</span>(left.high, right.high) + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> maxDistance = <span class="hljs-built_in">max</span>(left.high + right.high + <span class="hljs-number">2</span>, <span class="hljs-built_in">max</span>(left.maxDistance, right.maxDistance));<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ReturnType</span>(high, maxDistance);<br>&#125;<br><br><span class="hljs-comment">// 查找树的最大距离</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMaxDistance</span><span class="hljs-params">(Node *head)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(head).maxDistance;<br>&#125;<br><br><span class="hljs-comment">// 示例代码</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 构建示例二叉树</span><br>    Node *root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">1</span>);<br>    root-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">2</span>);<br>    root-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">3</span>);<br>    root-&gt;left-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">4</span>);<br>    root-&gt;left-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">5</span>);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;最大距离: &quot;</span> &lt;&lt; <span class="hljs-built_in">findMaxDistance</span>(root) &lt;&lt; endl;<br>    <br>    <span class="hljs-comment">// 释放内存</span><br>    <span class="hljs-keyword">delete</span> root-&gt;left-&gt;left;<br>    <span class="hljs-keyword">delete</span> root-&gt;left-&gt;right;<br>    <span class="hljs-keyword">delete</span> root-&gt;left;<br>    <span class="hljs-keyword">delete</span> root-&gt;right;<br>    <span class="hljs-keyword">delete</span> root;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//直接使用对象，避免处理内存泄漏问题</span><br></code></pre></td></tr></table></figure><p>树型dp第一步：</p><p>以某个节点X为头节点的子树中中，分析答案有那些可能性，并且这种分析是以X的左子树，X的右子树和X整棵树的角度来考虑可能性的</p><p>树型dp第二步：</p><p>根据第一步的可能性分析，列出所有需要的信息</p><p>树型dp第三步：</p><p>合并第二步的信息，对左树和右树提出同样的要求，并写出信息结构</p><p>树型dp第四步：</p><p>设计递归函数，递归函数是处理以X为头结点的情况下的答案，包括设计递归函数的basecase，默认直接得到左树和右树的所有信息，以及把可能性作整合，并且要返回第三步的信息结构</p><h5 id="派对的最大快乐值"><a href="#派对的最大快乐值" class="headerlink" title="派对的最大快乐值"></a>派对的最大快乐值</h5><p><img src="/images/2025-02-25-1.png" alt="2"></p><p>对头结点来说：</p><p>1.来的情况下最大快乐值&#x3D;自己+a不+b不+c不</p><p>2.不来的情况下最大快乐值&#x3D;max(a不+a来)+max(b不+b来)+max(c不+c来)</p><h5 id="Morris遍历"><a href="#Morris遍历" class="headerlink" title="Morris遍历"></a>Morris遍历</h5><p>一种遍历二叉树的方式，并且时间复杂度O(n)，额外空间复杂度O(1)</p><p>通过利用原树中大量空闲指针的方式，达到节省空间的目的</p><p><img src="/images/2025-02-25-2.png" alt="3"></p><p>一个节点有左树，一定有两次到达自己</p><p>实质：一直往左遍历，并将右边界指向自己保证有返回路径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">morris</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    Node* cur  = head;<br>    Node* mostRight = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span> (cur!=<span class="hljs-literal">nullptr</span>) &#123;<br>        mostRight = cur-&gt;left;<br>        <span class="hljs-keyword">if</span>(mostRight!=<span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">while</span> (mostRight-&gt;right!=<span class="hljs-literal">nullptr</span>&amp;&amp;mostRight-&gt;right!=cur) &#123;<br>                mostRight = mostRight-&gt;right;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(mostRight==<span class="hljs-literal">nullptr</span>) &#123;<br>                mostRight-&gt;right=cur;<br>                cur = cur-&gt;left;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                mostRight-&gt;right = <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>        &#125;<br>        cur = cur-&gt;right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="加工成先序遍历"><a href="#加工成先序遍历" class="headerlink" title="加工成先序遍历"></a>加工成先序遍历</h5><p>​          1</p><p>​     2         3</p><p>4      5   6     7</p><p><strong>morris</strong>:1,2,4,2,5,1,3,6,3,7</p><p><strong>先序：</strong>如果一个节点只能到达他一次直接打印，有两次就只打印第一次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">morris</span><span class="hljs-params">(Node *head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    Node *cur = head;<br>    Node *mostRight = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>        mostRight = cur-&gt;left;<br>        <span class="hljs-keyword">if</span> (mostRight != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">while</span> (mostRight-&gt;right != <span class="hljs-literal">nullptr</span> &amp;&amp; mostRight-&gt;right != cur) &#123;<br>                mostRight = mostRight-&gt;right;<br>            &#125;<br>            <span class="hljs-comment">//第一次</span><br>            <span class="hljs-keyword">if</span> (mostRight-&gt;right == <span class="hljs-literal">nullptr</span>) &#123;<br>                cout &lt;&lt;cur-&gt;value&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>                mostRight-&gt;right = cur;<br>                cur = cur-&gt;left;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//第二次</span><br>                mostRight-&gt;right = <span class="hljs-literal">nullptr</span>;<br>                cur = cur-&gt;right;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//第一次</span><br>            cout &lt;&lt;cur-&gt;value&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            cur = cur-&gt;right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>中序：</strong>如果一个节点只能到达他一次直接打印，有两次就只打印第二次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">morris</span><span class="hljs-params">(Node *head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    Node *cur = head;<br>    Node *mostRight = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>        mostRight = cur-&gt;left;<br>        <span class="hljs-keyword">if</span> (mostRight != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">while</span> (mostRight-&gt;right != <span class="hljs-literal">nullptr</span> &amp;&amp; mostRight-&gt;right != cur) &#123;<br>                mostRight = mostRight-&gt;right;<br>            &#125;<br>            <span class="hljs-comment">//第一次</span><br>            <span class="hljs-keyword">if</span> (mostRight-&gt;right == <span class="hljs-literal">nullptr</span>) &#123;<br>                mostRight-&gt;right = cur;<br>                cur = cur-&gt;left;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//第二次</span><br>                cout &lt;&lt;cur-&gt;value&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>                mostRight-&gt;right = <span class="hljs-literal">nullptr</span>;<br>                cur = cur-&gt;right;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//第一次</span><br>            cout &lt;&lt;cur-&gt;value&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            cur = cur-&gt;right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>后序：</strong>第二次回到自己逆序打印左树的右边界，最后单独逆序打印自己的右边界</p><p><strong>逆序打印右边界</strong>：单链表逆序操作</p><p><strong>搜索二叉树就可以用morris遍历省空间</strong></p><p>当设计的套路必须要做汇总信息也就是从左树右树得信息，在根据自己汇总，操作，那就需要二叉树递归遍历，如果不需要就可以用morris遍历</p><h4 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h4><p>1.哈希函数可以把数据按照种类均匀分流</p><p>2.布隆过滤器用于集合的建立与查询，并可以节省大量空间</p><p>3.一致性哈希解决数据服务器的负载管理问题</p><p>4.利用并查集结构做到的并行计算</p><p>5.位图解决某一个范围数字的出现情况，并可以节省大量空间</p><p>6.利用分段统计的思想，并金玉不节省大量空间</p><p>7.利用对，外排序来做多个处理单元的结果合并</p><h5 id="一个大范围的基本连续区域找没有出现的数字"><a href="#一个大范围的基本连续区域找没有出现的数字" class="headerlink" title="一个大范围的基本连续区域找没有出现的数字"></a>一个大范围的基本连续区域找没有出现的数字</h5><p>1.位图</p><p>2.将一个区间等分成一个个小区间，每一个范围的词频统计，如果某一个范围的词频统计不够，那么就以这个区间为大区间继续细分，逐渐定位</p><p>如果就我们就2个变量，那个就两个范围二分</p><h5 id="搜索词汇中top100"><a href="#搜索词汇中top100" class="headerlink" title="搜索词汇中top100"></a>搜索词汇中top100</h5><p>hash分流然后词频统计，然后将每个小文件的大根堆的堆顶做一个大堆，每次从总的里面弹一个，然后总堆再进一个源文件堆的堆顶</p><h5 id="大范围区域找出现了两次的数"><a href="#大范围区域找出现了两次的数" class="headerlink" title="大范围区域找出现了两次的数"></a>大范围区域找出现了两次的数</h5><p>1.hash函数分流</p><p>2.位图用两个位的信息来表示出现的次数  00：0次 01:1次 10:2次 11:2次以上</p><h5 id="大范围区域找中位数"><a href="#大范围区域找中位数" class="headerlink" title="大范围区域找中位数"></a>大范围区域找中位数</h5><p>范围统计的思想：哪一个范围让数字数量刚刚超过一半，循环操作</p><h5 id="大文件，将无序文件边有序"><a href="#大文件，将无序文件边有序" class="headerlink" title="大文件，将无序文件边有序"></a>大文件，将无序文件边有序</h5><p>将大文件对每一范围进行堆排序，将他放进文件</p><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><h5 id="不用比较判断链两个数的大小"><a href="#不用比较判断链两个数的大小" class="headerlink" title="不用比较判断链两个数的大小"></a>不用比较判断链两个数的大小</h5><h5 id="判断一个32位整数是不是2的幂，4的幂"><a href="#判断一个32位整数是不是2的幂，4的幂" class="headerlink" title="判断一个32位整数是不是2的幂，4的幂"></a>判断一个32位整数是不是2的幂，4的幂</h5><h5 id="不使用算术运算符，实现加减乘除（cpu"><a href="#不使用算术运算符，实现加减乘除（cpu" class="headerlink" title="不使用算术运算符，实现加减乘除（cpu)"></a>不使用算术运算符，实现加减乘除（cpu)</h5><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>暴力尝试-&gt;记忆化搜索-&gt;严格表结构</p><h5 id="机器人运动问题"><a href="#机器人运动问题" class="headerlink" title="机器人运动问题"></a>机器人运动问题</h5><p>有n个位置（1-N)，一个机器人停在s位置，要去往e位置，机器人必须走K步，机器人可以随意左右走，没有环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> N, <span class="hljs-type">int</span> E, <span class="hljs-type">int</span> rest, <span class="hljs-type">int</span> cur)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (rest == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> cur == E ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(N, E, rest - <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cur == N) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(N, E, rest - <span class="hljs-number">1</span>, N - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(N, E, rest - <span class="hljs-number">1</span>, cur - <span class="hljs-number">1</span>) + <span class="hljs-built_in">f</span>(N, E, rest - <span class="hljs-number">1</span>, cur + <span class="hljs-number">1</span>);<br>&#125;<br>时间复杂度：<span class="hljs-built_in">O</span>(<span class="hljs-number">2</span>^k)<br></code></pre></td></tr></table></figure><p>可变参数一旦确定返回值就确定</p><p>​            f(4,2)</p><p>​        f(3,1)    f(3,3)</p><p>   f(2,2)     f(2,2)   f(2,4)</p><p>。。。。。。。。。。。。</p><p>会有很多重复的过程</p><p>是不是可变参数一旦固定，那么不管谁调用的函数过程都一样，如果是，那么这样的尝试叫做无后效性的尝试</p><h5 id="如何实现记忆化搜索"><a href="#如何实现记忆化搜索" class="headerlink" title="如何实现记忆化搜索"></a>如何实现记忆化搜索</h5><p>缓存已经出现的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-type">int</span> N, <span class="hljs-type">int</span> E, <span class="hljs-type">int</span> rest, <span class="hljs-type">int</span> cur, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; dp)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (dp[rest][cur] != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> dp[rest][cur];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (rest == <span class="hljs-number">0</span>) &#123;<br>        dp[rest][cur] = cur == E ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> dp[rest][cur];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">1</span>) &#123;<br>        dp[rest][cur] = <span class="hljs-built_in">f</span>(N, E, rest - <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur == N) &#123;<br>        dp[rest][cur] = <span class="hljs-built_in">f</span>(N, E, rest - <span class="hljs-number">1</span>, N - <span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        dp[rest][cur] = <span class="hljs-built_in">f</span>(N, E, rest - <span class="hljs-number">1</span>, cur - <span class="hljs-number">1</span>) + <span class="hljs-built_in">f</span>(N, E, rest - <span class="hljs-number">1</span>, cur + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[rest][cur];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">way2</span><span class="hljs-params">(<span class="hljs-type">int</span> N, <span class="hljs-type">int</span> E, <span class="hljs-type">int</span> rest, <span class="hljs-type">int</span> cur)</span> </span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">dp</span>(rest + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(N + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">f2</span>(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, dp);<br>&#125;<br>时间复杂度：<span class="hljs-built_in">O</span>(K*N)<br></code></pre></td></tr></table></figure><p><img src="/images/2025-02-26-3.png" alt="3"></p><h5 id="硬币数组"><a href="#硬币数组" class="headerlink" title="硬币数组"></a>硬币数组</h5><p>正数数组，有重复值，每一个代表一枚硬币的面值，如何用最少的组合刚好达到给定面值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ff</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; coins, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> rest)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (rest &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (rest == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (index == coins.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> p1 = <span class="hljs-built_in">ff</span>(coins, index + <span class="hljs-number">1</span>, rest);<br>    <span class="hljs-type">int</span> p2 = <span class="hljs-built_in">ff</span>(coins, index + <span class="hljs-number">1</span>, rest - coins[index]) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (p1 == <span class="hljs-number">-1</span> &amp;&amp; p2 == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (p1 == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">return</span> p2;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p2 == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">return</span> p1;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(p1, p2);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMinCoin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; coins, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ff</span>(coins, <span class="hljs-number">0</span>, target);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>改记忆化搜索：</strong></p><p>加vector&lt;unordered_map&lt;int,int&gt;&gt; dp;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 记忆化搜索 + unordered_map</span><br>vector&lt;unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; dp; <span class="hljs-comment">// dp[index][rest] 只存实际访问的状态</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ff</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> rest)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (rest &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;   <span class="hljs-comment">// 无效情况</span><br>    <span class="hljs-keyword">if</span> (rest == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <span class="hljs-comment">// 正好凑齐，不需要硬币</span><br>    <span class="hljs-keyword">if</span> (index == coins.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 没有硬币可选</span><br><br>    <span class="hljs-keyword">if</span> (dp[index].<span class="hljs-built_in">count</span>(rest)) <span class="hljs-keyword">return</span> dp[index][rest]; <span class="hljs-comment">// 记忆化剪枝</span><br>    <br>    <span class="hljs-type">int</span> p1 = <span class="hljs-built_in">ff</span>(coins, index + <span class="hljs-number">1</span>, rest); <span class="hljs-comment">// 不选当前硬币</span><br>    <span class="hljs-type">int</span> p2 = <span class="hljs-built_in">ff</span>(coins, index + <span class="hljs-number">1</span>, rest - coins[index]); <span class="hljs-comment">// 选当前硬币</span><br>    <span class="hljs-keyword">if</span> (p2 != <span class="hljs-number">-1</span>) p2 += <span class="hljs-number">1</span>; <span class="hljs-comment">// 如果 p2 有解，加 1</span><br>    <br>    <span class="hljs-keyword">if</span> (p1 == <span class="hljs-number">-1</span> &amp;&amp; p2 == <span class="hljs-number">-1</span>) &#123;<br>        dp[index][rest] = <span class="hljs-number">-1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p1 == <span class="hljs-number">-1</span>) &#123;<br>        dp[index][rest] = p2;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p2 == <span class="hljs-number">-1</span>) &#123;<br>        dp[index][rest] = p1;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        dp[index][rest] = <span class="hljs-built_in">min</span>(p1, p2);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[index][rest];<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMinCoin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    dp = vector&lt;unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;(coins.<span class="hljs-built_in">size</span>()); <span class="hljs-comment">// 初始化 dp</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ff</span>(coins, <span class="hljs-number">0</span>, target);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; coins = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span> target = <span class="hljs-number">10000</span>; <span class="hljs-comment">// 目标金额很大</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">getMinCoin</span>(coins, target);<br>    cout &lt;&lt; <span class="hljs-string">&quot;最少需要 &quot;</span> &lt;&lt; (result == <span class="hljs-number">-1</span> ? <span class="hljs-string">&quot;无法组成&quot;</span> : <span class="hljs-built_in">to_string</span>(result) + <span class="hljs-string">&quot; 枚硬币&quot;</span>) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>做表</strong></p><p>递归函数怎么调的，格子就怎么取值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMinCoin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;coins, <span class="hljs-type">int</span> aim)</span> </span>&#123;<br>    <span class="hljs-type">int</span> N = coins.<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">dp</span>(N + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(aim + <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> row = <span class="hljs-number">0</span>; row &lt;= N; ++row) &#123;<br>        dp[row][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> col = <span class="hljs-number">0</span>; col &lt;= aim; ++col) &#123;<br>        dp[N][col] = <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> index = N - <span class="hljs-number">1</span>; index &gt;= <span class="hljs-number">0</span>; index--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> rest = <span class="hljs-number">1</span>; rest &lt;= aim; rest++) &#123;<br>            <span class="hljs-type">int</span> p1 = dp[index + <span class="hljs-number">1</span>][rest];<br>            <span class="hljs-type">int</span> p2Next = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">if</span> (rest - coins[index] &gt;= <span class="hljs-number">0</span>) &#123;<br>                p2Next = dp[index + <span class="hljs-number">1</span>][rest - coins[index]];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (p1 == <span class="hljs-number">-1</span> &amp;&amp; p2Next == <span class="hljs-number">-1</span>) &#123;<br>                dp[index][rest] = <span class="hljs-number">-1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (p1 == <span class="hljs-number">-1</span>) &#123;<br>                    dp[index][rest] = p2Next + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p2Next == <span class="hljs-number">-1</span>) &#123;<br>                    dp[index][rest] = p1;<br>                &#125;<br>                dp[index][rest] = <span class="hljs-built_in">min</span>(p1, p2Next);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][aim];<br>&#125;<br></code></pre></td></tr></table></figure><p>1.分析可变参数的变化范围</p><p>2.标出计算的终止位置</p><p>3.根据basecase得到一些确定的值</p><p>4.看某一个普遍位置依赖于其他哪些位置</p><p>5.确定依次计算的顺序</p><h5 id="博弈问题-1"><a href="#博弈问题-1" class="headerlink" title="博弈问题"></a>博弈问题</h5><p><strong>范围上尝试</strong>，左下半区一律无效</p><p>f的对角线求s的对角线的上一条，s的对角线求f对角线的上一条</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">s</span>(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        f[i][i] = arr[i];<br>    &#125;<br>    <span class="hljs-type">int</span> row = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> col = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (col&lt;n) &#123;<br>        <span class="hljs-type">int</span> i = row;<br>        <span class="hljs-type">int</span> j = col;<br>        <span class="hljs-keyword">while</span> (i&lt;n&amp;&amp;j&lt;n) &#123;<br>            f[i][j] = <span class="hljs-built_in">max</span>(arr[i]+s[i<span class="hljs-number">+1</span>][j],arr[j]+s[i][j<span class="hljs-number">-1</span>]);<br>            s[i][j] = <span class="hljs-built_in">min</span>(f[i<span class="hljs-number">+1</span>][j],f[i][j<span class="hljs-number">-1</span>]);<br>            i++;<br>            j++;<br>        &#125;<br>        col++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(f[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>],s[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="象棋棋盘"><a href="#象棋棋盘" class="headerlink" title="象棋棋盘"></a>象棋棋盘</h5><p>横9纵10，马在(0,0)，马要去(a,b)，如何用k步跳到(a,b)</p><p>三维表格 step只依赖step-1层，同层无影响</p><h5 id="网格选择"><a href="#网格选择" class="headerlink" title="网格选择"></a>网格选择</h5><p>给一个行数，列数，(N,M)，一个人在(a,b)(可能在外面)，这个人上下左右四个方向走K步，一旦越界认为人死了，请求活下来走的选择</p><h5 id="面值凑钱"><a href="#面值凑钱" class="headerlink" title="面值凑钱"></a>面值凑钱</h5><p>给定几种面值（不限额），请给出凑出给定数额的方法数</p><p>从index&#x3D;0开始对每张面值进行选择</p><p>做表的时候每一行依赖于下一行</p><p>而每一行可以从前面已经搞过的东西加上下面的东西来计算（优化）</p><p>斜率优化：当计算某个数的时候，有枚举行为，那么可以用临近的位置计算</p><h5 id="尝试的方式"><a href="#尝试的方式" class="headerlink" title="尝试的方式"></a>尝试的方式</h5><p>1.尝试的可变参数自己的维度，指的是参数的类型，最好就是整型</p><p>2.可变参数的个数</p><h4 id="有序表"><a href="#有序表" class="headerlink" title="有序表"></a>有序表</h4><h5 id="有序表-1"><a href="#有序表-1" class="headerlink" title="有序表"></a>有序表</h5><p>有序组织key</p><p>使用时认为增删改查都是logn操作</p><p>放入有序表中的自定义结构，必须要有比较器</p><p>时间复杂度O(logn)</p><p>底层原理： 红黑树 AVL树 SB树（平衡搜索二叉树）         跳表（链表）</p><p>一般默认搜索二叉树没有重复项（可以压缩信息将重复项合并）</p><p>搜索二叉树的查找，增加，删除</p><p>何为具有平衡性的树，左右子树高度平衡</p><p>树的左旋，头结点导向左边</p><p>数的右旋，头结点导向右边</p><p>三种平衡搜索二叉树对平衡的定义不同</p><h5 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h5><p>是最严格的平衡搜索二叉树，左右子树高度差不超过1</p><p><strong>怎么查不平衡</strong></p><p>当加入（删除）某个节点，从这个节点开始往上每个节点都查找平衡性</p><p><strong>不平衡的情形</strong></p><p>LL情形（右旋）  RR情形（左旋） LR情形(左旋后右旋)    RL情形(右旋后左旋)</p><h5 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h5><p>区别：平衡性标准不同，由于平衡性标准不同导致维持的信息不同</p><p>1.每一个节点不是红就是黑</p><p>2.叶节点指的是最底层的空节点，头节点和叶节点是黑</p><p>3.任何两个红节点不能相邻</p><p>4.从cur出发到叶节点的每一条路径黑节点数量相同</p><p>保证了头结点之下的任意路径长度没有到两倍以上</p><h5 id="Size-Balanced"><a href="#Size-Balanced" class="headerlink" title="Size-Balanced"></a><strong>Size-Balanced</strong></h5><p>每一个子树的大小，不小于其兄弟的子树大小</p><p>即每棵叔叔数大小，不小于其任何侄子树的大小</p><p><strong>不平衡的情形</strong></p><p>LL情形(右旋，谁的孩子节点变化了自己递归)</p><p>RR情形(左旋，谁的孩子节点变化了自己递归)</p><p>LR情形(左旋后右旋，谁的孩子节点变化了自己递归)</p><p>RL情形(右旋后左旋，谁的孩子节点变化了自己递归)</p><h5 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h5><p>有一个默认节点，拥有排序上最低的key，指针指向空</p><p>某一个节点初始有1个指针，再随机几个next指针（0.5概率加一层）</p><p>默认节点永远跟着指针数量的最大值扩冲</p><p>永远从最高层节点开始，找到小于等于他的最小节点，如果这层没有他，向下走，继续查，循环走</p><p>原理就是利用高度跳过了很多查找</p><p><strong>感觉像是高层就是下层的索引，加速查找</strong></p><p><strong>不取决于用户的数据状况，依靠概率建立一颗近似的满二叉树</strong></p><h3 id="刷题系列"><a href="#刷题系列" class="headerlink" title="刷题系列"></a>刷题系列</h3><h5 id="窗口模型：构造左边界与右边界不需回退，双指针"><a href="#窗口模型：构造左边界与右边界不需回退，双指针" class="headerlink" title="窗口模型：构造左边界与右边界不需回退，双指针"></a>窗口模型：构造左边界与右边界不需回退，双指针</h5><p>绳子上有arr[]这些个点，用L长的绳子去覆盖他最多能覆盖多少个点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMaxPoint</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> L)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (arr.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> maxCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.<span class="hljs-built_in">size</span>(); ++j) &#123;<br>        <span class="hljs-keyword">while</span> (arr[j] - arr[i] &gt; L) &#123;<br>            i++;<br>        &#125;<br>        maxCount = <span class="hljs-built_in">max</span>(maxCount, j - i + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxCount;<br>&#125;<br></code></pre></td></tr></table></figure><p>买苹果只能买6个和8个，能买下返回最少得袋数，买不下就是-1</p><p>这个尝试的方法只有num一个变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getApple</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getApple</span>(num - <span class="hljs-number">8</span>) == <span class="hljs-number">-1</span> &amp;&amp; <span class="hljs-built_in">getApple</span>(num - <span class="hljs-number">6</span>) == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getApple</span>(num - <span class="hljs-number">8</span>) == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getApple</span>(num - <span class="hljs-number">6</span>) + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getApple</span>(num - <span class="hljs-number">6</span>) == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getApple</span>(num - <span class="hljs-number">8</span>) + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(<span class="hljs-built_in">getApple</span>(num - <span class="hljs-number">6</span>), <span class="hljs-built_in">getApple</span>(num - <span class="hljs-number">8</span>)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="打表法"><a href="#打表法" class="headerlink" title="打表法"></a>打表法</h5><p>输入输出比较简单</p><p>也可以用硬币的方法，就是对6枚举，和对8枚举</p><p>从这个方法可以引申一个数学方法：先对最大的面值试，从多的往下试，试出成功那就是结果，无非就是尽量使用8类型的袋子</p><p>再次优化：不必要试所有可能性，用数学的方法排除</p><p>比如：107个苹果   </p><p>8*13剩3个    </p><p>8*12剩11个 </p><p>8*11剩19个 </p><p>8*10剩27个   27&#x3D;24+3</p><p>当剩余的大于24后就不用试了，24是6和8的最大公倍数，因为如果有24的话为什么不用3个8呢</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minBagBase6</span><span class="hljs-params">(<span class="hljs-type">int</span> rest)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> rest % <span class="hljs-number">6</span> == <span class="hljs-number">0</span> ? (rest / <span class="hljs-number">6</span>) : <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minBags</span><span class="hljs-params">(<span class="hljs-type">int</span> apple)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (apple &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> bag6 = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> bag8 = apple / <span class="hljs-number">8</span>;<br>    <span class="hljs-type">int</span> rest = apple - <span class="hljs-number">8</span> * bag8;<br>    <span class="hljs-keyword">while</span> (bag8 &gt;= <span class="hljs-number">0</span> &amp; rest &lt; <span class="hljs-number">24</span>) &#123;<br>        <span class="hljs-type">int</span> restUse6 = <span class="hljs-built_in">minBagBase6</span>(rest);<br>        <span class="hljs-keyword">if</span> (restUse6 != <span class="hljs-number">-1</span>) &#123;<br>            bag6 = restUse6;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        rest = apple - <span class="hljs-number">8</span> * (--bag8);<br>    &#125;<br>    <span class="hljs-keyword">return</span> bag6 == <span class="hljs-number">-1</span> ? <span class="hljs-number">-1</span> : bag6 + bag8;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我发现入参是整数，出参是整数，那么就用最傻的办法写出答案，然后打表找规律、</p><h5 id="牛吃草"><a href="#牛吃草" class="headerlink" title="牛吃草"></a>牛吃草</h5><p>有先手和后手两个人吃草，都只能吃4的N次方个草（不能不吃），给定N，请返回谁赢</p><p>仅考虑先手，然后对依次草个数减判断是否成功（因为后手和先手是一种操作，只有返回结果不同）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findWinCao</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">//0  1</span><br>    <span class="hljs-comment">//后 先</span><br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> base = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (base &lt;= n) &#123;<br>        <span class="hljs-comment">//母过程 先手 子过程是后手</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">findWinCao</span>(n - base)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (base &gt; n / <span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        base *= <span class="hljs-number">4</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>打表总结规律</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">findWincao2</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">5</span> == <span class="hljs-number">0</span> || n % <span class="hljs-number">5</span> == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;后手&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;先手&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="预处理技巧"><a href="#预处理技巧" class="headerlink" title="预处理技巧"></a>预处理技巧</h5><p>指的是查询的操作大量重复，能不能以空间换时间的方法优化这个操作</p><p>RG随机排列，想让每个R在G左侧（也就是左边全是R，右边全是G)，最小次数满足</p><p>枚举左侧部分大小L，对arr[0…L]，统计一共有多少个G，全部染成R，对arr[L+1…N-1]一共有多少个R，全部染成G</p><p>生成一个辅助数组，计算0-i上的G数量和i-N-1的R数量</p><h5 id="0-1矩阵内正方形矩阵（边框全是1-个数"><a href="#0-1矩阵内正方形矩阵（边框全是1-个数" class="headerlink" title="0,1矩阵内正方形矩阵（边框全是1)个数"></a>0,1矩阵内正方形矩阵（边框全是1)个数</h5><p>n*n的矩阵，内小矩阵有N^4规模，正方形n^3规模</p><p>枚举左上角的点，再枚举边长</p><p>生成一个right和down数组，计算连续的1的个数</p><h5 id="等概率发生器"><a href="#等概率发生器" class="headerlink" title="等概率发生器"></a>等概率发生器</h5><p>就是把元范围做成01生成器，切成两等分（多的不要重做），再根据范围（改成0-N)判断所需要的二进制位数，揉几次得出0-N的数，如果超出重做6</p><h5 id="非负整数N得到二叉树种类"><a href="#非负整数N得到二叉树种类" class="headerlink" title="非负整数N得到二叉树种类"></a>非负整数N得到二叉树种类</h5><p>对N个节点，0为0，1为1，大于1枚举左右子树节点个数种类相乘</p><h5 id="括号匹配问题"><a href="#括号匹配问题" class="headerlink" title="括号匹配问题"></a>括号匹配问题</h5><p>设置一个cnt，左括号cnt++，右括号cnt–，cnt&lt;0不合法，结束是cnt!&#x3D;0不合法</p><h5 id="求差值为k的数值对（不重复统计）"><a href="#求差值为k的数值对（不重复统计）" class="headerlink" title="求差值为k的数值对（不重复统计）"></a>求差值为k的数值对（不重复统计）</h5><p>两数之和，只找一边就不会有重复s</p><h5 id="将a集合的数拿到b集合里面，使两个数组的平均值都增大"><a href="#将a集合的数拿到b集合里面，使两个数组的平均值都增大" class="headerlink" title="将a集合的数拿到b集合里面，使两个数组的平均值都增大"></a>将a集合的数拿到b集合里面，使两个数组的平均值都增大</h5><p>能拿的数字是平均值大的数拿到平均值小的数，满足要求的数字拿那个?   拿最小的数（贪心）</p><p>coding技巧，用double类型或者(a + b - 1) &#x2F; b; &#x2F;&#x2F; 向上取整 避免精度损失</p><h5 id="面对子序列的问题（连续）可以将求以每个位置结尾，不连续也行"><a href="#面对子序列的问题（连续）可以将求以每个位置结尾，不连续也行" class="headerlink" title="面对子序列的问题（连续）可以将求以每个位置结尾，不连续也行"></a>面对子序列的问题（连续）可以将求以每个位置结尾，不连续也行</h5>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高并发服务器</title>
    <link href="/2025/02/14/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2025/02/14/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>技术</title>
    <link href="/2025/02/14/%E6%8A%80%E6%9C%AF/"/>
    <url>/2025/02/14/%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="1-弹性计算服务（ECS）"><a href="#1-弹性计算服务（ECS）" class="headerlink" title="1. 弹性计算服务（ECS）"></a><strong>1. 弹性计算服务（ECS）</strong></h3><ul><li><strong>技术亮点</strong>：弹性扩展、按需付费、支持多种实例类型（通用型、计算优化型、GPU&#x2F;FPGA等）。</li><li><strong>热门场景</strong>：企业上云、高并发业务（如电商大促）、游戏服务器、科学计算。</li><li><strong>相关产品</strong>：<strong>神龙架构</strong>（软硬一体的虚拟化技术）、弹性裸金属服务器（EBM）、弹性容器实例（ECI）。</li></ul><hr><h3 id="2-容器与云原生技术"><a href="#2-容器与云原生技术" class="headerlink" title="2. 容器与云原生技术"></a><strong>2. 容器与云原生技术</strong></h3><ul><li><strong>核心产品</strong>：<strong>容器服务 Kubernetes 版（ACK）</strong><ul><li><strong>优势</strong>：支持混合云部署、Serverless 容器（ASK）、与阿里云生态深度集成。</li><li><strong>热门应用</strong>：微服务架构、CI&#x2F;CD 流水线、AI 模型训练与推理。</li></ul></li><li><strong>其他技术</strong>：<strong>Service Mesh（ASM）</strong>、Serverless 应用引擎（SAE）。</li></ul><hr><h3 id="3-云原生数据库"><a href="#3-云原生数据库" class="headerlink" title="3. 云原生数据库"></a><strong>3. 云原生数据库</strong></h3><ul><li><strong>PolarDB</strong>（云原生关系型数据库）：<ul><li><strong>特点</strong>：100% 兼容 MySQL&#x2F;PostgreSQL，存储与计算分离，性能是传统 MySQL 的 6 倍。</li><li><strong>适用场景</strong>：高并发 OLTP、企业级核心业务系统。</li></ul></li><li><strong>AnalyticDB</strong>（实时数仓）：<ul><li><strong>优势</strong>：PB 级数据分析秒级响应，支持实时数据湖分析。</li><li><strong>对标技术</strong>：Snowflake、ClickHouse。</li></ul></li></ul><hr><h3 id="4-人工智能与机器学习"><a href="#4-人工智能与机器学习" class="headerlink" title="4. 人工智能与机器学习"></a><strong>4. 人工智能与机器学习</strong></h3><ul><li><strong>机器学习平台 PAI</strong>：<ul><li>提供从模型开发、训练到部署的全流程工具，支持视觉、NLP、推荐系统等场景。</li><li><strong>典型案例</strong>：双 11 商品推荐、工业质检、城市大脑。</li></ul></li><li><strong>通义大模型</strong>：<ul><li>阿里自研的生成式 AI 模型，已集成到阿里云产品中（如智能客服、文档分析）。</li></ul></li></ul><hr><h3 id="5-大数据与实时计算"><a href="#5-大数据与实时计算" class="headerlink" title="5. 大数据与实时计算"></a><strong>5. 大数据与实时计算</strong></h3><ul><li><strong>实时计算 Flink 版</strong>：<ul><li>阿里内部双 11 实时大屏的核心技术，支持毫秒级流数据处理。</li></ul></li><li><strong>MaxCompute</strong>（原 ODPS）：<ul><li>企业级大数据计算平台，支撑 EB 级数据仓库，成本比自建 Hadoop 低 50%。</li></ul></li></ul><hr><h3 id="6-无服务器计算（Serverless）"><a href="#6-无服务器计算（Serverless）" class="headerlink" title="6. 无服务器计算（Serverless）"></a><strong>6. 无服务器计算（Serverless）</strong></h3><ul><li><strong>函数计算 FC</strong>：<ul><li>事件驱动的无服务器架构，支持毫秒级资源弹性，按实际调用次数计费。</li><li><strong>典型场景</strong>：文件处理、API 后端、IoT 数据处理。</li></ul></li><li><strong>Serverless 应用引擎（SAE）</strong>：专注于微服务应用的 Serverless 化。</li></ul><hr><h3 id="7-物联网（IoT）与边缘计算"><a href="#7-物联网（IoT）与边缘计算" class="headerlink" title="7. 物联网（IoT）与边缘计算"></a><strong>7. 物联网（IoT）与边缘计算</strong></h3><ul><li><strong>阿里云 IoT 平台</strong>：<ul><li>提供设备接入、数据管理、AI 边缘计算（Link IoT Edge）一体化服务。</li><li><strong>热门行业</strong>：智能制造、智慧城市、能源管理。</li></ul></li><li><strong>边缘计算节点（ENS）</strong>：低延迟数据处理，支持 CDN、云游戏等场景。</li></ul><hr><h3 id="8-云安全与合规"><a href="#8-云安全与合规" class="headerlink" title="8. 云安全与合规"></a><strong>8. 云安全与合规</strong></h3><ul><li><strong>云安全中心</strong>：<ul><li>整合漏洞扫描、入侵检测、日志审计等功能，提供一站式安全防护。</li></ul></li><li><strong>Web 应用防火墙（WAF）</strong>：<ul><li>防御 SQL 注入、CC 攻击等，保障 Web 应用安全。</li></ul></li></ul><hr><h3 id="9-混合云与专有云"><a href="#9-混合云与专有云" class="headerlink" title="9. 混合云与专有云"></a><strong>9. 混合云与专有云</strong></h3><ul><li><strong>Apsara Stack</strong>：<ul><li>阿里云专有云解决方案，满足金融、政务等行业的合规需求。</li></ul></li><li><strong>云企业网（CEN）</strong>：实现跨地域、跨云的多网络互联。</li></ul><hr><h3 id="10-音视频与-CDN"><a href="#10-音视频与-CDN" class="headerlink" title="10. 音视频与 CDN"></a><strong>10. 音视频与 CDN</strong></h3><ul><li><strong>视频直播&#x2F;点播服务</strong>：<ul><li>支持 4K&#x2F;8K 超高清、低延迟直播，覆盖全球 3000+ 节点。</li></ul></li><li><strong>全站加速（DCDN）</strong>：<ul><li>动静内容智能分发，优化电商、在线教育等场景的用户体验。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>aliyun</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024-12-17</title>
    <link href="/2024/12/17/2024-12-17/"/>
    <url>/2024/12/17/2024-12-17/</url>
    
    <content type="html"><![CDATA[<h2 id="2024-12-17"><a href="#2024-12-17" class="headerlink" title="2024-12-17"></a>2024-12-17</h2><h4 id="NAT模式连接原理"><a href="#NAT模式连接原理" class="headerlink" title="NAT模式连接原理"></a>NAT模式连接原理</h4><p><img src="/images/2024-12-17-1.png" alt="NAT模式连接原理"></p><p>修改虚拟网段，虚拟网络编辑器</p><p>查看网关，vmnet8</p><h4 id="网络环境配置"><a href="#网络环境配置" class="headerlink" title="网络环境配置"></a>网络环境配置</h4><p>自动获取：首选项，网络，自动连接</p><p>手动获取：script（脚本）</p><p>vim  etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33(ens33网卡)</p><p><img src="/images/2024-12-17-2.png" alt="2"></p><h4 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h4><p>每个执行的程序称为一个进程，每个进程都分配一个ID号</p><p>每一个进程，都对应一个父进程，而这个父进程可以复制多个子进程</p><p>每个进程都可能以两种方式存在，前台与后台</p><p>一般系统的服务都以后台进程形式存在，而且都会常驻系统中，直到关机才结束</p><h5 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h5><p><strong>ps</strong>命令查看系统进程 -a 所有进程 -u以用户格式显示进程信息 -x显示后台进程运行参数</p><p><strong>ps -aux</strong></p><p><img src="/images/2024-12-17-3.png" alt="3"></p><p>ps-aux | grep xxx 过滤指令，将显示的内容进行过滤</p><p>查看父进程 ps -ef  PPID就是父进程</p><p>pstree 树状形式查看 -p显示pid -u显示所属用户</p><h5 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h5><p>kill [选项] 进程号   -9表示强制进程停止</p><p>killall 进程名称  支持通配符</p><p>1.踢掉jack的非法登录</p><p>ps -aux | grep sshd  找到进程号</p><p>kill 进程号</p><p>2.终止远程登录sshd</p><p>kill 进程号</p><p>3.终止多个gedit编辑器</p><p>killall gedit</p><p>4.强制关闭一个终端</p><p>ps -aux | grep bash</p><p>kill -9 进程号</p><h4 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h4><p>服务本质就是进程，但是运行在后台，通常会监听某个端口，等待其他程序的请求</p><p>systemctl&#x2F;service 服务名 [start|stop|restart|reload|status]  只是临时生效，重启系统后会恢复</p><p>telnet ip 端口 查看某个ip的某个端口是否打开</p><h5 id="查看服务"><a href="#查看服务" class="headerlink" title="查看服务"></a>查看服务</h5><p>1.使用setup 系统服务 就可以看到</p><p>2..&#x2F;etc&#x2F;init.d&#x2F;服务名称</p><h4 id="动态监控"><a href="#动态监控" class="headerlink" title="动态监控"></a>动态监控</h4><h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a><strong>进程</strong></h5><p><strong>top</strong>  -u监控某个user k杀死某个进程 -d多少秒刷新</p><p><img src="/images/2024-12-17-4.png" alt="4"></p><h5 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h5><p>netstat 查看网络服务</p><p>netstat -anp 查看所有的网络服务</p><p>netstat -anp | grep sshd</p><h4 id="RPM和YUM"><a href="#RPM和YUM" class="headerlink" title="RPM和YUM"></a>RPM和YUM</h4><p>rpm用户互联网下载包的打包和管理工具</p><p>rpm -qa | grep firfox  查看安装的包  </p><p><img src="/images/2024-12-17-5.png" alt="5"></p><p>rpm -qi firefox  具体信息</p><p>rpm -ql firefox 安装了哪些文件</p><p>rpm -qf &#x2F;etc&#x2F;passwd 文件全路径名  查询文件所属的软件包</p><p>rpm -e firefox 卸载软件包  </p><p>rpm -ivh RPM包全路径 安装软件</p><p><img src="/images/2024-12-17-6.png" alt="6"></p><p>yum是一个shell前端软件管理器，基于RPM包管理，能够从指定的服务器下载rpm包并进行安装，可以自动处理依赖关系，并安装所有依赖的软件包，前提是可以联网</p><p>yum list | grep xx  查看是否有需要安装的软件</p><p>yum install xxx 默认安装最新版本</p><h3 id="shell编程"><a href="#shell编程" class="headerlink" title="shell编程"></a>shell编程</h3><p>shell是命令行解释器，为用户提供了一个可以向linux内核发送请求以便运行程序的界面系统级程序，用户可以用shell启动，挂起，停止甚至是编写一些程序</p><h4 id="脚本格式"><a href="#脚本格式" class="headerlink" title="脚本格式"></a>脚本格式</h4><p>1.脚本一#!bin&#x2F;bash开头</p><p>2.脚本需要有可执行权限</p><h4 id="编写第一个shell脚本"><a href="#编写第一个shell脚本" class="headerlink" title="编写第一个shell脚本"></a>编写第一个shell脚本</h4><p>1.vim myshell.sh</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello,world!&quot;</span>   <span class="hljs-comment">#它是解释</span><br><span class="hljs-comment">#多行注释</span><br>:&lt;&lt;!<br><span class="hljs-comment">#内容</span><br>!<br></code></pre></td></tr></table></figure><p>2.给所有者一个执行权限</p><p>chmod 744 myshell.sh</p><p>3.执行</p><p>.&#x2F;myshell.sh  &#x2F;&#x2F;相对路径</p><p>&#x2F;root&#x2F;shell&#x2F;myshell.sh  &#x2F;&#x2F;绝对路径</p><p>(如果不给可执行权限，也可以直接用 sh .&#x2F;myshell.sh，但是不推荐)</p><h4 id="shell的变量"><a href="#shell的变量" class="headerlink" title="shell的变量"></a>shell的变量</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>1.变量分为系统变量和用户自定义变量</p><p>2.系统变量有：$HOME $PWD $SHELL $USER</p><p>3.显示shell中所有变量set</p><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>1.定义变量</p><p>A&#x3D;100  echo “A&#x3D;$A”</p><p>2.销毁变量</p><p>unset A echo “A&#x3D;$A”</p><p>3.静态变量，不能unset</p><p>readonly A&#x3D;99</p><h5 id="变量定义规则"><a href="#变量定义规则" class="headerlink" title="变量定义规则"></a>变量定义规则</h5><p>1.变量名称可以有字母，数字，下划线开头，但是不能以数字开头</p><p>2.等号两侧不能有空格</p><p>3.变量名称一般用大写</p><p>4.使用&#96;&#96;将命令括起来或者用$()，可以得到命令的结果为变量</p><h5 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h5><p><img src="/images/2024-12-17-7.png" alt="7"></p><p>vim &#x2F;etc&#x2F;profile</p><p>TOMCAT_HOME&#x3D;&#x2F;opt&#x2F;tomcat</p><p>export TOMCAT_HOME</p><p>注意：在输出之前，需要让其生效</p><p>source  &#x2F;etc&#x2F;profile</p><h5 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h5><p>当我们执行一个shell脚本时，如果希望获取到命令行的参数信息，就可以使用到为止参数变量，比如：.&#x2F;myshell.sh 100 200 , 这个就是一个执行shell的命令行，可以从myshell脚本中获取到参数信息</p><p>$n(n为数字，$0代表命令本身 $1-$9代表第一到第九个参数，十以上的参数需要用大括号包含，如${10})</p><p>$*(代表命令行中的所有参数，把所有参数看做一个整体)</p><p>$@(也代表命令行中所有的参数，不过他把每个参数去区分对待)</p><p>$#(代表命令行中参数的个数)</p><h5 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h5><p>$$(当前进程的进程号PID)</p><p>$!(后台运行的最后一个进程的进程号)</p><p>$?(最后一次执行命令的返回状态，如果这个变量的值为0，证明上一个命令正确执行，如果这个变量的值为非0，具体那个数由命令自己来决定，则证明上一个命令执行不正确)</p><p><img src="/images/2024-12-17-8.png" alt="8"></p><h4 id="shell运算符"><a href="#shell运算符" class="headerlink" title="shell运算符"></a>shell运算符</h4><p>1.$()  RESURT1&#x3D;$(((2+3)*4))</p><p>2.$[]  RESURT2&#x3D;$[(2+3)*4]</p><p>3.expr </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">TEMP=`expr 2 + 3`<br>RESURT3=`expr $TEMP \* 4`<br>echo &quot;RESURT3=$RESULT&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">这种才要给空格，另外两个不要给空格</span><br></code></pre></td></tr></table></figure><h4 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h4><p>[ condition ]   (注意condition前后要有空格)</p><h5 id="1-文件属性判断"><a href="#1-文件属性判断" class="headerlink" title="1. 文件属性判断"></a><strong>1. 文件属性判断</strong></h5><p>使用 <code>test</code> 命令或者 <code>[ ]</code> 表达式来判断文件的状态。</p><table><thead><tr><th>条件</th><th>含义</th></tr></thead><tbody><tr><td><code>-e file</code></td><td>文件存在</td></tr><tr><td><code>-f file</code></td><td>文件存在且是普通文件</td></tr><tr><td><code>-d file</code></td><td>文件存在且是目录</td></tr><tr><td><code>-r file</code></td><td>文件存在且可读</td></tr><tr><td><code>-w file</code></td><td>文件存在且可写</td></tr><tr><td><code>-x file</code></td><td>文件存在且可执行</td></tr><tr><td><code>-s file</code></td><td>文件存在且非空</td></tr><tr><td><code>file1 -nt file2</code></td><td><code>file1</code> 比 <code>file2</code> 更新</td></tr><tr><td><code>file1 -ot file2</code></td><td><code>file1</code> 比 <code>file2</code> 更旧</td></tr><tr><td><code>file1 -ef file2</code></td><td><code>file1</code> 和 <code>file2</code> 硬链接到同一个文件</td></tr></tbody></table><h5 id="2-字符串判断"><a href="#2-字符串判断" class="headerlink" title="2. 字符串判断"></a><strong>2. 字符串判断</strong></h5><p>用于比较字符串内容。</p><table><thead><tr><th>条件</th><th>含义</th></tr></thead><tbody><tr><td><code>-z str</code></td><td>字符串长度为 0</td></tr><tr><td><code>-n str</code></td><td>字符串长度大于 0</td></tr><tr><td><code>str1 = str2</code></td><td>字符串相等</td></tr><tr><td><code>str1 != str2</code></td><td>字符串不相等</td></tr><tr><td><code>[ str ]</code></td><td>字符串非空，相当于 <code>-n str</code> 的简写</td></tr></tbody></table><h5 id="3-数值判断"><a href="#3-数值判断" class="headerlink" title="3. 数值判断"></a><strong>3. 数值判断</strong></h5><p>用于比较数值大小。</p><table><thead><tr><th>条件</th><th>含义</th></tr></thead><tbody><tr><td><code>num1 -eq num2</code></td><td>等于</td></tr><tr><td><code>num1 -ne num2</code></td><td>不等于</td></tr><tr><td><code>num1 -gt num2</code></td><td>大于</td></tr><tr><td><code>num1 -lt num2</code></td><td>小于</td></tr><tr><td><code>num1 -ge num2</code></td><td>大于等于</td></tr><tr><td><code>num1 -le num2</code></td><td>小于等于</td></tr></tbody></table><h4 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h4><h5 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [ condition ];<br><br>    #程序<br><br>fi<br><br>或者<br><br>if [ condition]<br><br>   then <br><br>      #程序<br><br>   elif [ condition ]<br><br>    then<br><br>       #程序<br><br>fi<br></code></pre></td></tr></table></figure><h5 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">case variable in<br>    pattern1)<br>        # 当 variable 匹配 pattern1 时执行的命令<br>        command1<br>        ;;<br>    pattern2)<br>        # 当 variable 匹配 pattern2 时执行的命令<br>        command2<br>        ;;<br>    pattern3||pattern4)<br>        # 当 variable 匹配 pattern3 或 pattern4 时执行的命令<br>        command3<br>        ;;<br>    *)<br>        # 默认情况下（没有匹配时）执行的命令<br>        default_command<br>        ;;<br>esac<br></code></pre></td></tr></table></figure><p><img src="/%5Cimages%5C2024-12-17-9.png" alt="9"></p><h5 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for variable in list<br>do<br>    commands<br>done<br></code></pre></td></tr></table></figure><p><img src="/%5Cimages%5C2024-12-17-10.png" alt="10"></p><table><thead><tr><th>表达式</th><th>参数拆分方式</th><th>输出形式</th></tr></thead><tbody><tr><td><code>$*</code></td><td>不加引号时，会将参数按 <code>IFS</code> 分隔后拆分成多个部分</td><td>分裂后的多个单独参数</td></tr><tr><td><code>&quot;$*&quot;</code></td><td>加引号后，所有参数被拼接成一个整体，保留空格或其他分隔符</td><td>一个完整的字符串</td></tr><tr><td>“$@”</td><td>每个参数是独立的，保持原样</td><td>分裂后的多个单独参数</td></tr></tbody></table><p>C++风格</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for (( 初始化; 条件; 更新 ))<br>do<br>    commands<br>done<br></code></pre></td></tr></table></figure><h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">while [ 条件 ]<br>do<br>    commands<br>done<br></code></pre></td></tr></table></figure><p><img src="/images%5C2024-12-17-11.png" alt="2024-12-17-11"></p>]]></content>
    
    
    <categories>
      
      <category>学习日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024-12-13</title>
    <link href="/2024/12/13/2024-12-13/"/>
    <url>/2024/12/13/2024-12-13/</url>
    
    <content type="html"><![CDATA[<h2 id="2024-12-13"><a href="#2024-12-13" class="headerlink" title="2024-12-13"></a>2024-12-13</h2><h3 id="组管理和权限管理"><a href="#组管理和权限管理" class="headerlink" title="组管理和权限管理"></a>组管理和权限管理</h3><h4 id="组介绍："><a href="#组介绍：" class="headerlink" title="组介绍："></a><strong>组介绍：</strong></h4><p>linux每个用户都必须属于一个组，不能独立于组外，在linux每个文件有所有者，所在组，其他组的概念。</p><p>查看所有者：<strong>ls  -ahl</strong></p><p>修改所有者：<strong>chown（change owner)  用户名 文件名</strong></p><p>chown newowner:newgroup file 改变所有者和所有组</p><p>-R 如果是目录 使其下所有的子文件和目录递归生效</p><p>造成所有者和所在组可能不一样</p><p>修改文件所在组：<strong>chgrp 组名 文件名</strong></p><p><strong>除文件的所有者和所有则的文件外，其他用户就是其他组</strong></p><h4 id="权限介绍"><a href="#权限介绍" class="headerlink" title="权限介绍"></a>权限介绍</h4><h5 id="案例详解"><a href="#案例详解" class="headerlink" title="案例详解"></a>案例详解</h5><p><strong>-rw-r–r– 1  tom police 6 3月 18 19:24 ok.txt</strong></p><p>文件类型：</p><p>-普通文件 d目录 l软链接 c字符设备【键盘，鼠标】 b块文件，硬盘</p><p>-文件类型  rw-文件所有者权限 r–文件所在组权限 r–文件其他组用户权限</p><p>1 如果是文件，表示硬链接数目  如果是目录则表示该目录的子目录个数</p><p>tom 代表文件所有者 police 代表文件所在组</p><p>6代表文件大小 如果是目录会显示4096</p><p>3月 18 19:24 文件最后修改时间</p><p>ok.txt 文件名称</p><h5 id="rwx权限介绍"><a href="#rwx权限介绍" class="headerlink" title="rwx权限介绍"></a>rwx权限介绍</h5><p>rwx作用到文件 r代表可读 </p><p>w代表可写，但不代表可以删除，删除一个文件的前题是对该文件所在的目录有写权限，才能删除该文件</p><p>x代表可执行</p><p>rwx作用到目录 r代表可以读取，ls查看目录内容</p><p>w代表可以修改，目录内创建+删除+重命名目录</p><p>x代表可执行，可以进入该目录</p><h4 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h4><p><strong>chmod</strong> 修改文件或者目录权限</p><p><strong>第一种方式： + - &#x3D; 变更权限</strong></p><p>u所有者 g所在组 o其他人 a所有人</p><p>chmod u-x,g+w abc.txt</p><p><strong>第二种方式：通过数字变更权限</strong></p><p> r &#x3D; 4 w &#x3D; 2 x &#x3D; 1</p><p>chmod  755 abc.txt</p><h3 id="实践：警察和土匪游戏"><a href="#实践：警察和土匪游戏" class="headerlink" title="实践：警察和土匪游戏"></a>实践：警察和土匪游戏</h3><p>police： jack, jerry  bandit(土匪) ： xh xq</p><h4 id="1-创建组"><a href="#1-创建组" class="headerlink" title="1.创建组"></a>1.创建组</h4><h4 id="2-创建用户"><a href="#2-创建用户" class="headerlink" title="2.创建用户"></a>2.创建用户</h4><h4 id="3-jack创建一个文件，自己可以读写，本组人可以读，其他组没有任何权限"><a href="#3-jack创建一个文件，自己可以读写，本组人可以读，其他组没有任何权限" class="headerlink" title="3. jack创建一个文件，自己可以读写，本组人可以读，其他组没有任何权限"></a>3. jack创建一个文件，自己可以读写，本组人可以读，其他组没有任何权限</h4><h4 id="4-jack修改该文件，让其他组人可以读，本组人可以读写"><a href="#4-jack修改该文件，让其他组人可以读，本组人可以读写" class="headerlink" title="4. jack修改该文件，让其他组人可以读，本组人可以读写"></a>4. jack修改该文件，让其他组人可以读，本组人可以读写</h4><h4 id="5-xh-投靠警察，使小红可以读写jack的文件"><a href="#5-xh-投靠警察，使小红可以读写jack的文件" class="headerlink" title="5. xh 投靠警察，使小红可以读写jack的文件"></a>5. xh 投靠警察，使小红可以读写jack的文件</h4><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><h4 id="定时任务调度"><a href="#定时任务调度" class="headerlink" title="定时任务调度"></a>定时任务调度</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>crontab -e编辑定时任务  -l查询crontab任务 -r删除当前用户所有的crontab任务</p><p>service crond restart 重启任务调度</p><p>如果只是简单的任务，不用写脚本，直接在crontab加入任务即可，对于比较浮渣的任务，需要写脚本（shell)</p><h5 id="任务步骤"><a href="#任务步骤" class="headerlink" title="任务步骤"></a>任务步骤</h5><p><strong>占位符说明</strong> </p><p>每行的语法为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">复制代码<br>分钟 小时 日 月 星期 命令<br></code></pre></td></tr></table></figure><p>各个占位符的具体含义和范围是：</p><table><thead><tr><th>占位符</th><th>描述</th><th>取值范围</th></tr></thead><tbody><tr><td>分钟</td><td>指定分钟</td><td>0-59</td></tr><tr><td>小时</td><td>指定小时</td><td>0-23</td></tr><tr><td>日</td><td>指定日期</td><td>1-31</td></tr><tr><td>月</td><td>指定月份</td><td>1-12 或 <code>JAN-DEC</code></td></tr><tr><td>星期</td><td>指定星期几</td><td>0-7 (0 和 7 都表示星期天) 或 <code>SUN-SAT</code></td></tr><tr><td>命令</td><td>要执行的命令</td><td>任意有效的 Shell 命令</td></tr></tbody></table><p>特殊符号</p><ol><li><p>**星号 (<code>*</code>)**：表示任意值。例如，<code>* * * * *</code> 表示每分钟执行一次任务。</p></li><li><p>**逗号 (<code>,</code>)**：列举多个值。例如，<code>0,15,30,45 * * * *</code> 表示每小时的第 0、15、30 和 45 分钟执行。</p></li><li><p>**连字符 (<code>-</code>)**：表示范围。例如，<code>1-5 * * * *</code> 表示每小时的第 1 到第 5 分钟执行。</p></li><li><p>**斜线 (<code>*/n</code>)**：表示步进。例如，<code>*/5 * * * *</code> 表示每 5 分钟执行一次。</p></li><li><p>**问号 (<code>?</code>)**：在某些 Crontab 变种中，用于占位（通常与 <code>星期</code> 或 <code>日期</code> 配合使用，表示不指定）。这种写法多用于 Quartz 定时器，而非传统的 Crontab。</p></li><li><p>**井号 (<code>#</code>)**：用于指定每月的第几周。例如，<code>5 0 1 * 4#2</code> 表示在每月的第二个星期四的 00:05 执行。</p></li><li><p>cd &#x2F;home&#x2F;</p></li><li><p>vim mytask.sh</p></li><li><p>输入date &gt;&gt;&#x2F;tmp&#x2F;mydate.txt</p></li><li><p>修改权限为可执行 chmod 744 mytask.sh</p></li><li><p>crontab -e (所用定时任务都在一个文件里面)</p></li><li><p>*&#x2F;1 * * * * ls -l &#x2F;etc &gt;&gt; &#x2F;tmp&#x2F;to.txt</p><p>*&#x2F;1 * * * * &#x2F;home&#x2F;mytask.sh</p></li></ol><h3 id="磁盘分区和挂载"><a href="#磁盘分区和挂载" class="headerlink" title="磁盘分区和挂载"></a>磁盘分区和挂载</h3><h4 id="分区基础知识"><a href="#分区基础知识" class="headerlink" title="分区基础知识"></a>分区基础知识</h4><p>1 mbr分区，gtp分区，主分区数量增加，分区最大容量增加</p><p>2 windows磁盘分区 主分区 扩展分区（可以分为逻辑分区）</p><p>3 linux分区 linux无论有几个分区，分给哪一目录使用，归根结底只有一个根目录，一个独立且唯一的文件结构，linux中每个分区都是来组成文件系统的一部分</p><p>linux采用了一种叫做mount(挂载)的处理方法，它的整个文件系统包含了一整套的文件和目录，且将一个分区和一个目录联系起来。</p><p>4 在linux中如何对硬盘进行标号</p><p><strong>lsblk -f&#x2F;lsblk</strong>查看系统分区域挂载的情况</p><p><strong><code>sdx~</code> 的含义</strong></p><ul><li>**<code>s</code>**：表示 SCSI（包括 SATA 和 SAS）设备，但实际上现代系统中也用来标识基于 USB 或 NVMe 接口的设备。</li><li>**<code>d</code>**：代表磁盘（Disk）。</li><li><code>x</code>：代表设备的字母序号，a表示第一个磁盘，b表示第二个磁盘，依此类推。</li></ul><p>设备后缀</p><ul><li><code>sda1</code>、<code>sda2</code> 等：数字后缀表示该磁盘上的分区编号。从5开始后就是逻辑分区</li></ul><h4 id="增加一块磁盘"><a href="#增加一块磁盘" class="headerlink" title="增加一块磁盘"></a>增加一块磁盘</h4><p>1.虚拟机添加磁盘</p><p>2.分区 fdisk &#x2F;dev&#x2F;sdb   n   p   1   1   w</p><p>3.格式化 mkfs -t ext4 &#x2F;dev&#x2F;sdb1</p><p>4.挂载 先创建一个 &#x2F;home&#x2F;newdisk ,挂载 mount &#x2F;dev&#x2F;sdb1 &#x2F;home&#x2F;newdisk</p><p>5.设置永久挂载  vim &#x2F;etc&#x2F;fstab</p><p>&#x2F;dev&#x2F;sdb1         &#x2F;home&#x2F;newdisk        ext4     defaults       0 0</p><h4 id="磁盘情况查询"><a href="#磁盘情况查询" class="headerlink" title="磁盘情况查询"></a>磁盘情况查询</h4><p><strong>df -h</strong>  系统整体使用情况</p><p><strong>du -h &#x2F;目录</strong> </p><p>某个目录使用情况   -s 指定目录占用大小汇总  -a含文件    -c列出明细的同时，增加汇总值    –max-depth&#x3D;1 子目录深度</p><p>du -ach –max-depth&#x3D;1 &#x2F;opt</p><p>统计某个目录下有多少文件</p><p>ls -l &#x2F;home | grep “^-“ | wc -l  wc是统计的意思</p><p>统计&#x2F;home文件夹下目录个数</p><p>ls -l &#x2F;home | grep “^d” | wc -l </p><p>统计&#x2F;home文件夹下文件个数，包括子文件夹里的</p><p>ls -lR &#x2F;home | grep “^d” | wc -l </p><p>以树状形式查看目录</p><p>yum install tree</p><p>tree &#x2F;home&#x2F;</p>]]></content>
    
    
    <categories>
      
      <category>学习日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024-12-12</title>
    <link href="/2024/12/12/2024-12-12/"/>
    <url>/2024/12/12/2024-12-12/</url>
    
    <content type="html"><![CDATA[<h2 id="2024-12-12"><a href="#2024-12-12" class="headerlink" title="2024-12-12"></a>2024-12-12</h2><h3 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h3><p>YAML Front Matter 是一种用于在文本文件（如Markdown文件）中定义元数据的格式。它通常位于文件的顶部，由三个连续的短横线（<code>---</code>）包围的区域，用于指定个别文件的变量和配置信息。这些元数据可以包括文件的标题、日期、标签、类别等，也可以用于控制页面的布局和版本控制等。</p><p>YAML（Yet Another Markup Language）是一种轻量级的数据序列化格式，它易于人类阅读和编写，同时也易于机器解析和生成。</p><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p><strong>linux系统是一个多用户多任务的操作系统，任何一个使用系统资源的用户，都必须向系统管理员申请一个账号，然后以这个账号的身份进入系统</strong></p><p>用户归属于用户组  每个用户属于一个或多个组  root属于root组</p><p>家目录 &#x2F;home&#x2F; 目录下有各个创建的用户对应的家目录，当用户登录时自动进入自己的家目录</p><p><strong>添加用户</strong></p><p>useradd [选项，可以不选] 用户名   没有指定家目录，会自动创建与该用户同名的子家目录，并将该用户添加到家目录中，也就是创建&#x2F;home的目录</p><p><strong>useradd -d &#x2F;home&#x2F;llj</strong> 向指定目录添加用户 直接建新目录</p><p><strong>用户组没有指定，自动创建同名用户组</strong></p><p><strong>cd 切换目录</strong> change director</p><p><strong>passwd 用户名</strong> 指定密码</p><p><strong>mkdir</strong> make director 创建目录 添加用户</p><p><strong>删除目录</strong></p><p><strong>userdel 用户 删除用户</strong>，但是保留家目录</p><p><strong>userdel -r 用户 删除用户</strong>，并且家目录</p><p><strong>在删除用户时，一般要保留家目录，因为有一些文件需要保留</strong></p><p><strong>id 用户</strong>  查询用户信息</p><p><strong>su - 切换用户名</strong>  高权限用户进入低权限用户不需要输密码</p><p><strong>exit</strong> 回退到初始用户</p><p><strong>whoami</strong> 查看当前是那个用户</p><h4 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h4><p>类似于角色，系统能够可以对用共性的多个用户进行统一的管理</p><p><strong>groupadd</strong> 组名 添加用户组</p><p><strong>clean</strong> 清屏</p><p><strong>groupdel</strong> 组名 删除用户组</p><p><strong>useradd -g 用户组 用户名</strong> 添加有归属的用户</p><p><strong>usermod -g 用户组 用户名</strong> 修改用户所属用户组</p><p><strong>&#x2F;etc&#x2F;passwd</strong> 用户配置信息</p><p>用户名：口令x(指代密码):用户id:组id::家目录：shell</p><p><strong>&#x2F;etc&#x2F;grroup</strong> 组配置信息</p><p>组名：口令x:组id:组内用户列表</p><p><strong>&#x2F;etc&#x2F;shadow</strong>(阴影) 口令配置信息（密码和登录信息，加密）</p><p>注意： <strong>路径问题</strong></p><p>如果你运行的是 <code>vim etc/passwd</code>，而不是 <code>vim /etc/passwd</code>，系统会尝试在当前工作目录下寻找 <code>etc/passwd</code> 文件，而不是全局的 <code>/etc/passwd</code> 文件。如果当前目录中没有该文件，Vim 会新建一个空文件。</p><p><strong>解决办法</strong>：明确指定路径，运行 <code>vim /etc/passwd</code>。</p><h3 id="实用指令"><a href="#实用指令" class="headerlink" title="实用指令"></a>实用指令</h3><h4 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a><strong>运行级别</strong></h4><p>0：关机  1：单用户  2：多用户无网络  <strong>3：多用户有网络</strong>  4：系统保留  5：图形界面  6：重启</p><p><strong>系统的运行级别配置文件 &#x2F;etc&#x2F;inittab</strong>  tab(标签)</p><p><strong>init 运行级别</strong> 切换到指定运行级别</p><p><strong>cat 文件</strong> 查看文件</p><h4 id="SysVinit和Systemd"><a href="#SysVinit和Systemd" class="headerlink" title="SysVinit和Systemd"></a>SysVinit和Systemd</h4><h5 id="SysVinit"><a href="#SysVinit" class="headerlink" title="SysVinit"></a><strong>SysVinit</strong></h5><ul><li><strong>SysVinit</strong> 是一种传统的初始化系统，源自 Unix 的 <strong>System V</strong> 体系。</li><li>它负责管理系统的启动流程，包括启动服务、挂载文件系统、进入特定运行级别（Runlevel）等。</li><li>配置文件位于 <code>/etc/inittab</code>，通过运行级别（如 <code>0</code>、<code>1</code>、<code>2</code> 等）来定义系统的工作状态。</li><li>常见的服务脚本存放在 <code>/etc/init.d</code>。</li></ul><hr><h5 id="Systemd"><a href="#Systemd" class="headerlink" title="Systemd"></a><strong>Systemd</strong></h5><ul><li><strong>Systemd</strong> 是一种现代化的初始化系统，旨在克服 SysVinit 的局限性，为 Linux 系统提供更快、更可靠的启动和服务管理。</li><li>它使用并行化技术，加快了启动速度，同时引入了服务依赖管理和监控功能。</li><li>配置文件分布在 <code>/etc/systemd/</code> 和 <code>/lib/systemd/system</code> 下，以 <code>.service</code> 文件为主。</li><li>Systemd 不仅是初始化系统，还提供了许多附加功能，例如日志管理（<code>journald</code>）和设备管理（<code>udevd</code>）。</li></ul><hr><h5 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a><strong>主要区别</strong></h5><table><thead><tr><th>特性</th><th>SysVinit</th><th>Systemd</th></tr></thead><tbody><tr><td><strong>设计理念</strong></td><td>单线程、串行启动</td><td>并行化、多线程启动</td></tr><tr><td><strong>服务管理</strong></td><td>服务启动顺序需手动配置</td><td>自动管理服务依赖，按需启动</td></tr><tr><td><strong>启动速度</strong></td><td>启动速度较慢，不能并行化</td><td>启动速度快，支持并行化</td></tr><tr><td><strong>配置文件</strong></td><td><code>/etc/inittab</code> 和 <code>/etc/init.d</code></td><td><code>/etc/systemd/</code> 和 <code>.service</code> 文件</td></tr><tr><td><strong>运行级别</strong></td><td>使用运行级别（Runlevel）</td><td>使用目标（Target），更灵活</td></tr><tr><td><strong>监控和恢复</strong></td><td>缺乏内建服务监控功能</td><td>内建服务监控和自动恢复</td></tr><tr><td><strong>日志管理</strong></td><td>使用传统日志（如 <code>/var/log</code>）</td><td>集中式日志管理，通过 <code>journald</code></td></tr><tr><td><strong>依赖管理</strong></td><td>手动配置服务依赖</td><td>自动检测和管理服务依赖</td></tr><tr><td><strong>扩展功能</strong></td><td>无扩展功能</td><td>提供诸多功能，如 <code>timedatectl</code> 和 <code>networkd</code></td></tr><tr><td><strong>启动顺序</strong></td><td>严格按照脚本文件顺序启动</td><td>根据依赖动态调整启动顺序</td></tr><tr><td><strong>兼容性</strong></td><td>兼容旧版 UNIX 系统</td><td>主流 Linux 发行版的默认选项</td></tr></tbody></table><p><strong>如何找回丢失的root密码</strong></p><p>因为进入单用户模式，root不需要密码，进入到单用户模式，然后修改root密码</p><p>开机，在引导是输入回车，看到界面输入e,  新界面选中第二行输入e, 输入1，回车，输入b,进入单用户模式，修改passwd</p><h4 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h4><p>当我们对某个指令不熟悉时</p><p>man [命令&#x2F;配置文件]  entry(登记) format(格式)</p><p>help 命令 用法</p><h4 id="文件目录类"><a href="#文件目录类" class="headerlink" title="文件目录类"></a>文件目录类</h4><p><strong>目录结尾加&#x2F; 文件不叫 绝对路径开头加&#x2F; 相对路径开头不加&#x2F;</strong></p><p><strong>pwd</strong> 显示当前目录的绝对路径</p><p><strong>ls</strong> [目录或是文件] <strong>-a</strong> 包括隐藏的 <strong>-l</strong> 详细信息，以列表形式显示 -al ll是ls -l的别名</p><p><strong>cd</strong> 切换目录  <code>..</code> 的含义：当前路径的父目录，即去掉最后一层路径。</p><p>cd ~或者 cd 回到自己的家目录 cd ..回到当前目录的上一级 </p><p><strong>mkdir</strong> 创建目录 -p 创建多级目录 绝对路径或者相对路径</p><p><strong>rmdir</strong> 删除空目录 如果有内容是无法删除的  强制删除 rm -rf</p><p><strong>touch</strong> 创建新文件 在当前目录下 可以一次性创键多个文件</p><p><strong>CP</strong>  拷贝某文件到某目录下  cp aaa.txt bbb&#x2F;  -r(递归拷贝) 可以拷贝整个目录到另一个目录  \cp -r aaa&#x2F; bbb&#x2F; 强制覆盖，如果bbb&#x2F;目录下已经有aaa&#x2F;目录下的某个文件，\cp可以强制覆盖，不会提示</p><p><strong>rm</strong>  删除文件或目录  -rf(删除整个目录) -f(取消提示)</p><p><strong>mv</strong> 移动文件或者重命名 </p><p>mv 原名 新名（就在当前目录）重命名 mv aaa.txt bbb.txt</p><p>mv pig.txt &#x2F;root&#x2F; 移动文件</p><p><strong>cat</strong>  查看文件内容 以只读的方式打开 -n显示行号  加上管道命令 |more 进行分页显示</p><p>cat -n &#x2F;etc&#x2F;file | more</p><p><strong>more</strong> 以全屏的方式一次性显示文件  空格 下一页  enter 下一行 ctrl F下一页 ctrl B上一页</p><p><strong>less</strong> 一页一页全屏显示，大型文件查看</p><p><strong>&gt;指令和&gt;&gt;指令</strong>  &gt;输出重定向，会覆盖原文件内容  &gt;&gt;追加到该文件末尾 </p><p><strong>echo</strong> 输出内容到控制台</p><p><strong>head</strong> 显示文件开头内容（10行）  -n 5 指定行数</p><p><strong>tail</strong>  显示文件末尾内容（10行）  -n 5 指定行数  <strong>tail -f 实时追踪文件的更新</strong></p><p><strong>ln -s</strong> 类似于windows里面的快捷方式  </p><p>ln -s &#x2F;root linkToRoot rm -rf linkToRoot</p><p><strong>histoty</strong> 查看已经执行过的历史命令，也可以执行历史指令 history histoty 10</p><p><strong>!178</strong> 执行178这个指令</p><h4 id="时间日期类"><a href="#时间日期类" class="headerlink" title="时间日期类"></a>时间日期类</h4><p><strong>date</strong> 显示当前日期 date  date+%Y 年 date+%m  %d </p><p><strong>date “+Y</strong>年**%m<strong>月</strong>%d<strong>日</strong>%H<strong>时</strong>%M<strong>分</strong>%S<strong>秒</strong>“**</p><p><strong>date -s 设置时间</strong> date -s “2018-10-10 11-22-22”</p><p><strong>cal 显示日历</strong> cal 2024 显示某一年日历</p><h4 id="搜索查找类"><a href="#搜索查找类" class="headerlink" title="搜索查找类"></a>搜索查找类</h4><p><strong>find [搜索范围] [选项]</strong> </p><p>-name 查询方式为名字 -user 文件拥有者 -size +20M  -20M 20M  *.txt</p><p><strong>locate</strong>  快速定位文件路径</p><p>需要先使用updatedb 创建locate数据库  然后locate hello.txt</p><p><strong>| 管道命令</strong>，表示将前一个命令的处理结果传递给后面的命令处理</p><p><strong>grep [选项] 查找内容 源文件</strong>  <strong>-n显示匹配行号，-i忽略字母大小写</strong></p><p><strong>cat hello.txt | grep yes</strong> </p><h4 id="压缩和解压缩类"><a href="#压缩和解压缩类" class="headerlink" title="压缩和解压缩类"></a>压缩和解压缩类</h4><p><strong>gzip&#x2F;gunzip</strong>  压缩和解压缩文件</p><p>使用gzip对文件进行压缩后，不会保留原文件  </p><p><strong>zip&#x2F;unzip</strong> -r(压缩目录)  -d(指定压缩目录)</p><p>zip -r mypackage.zip &#x2F;home&#x2F; 将home目录压缩成mypackage.zip放到当前目录</p><p>zip -d &#x2F;opt&#x2F;tmp&#x2F; maypackage.zip 将maypackage.zip解压到&#x2F;opt&#x2F;tmp&#x2F;目录下</p><p><strong>tar</strong> </p><p>-c产生.tar打包文件 -v显示详细信息 -f指定压缩后的文件名 -z打包的同时压缩 -x解包.tar文件</p><p>tar -zcvf a.tar.gz a1.txt a2.txt  将a1.txt a2.txt打包并压缩成a.tar.gz</p><p>tar -zcvf myhome.tar.gz &#x2F;home&#x2F; 将&#x2F;home&#x2F;打包压缩成myhome.tar.gz</p><p>tar -zxvf a.tar.gz 解压a.tar.gz</p><p>tar -zxvf myhome.tar.gz -C &#x2F;opt&#x2F; 解压myhome.tar.gz 到&#x2F;opt&#x2F;</p>]]></content>
    
    
    <categories>
      
      <category>学习日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024-12-11</title>
    <link href="/2024/12/11/2024-12-11/"/>
    <url>/2024/12/11/2024-12-11/</url>
    
    <content type="html"><![CDATA[<h3 id="2024-12-11"><a href="#2024-12-11" class="headerlink" title="2024-12-11"></a>2024-12-11</h3><h4 id="vi和vim基本介绍"><a href="#vi和vim基本介绍" class="headerlink" title="vi和vim基本介绍"></a>vi和vim基本介绍</h4><p>vim是vi的增强版本，具有程序编辑能力</p><h4 id="vi和vim的三种常见模式"><a href="#vi和vim的三种常见模式" class="headerlink" title="vi和vim的三种常见模式"></a>vi和vim的三种常见模式</h4><p><strong>1.正常模式</strong></p><p><strong>快捷键：</strong></p><p>默认模式，在正常模式下可以使用快捷键</p><p>Nyy: yy复制当前行，3yy当前3行</p><p>p: 粘贴</p><p>Ndd: 删除当前行</p><p>&#x2F;加单词：先用&#x2F;进入命令行模式，在输入单词即可查找</p><p>：set nu和：set nonu :加入行号，取消行号</p><p>G和gg: 末行和首行</p><p>u: 撤销动作</p><p>光标移动到20行： ：set nu 输入20 输入shift g</p><p><strong>按下i,l,o,O,a,A,r,R等任何一个字母都会进入编辑模式，一般按下i即可</strong></p><p><strong>按：或者&#x2F;进入命令行模式</strong></p><p><strong>2.插入模式</strong></p><p>进行编辑</p><p><strong>3.命令行模式</strong></p><p>：wq保存退出，：q！强制退出  无修改：q退出</p><p>完成读取，存盘，替换，离开，显示行号等动作</p><p><strong>按esc进入正常模式</strong></p><p>ll 显示当前目录文件</p><h4 id="关机和重启"><a href="#关机和重启" class="headerlink" title="关机和重启"></a>关机和重启</h4><p>shutdown</p><p>​shutdown -h now :立即关机</p><p>​shutdown -1 now :1分钟后关机</p><p>​shutdown -r now :立即重启</p><p>halt（停止） 关机</p><p>reboot  重启</p><p>sync（同步）  保存，将内存的数据同步到磁盘上</p><p>su  - 用户名 切换系统管理员</p><p>logout 注销用户 只针对远程登录</p>]]></content>
    
    
    <categories>
      
      <category>学习日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024-12-10</title>
    <link href="/2024/12/10/2024-12-10/"/>
    <url>/2024/12/10/2024-12-10/</url>
    
    <content type="html"><![CDATA[<h3 id="2024-12-10"><a href="#2024-12-10" class="headerlink" title="2024-12-10"></a>2024-12-10</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><img src="/images/1.jpg" alt="1"></p><p>linux内核：centos redhat ubuntu suse fedora(发行版)</p><p>操作系统：windows android  linux 车载系统 </p><p>linux和unix的关系：linux是基于unix的开源操作系统</p><p>远程操作系统操作机房–命令行操作</p><p><strong>windows和VM和centos关系:</strong></p><p>VM软件可以在windows上创建一个虚拟机空间，而centos则装在这个空间上</p><p>而这个这个centos可以移植，用其他的vm打开</p><p>deprecate 反对</p><h4 id="虚拟机网络连接模式"><a href="#虚拟机网络连接模式" class="headerlink" title="虚拟机网络连接模式"></a><em>虚拟机网络连接模式</em></h4><p>桥接模式：虚拟机ip地址与宿主机ip地址在同一个网段 </p><p>可能会出现ip地址冲突，只有253个地址 0是网络号，255是广播</p><p>NAT模式：网络地址转换方式：宿主机会重新创建一个虚拟ip地址，而linux系统能在这个虚拟ip网段创建新的地址，linux可以访问外网，不会造成ip冲突，但是外网不能找到虚拟机</p><p>主机模式：linux是一个独立的主机，不能访问外网</p><p><strong>VMnet0网口对应的是桥接模式</strong></p><p><strong>VMnet8网口对应的是NAT模式</strong></p><p><strong>VMnet1网口对应的是仅主机模式</strong></p><p>linux磁盘分区至少有三个 根分区 swap分区 boot分区</p><p>重启指令 reboot</p><p>共享文件夹默认放在centos 的 &#x2F;mnt&#x2F;hgfs 下</p><h4 id="linux目录结构"><a href="#linux目录结构" class="headerlink" title="linux目录结构"></a>linux目录结构</h4><p>树状目录结构 &#x2F;根目录</p><p><strong>在linux世界里，一切皆文件</strong> （所有东西都映射为文件）</p><p><strong>bin：</strong>binary  常用的命令</p><p><strong>sbin:</strong>  系统管理员使用的系统管理程序</p><p><strong>home：</strong>存放普通用户的主目录，在linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的</p><p><strong>root:</strong>   系统管理员 <strong>root&#x2F;desktop</strong> 桌面在这个之下</p><p>lib:   系统开机所需要的最基本的动态链接共享库，类似windows中的dll文件</p><p>DLL文件的作用是将程序中的一些功能模块化和共享化，避免重复开发和占用过多存储空间</p><p>lost+found: 系统非法关机，存放文件</p><p>dev:  管理设备，如cpu等等</p><p><strong>etc:</strong>    系统管理所需要的配置文件和子目录</p><p><strong>usr:</strong>    用户安装的很多应用程序和文件都存放在这个目录，类似于windows下的program fils目录</p><p><strong>boot:</strong>  启动linux的一些核心文件，包括一些连接文件和镜像文件</p><p>proc:  srv:  sys： 这三个最好别动</p><p>tmp:   临时文件</p><p><strong>media:</strong> U盘，光驱等，linux会将识别的设备挂载到这个目录下</p><p><strong>mnt:</strong>    为了让用户临时挂载别的文件系统的，可以将外部的存储挂载到这上面，进入该目录就可以查看里面的内容</p><p><strong>opt:</strong>   存放安装之前的软件</p><p><strong>usr&#x2F;local:</strong>  安装过后的软件</p><p><strong>var:</strong>    不断扩充的东西，变量，日志</p><p>selinux: 安全相关</p><p>远程登录<strong>xshell</strong> 远程上传文件<strong>xftp</strong></p><p>需要linux服务器开启sshd服务，22号端口</p><p><strong>ifconfig</strong> 查看ip</p>]]></content>
    
    
    <categories>
      
      <category>学习日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024-12-09</title>
    <link href="/2024/12/09/2024-12-09/"/>
    <url>/2024/12/09/2024-12-09/</url>
    
    <content type="html"><![CDATA[<h3 id="2024-12-09"><a href="#2024-12-09" class="headerlink" title="2024-12-09"></a>2024-12-09</h3><p>B&#x2F;S和C&#x2F;S</p><p><strong>B&#x2F;S 架构：</strong> 基于浏览器和服务器的架构，用户通过浏览器访问服务器上的应用程序。</p><p><strong>C&#x2F;S 架构：</strong> 基于客户端和服务器的架构，需要专门的客户端软件来与服务器进行交互。</p><p>Browser:浏览器</p><p>服务器程序通常需要处理三类事件：I&#x2F;O事件，信号及定时事件。有两种事件处理模式：</p><p><strong>Reactor模式：</strong>要求主线程（I&#x2F;O处理单元）只负责监听文件描述符上是否有事件发生（可读、可写），若有，则立即通知工作线程（逻辑单元），将socket可读可写事件放入请求队列，交给工作线程处理。这个过程是同步的，读取完数据后应用进程才能处理数据。<br><strong>Proactor模式：</strong>将所有的I&#x2F;O操作都交给主线程和内核来处理（进行读、写），工作线程仅负责处理逻辑，如主线程读完成后users[sockfd].read()，选择一个工作线程来处理客户请求pool-&gt;append(users + sockfd)。</p><p><strong>无论是 Reactor，还是 Proactor，都是一种基于「事件分发」的网络编程模式，区别在于 Reactor 模式是基于「待完成」的 I&#x2F;O 事件，而 Proactor 模式则是基于「已完成」的 I&#x2F;O 事件。</strong></p><p><strong>文件描述符 (File Descriptor)</strong> 是操作系统中用于标识打开文件的整数标识符，常见于类 Unix 系统。</p><p><strong><code>std::atomic</code>的作用：</strong></p><p><strong><code>std::atomic</code>：</strong></p><ul><li>提供对某些变量的<strong>原子操作支持</strong>，避免多线程操作时的数据竞争（Data Race）。</li><li>确保对变量的操作是线程安全的，操作不可分割。</li><li>典型操作包括：读取、写入、加减等，所有操作会在硬件级别（如CPU指令）上保持一致性。</li></ul><p><strong><code>std::size_t</code>：</strong></p><ul><li>是一种无符号整数类型，用于表示内存大小或数组索引。</li><li>平台相关：在32位系统上通常为32位整数，在64位系统上通常为64位整数。</li><li>例如，<code>sizeof</code> 运算符的结果类型就是 <code>std::size_t</code>。</li></ul><p><strong>为什么使用<code>std::size_t</code>？</strong></p><ul><li><code>std::size_t</code> 是一种平台无关的无符号整数类型，专门用于表示对象的大小或数组的索引。</li><li>使用 <code>std::atomic&lt;std::size_t&gt;</code> 可以在线程安全的情况下操作这些大小或索引变量。</li></ul><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p><strong>单例模式是最常用的设计模式之一，目的是保证一个类只有一个实例，并提供一个他的全局访问点，该实例被所有程序模块共享。此时需要把该类的构造和析构函数放入private中。</strong></p><p>单例模式有两种实现方法，一种是懒汉模式，另一种是饿汉模式。</p><p><strong>懒汉模式：</strong> 顾名思义，非常的懒，只有当调用getInstance的时候，才会去初始化这个单例。其中在C++11后，不需要加锁，直接使用函数内局部静态对象即可。<br><strong>饿汉模式：</strong> 即迫不及待，在程序运行时立即初始化。饿汉模式不需要加锁，就可以实现线程安全，原因在于，在程序运行时就定义了对象，并对其初始化。之后，不管哪个线程调用成员函数getinstance()，都只不过是返回一个对象的指针而已。所以是线程安全的，不需要在获取实例的成员函数中加锁。</p><h4 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h4><p><strong>什么是RAII？</strong></p><p>RAII是<strong>Resource Acquisition Is Initialization</strong>（wiki上面翻译成 “资源获取就是初始化”）的简称，是C++语言的一种管理资源、避免泄漏的惯用法。利用的就是C++构造的对象最终会被销毁的原则。RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。</p><p><strong>为什么要使用RAII？</strong></p><p>上面说到RAII是用来管理资源、避免资源泄漏的方法。那么，用了这么久了，也写了这么多程序了，口头上经常会说资源，那么资源是如何定义的？在计算机系统中，资源是数量有限且对系统正常运行具有一定作用的元素。比如：网络套接字、互斥锁、文件句柄和内存等等，它们属于系统资源。由于系统的资源是有限的，就好比自然界的石油，铁矿一样，不是取之不尽，用之不竭的，所以，我们在编程使用系统资源时，都必须遵循一个步骤：<br>1 申请资源；<br>2 使用资源；<br>3 释放资源。<br>第一步和第三步缺一不可，因为资源必须要申请才能使用的，使用完成以后，必须要释放，如果不释放的话，就会造成资源泄漏。</p><p>skip:跳过</p><p>cmd输入services.msc可以查看运行的服务</p><p>ipconfig&#x2F;ip a查看ip地址</p><p>hexo new post +文章名称</p><p>或者直接在post添加文件&#x2F;？</p><p>hexo clean</p><p>hexo generate</p><p>hexo deploy</p>]]></content>
    
    
    <categories>
      
      <category>学习日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++面经</title>
    <link href="/2024/12/09/C++%E9%9D%A2%E7%BB%8F/"/>
    <url>/2024/12/09/C++%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="1-讲一讲封装、继承、多态是什么？"><a href="#1-讲一讲封装、继承、多态是什么？" class="headerlink" title="1.讲一讲封装、继承、多态是什么？"></a>1.讲一讲封装、继承、多态是什么？</h3><p><strong>封装：</strong>封装指的是将数据（属性）和操作数据的行为（函数）封装到对象中，隐藏对象的内部细节，只暴露公共接口给外部使用。</p><p><strong>继承：</strong>派生类继承基类的数据成员和成员函数（基类私有成员可被继承，但是无法被访问），其中构造函数、析构函数、友元函数、静态数据变量、静态成员函数都不能被继承，但子类可以调用基类构造函数。派生类访问基类的共享资源 protected 成员对于所有派生类都是可用的，但对外隐藏。当父类中的成员变量或者类本身被final关键字修饰时，修饰的类不能被继承，修饰的成员函数不能重写或修改。</p><p><strong>多态：</strong>C++ 支持两种多态：</p><ol><li><strong>编译时多态</strong>（静态多态）：通过函数重载和运算符重载实现。</li><li><strong>运行时多态</strong>（动态多态）：通过虚函数（<code>virtual</code>）和继承实现。虚函数允许派生类重写基类方法。当基类的指针或引用指向派生类对象时，会调用派生类的实现，使得基类指针呈现不同的表现形式。</li></ol><h3 id="2-final标识符的作用是什么？"><a href="#2-final标识符的作用是什么？" class="headerlink" title="2. final标识符的作用是什么？"></a>2. final标识符的作用是什么？</h3><p>放在类的后面表示该类无法被继承，也就是阻止了从类的继承，放在虚函数后面该虚函数无法被重写，表示阻止虚函数的重载</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
